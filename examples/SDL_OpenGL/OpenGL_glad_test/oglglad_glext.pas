{
    Commandline:
        --profile="compatibility" --api="gl=1.0" --generator="pascal" --spec="gl" --extensions="GL_3DFX_multisample,GL_3DFX_tbuffer,GL_3DFX_texture_compression_FXT1,GL_AMD_blend_minmax_factor,GL_AMD_conservative_depth,GL_AMD_debug_output,GL_AMD_depth_clamp_separate,GL_AMD_draw_buffers_blend,GL_AMD_framebuffer_multisample_advanced,GL_AMD_framebuffer_sample_positions,GL_AMD_gcn_shader,GL_AMD_gpu_shader_half_float,GL_AMD_gpu_shader_int16,GL_AMD_gpu_shader_int64,GL_AMD_interleaved_elements,GL_AMD_multi_draw_indirect,GL_AMD_name_gen_delete,GL_AMD_occlusion_query_event,GL_AMD_performance_monitor,GL_AMD_pinned_memory,GL_AMD_query_buffer_object,GL_AMD_sample_positions,GL_AMD_seamless_cubemap_per_texture,GL_AMD_shader_atomic_counter_ops,GL_AMD_shader_ballot,GL_AMD_shader_explicit_vertex_parameter,GL_AMD_shader_gpu_shader_half_float_fetch,GL_AMD_shader_image_load_store_lod,GL_AMD_shader_stencil_export,GL_AMD_shader_trinary_minmax,GL_AMD_sparse_texture,GL_AMD_stencil_operation_extended,GL_AMD_texture_gather_bias_lod,GL_AMD_texture_texture4,GL_AMD_transform_feedback3_lines_triangles,GL_AMD_transform_feedback4,GL_AMD_vertex_shader_layer,GL_AMD_vertex_shader_tessellator,GL_AMD_vertex_shader_viewport_index,GL_APPLE_aux_depth_stencil,GL_APPLE_client_storage,GL_APPLE_element_array,GL_APPLE_fence,GL_APPLE_float_pixels,GL_APPLE_flush_buffer_range,GL_APPLE_object_purgeable,GL_APPLE_rgb_422,GL_APPLE_row_bytes,GL_APPLE_specular_vector,GL_APPLE_texture_range,GL_APPLE_transform_hint,GL_APPLE_vertex_array_object,GL_APPLE_vertex_array_range,GL_APPLE_vertex_program_evaluators,GL_APPLE_ycbcr_422,GL_ARB_ES2_compatibility,GL_ARB_ES3_1_compatibility,GL_ARB_ES3_2_compatibility,GL_ARB_ES3_compatibility,GL_ARB_arrays_of_arrays,GL_ARB_base_instance,GL_ARB_bindless_texture,GL_ARB_blend_func_extended,GL_ARB_buffer_storage,GL_ARB_cl_event,GL_ARB_clear_buffer_object,GL_ARB_clear_texture,GL_ARB_clip_control,GL_ARB_color_buffer_float,GL_ARB_compatibility,GL_ARB_compressed_texture_pixel_storage,GL_ARB_compute_shader,GL_ARB_compute_variable_group_size,GL_ARB_conditional_render_inverted,GL_ARB_conservative_depth,GL_ARB_copy_buffer,GL_ARB_copy_image,GL_ARB_cull_distance,GL_ARB_debug_output,GL_ARB_depth_buffer_float,GL_ARB_depth_clamp,GL_ARB_depth_texture,GL_ARB_derivative_control,GL_ARB_direct_state_access,GL_ARB_draw_buffers,GL_ARB_draw_buffers_blend,GL_ARB_draw_elements_base_vertex,GL_ARB_draw_indirect,GL_ARB_draw_instanced,GL_ARB_enhanced_layouts,GL_ARB_explicit_attrib_location,GL_ARB_explicit_uniform_location,GL_ARB_fragment_coord_conventions,GL_ARB_fragment_layer_viewport,GL_ARB_fragment_program,GL_ARB_fragment_program_shadow,GL_ARB_fragment_shader,GL_ARB_fragment_shader_interlock,GL_ARB_framebuffer_no_attachments,GL_ARB_framebuffer_object,GL_ARB_framebuffer_sRGB,GL_ARB_geometry_shader4,GL_ARB_get_program_binary,GL_ARB_get_texture_sub_image,GL_ARB_gl_spirv,GL_ARB_gpu_shader5,GL_ARB_gpu_shader_fp64,GL_ARB_gpu_shader_int64,GL_ARB_half_float_pixel,GL_ARB_half_float_vertex,GL_ARB_imaging,GL_ARB_indirect_parameters,GL_ARB_instanced_arrays,GL_ARB_internalformat_query,GL_ARB_internalformat_query2,GL_ARB_invalidate_subdata,GL_ARB_map_buffer_alignment,GL_ARB_map_buffer_range,GL_ARB_matrix_palette,GL_ARB_multi_bind,GL_ARB_multi_draw_indirect,GL_ARB_multisample,GL_ARB_multitexture,GL_ARB_occlusion_query,GL_ARB_occlusion_query2,GL_ARB_parallel_shader_compile,GL_ARB_pipeline_statistics_query,GL_ARB_pixel_buffer_object,GL_ARB_point_parameters,GL_ARB_point_sprite,GL_ARB_polygon_offset_clamp,GL_ARB_post_depth_coverage,GL_ARB_program_interface_query,GL_ARB_provoking_vertex,GL_ARB_query_buffer_object,GL_ARB_robust_buffer_access_behavior,GL_ARB_robustness,GL_ARB_robustness_isolation,GL_ARB_sample_locations,GL_ARB_sample_shading,GL_ARB_sampler_objects,GL_ARB_seamless_cube_map,GL_ARB_seamless_cubemap_per_texture,GL_ARB_separate_shader_objects,GL_ARB_shader_atomic_counter_ops,GL_ARB_shader_atomic_counters,GL_ARB_shader_ballot,GL_ARB_shader_bit_encoding,GL_ARB_shader_clock,GL_ARB_shader_draw_parameters,GL_ARB_shader_group_vote,GL_ARB_shader_image_load_store,GL_ARB_shader_image_size,GL_ARB_shader_objects,GL_ARB_shader_precision,GL_ARB_shader_stencil_export,GL_ARB_shader_storage_buffer_object,GL_ARB_shader_subroutine,GL_ARB_shader_texture_image_samples,GL_ARB_shader_texture_lod,GL_ARB_shader_viewport_layer_array,GL_ARB_shading_language_100,GL_ARB_shading_language_420pack,GL_ARB_shading_language_include,GL_ARB_shading_language_packing,GL_ARB_shadow,GL_ARB_shadow_ambient,GL_ARB_sparse_buffer,GL_ARB_sparse_texture,GL_ARB_sparse_texture2,GL_ARB_sparse_texture_clamp,GL_ARB_spirv_extensions,GL_ARB_stencil_texturing,GL_ARB_sync,GL_ARB_tessellation_shader,GL_ARB_texture_barrier,GL_ARB_texture_border_clamp,GL_ARB_texture_buffer_object,GL_ARB_texture_buffer_object_rgb32,GL_ARB_texture_buffer_range,GL_ARB_texture_compression,GL_ARB_texture_compression_bptc,GL_ARB_texture_compression_rgtc,GL_ARB_texture_cube_map,GL_ARB_texture_cube_map_array,GL_ARB_texture_env_add,GL_ARB_texture_env_combine,GL_ARB_texture_env_crossbar,GL_ARB_texture_env_dot3,GL_ARB_texture_filter_anisotropic,GL_ARB_texture_filter_minmax,GL_ARB_texture_float,GL_ARB_texture_gather,GL_ARB_texture_mirror_clamp_to_edge,GL_ARB_texture_mirrored_repeat,GL_ARB_texture_multisample,GL_ARB_texture_non_power_of_two,GL_ARB_texture_query_levels,GL_ARB_texture_query_lod,GL_ARB_texture_rectangle,GL_ARB_texture_rg,GL_ARB_texture_rgb10_a2ui,GL_ARB_texture_stencil8,GL_ARB_texture_storage,GL_ARB_texture_storage_multisample,GL_ARB_texture_swizzle,GL_ARB_texture_view,GL_ARB_timer_query,GL_ARB_transform_feedback2,GL_ARB_transform_feedback3,GL_ARB_transform_feedback_instanced,GL_ARB_transform_feedback_overflow_query,GL_ARB_transpose_matrix,GL_ARB_uniform_buffer_object,GL_ARB_vertex_array_bgra,GL_ARB_vertex_array_object,GL_ARB_vertex_attrib_64bit,GL_ARB_vertex_attrib_binding,GL_ARB_vertex_blend,GL_ARB_vertex_buffer_object,GL_ARB_vertex_program,GL_ARB_vertex_shader,GL_ARB_vertex_type_10f_11f_11f_rev,GL_ARB_vertex_type_2_10_10_10_rev,GL_ARB_viewport_array,GL_ARB_window_pos,GL_ATI_draw_buffers,GL_ATI_element_array,GL_ATI_envmap_bumpmap,GL_ATI_fragment_shader,GL_ATI_map_object_buffer,GL_ATI_meminfo,GL_ATI_pixel_format_float,GL_ATI_pn_triangles,GL_ATI_separate_stencil,GL_ATI_text_fragment_shader,GL_ATI_texture_env_combine3,GL_ATI_texture_float,GL_ATI_texture_mirror_once,GL_ATI_vertex_array_object,GL_ATI_vertex_attrib_array_object,GL_ATI_vertex_streams,GL_EXT_422_pixels,GL_EXT_EGL_image_storage,GL_EXT_EGL_sync,GL_EXT_abgr,GL_EXT_bgra,GL_EXT_bindable_uniform,GL_EXT_blend_color,GL_EXT_blend_equation_separate,GL_EXT_blend_func_separate,GL_EXT_blend_logic_op,GL_EXT_blend_minmax,GL_EXT_blend_subtract,GL_EXT_clip_volume_hint,GL_EXT_cmyka,GL_EXT_color_subtable,GL_EXT_compiled_vertex_array,GL_EXT_convolution,GL_EXT_coordinate_frame,GL_EXT_copy_texture,GL_EXT_cull_vertex,GL_EXT_debug_label,GL_EXT_debug_marker,GL_EXT_depth_bounds_test,GL_EXT_direct_state_access,GL_EXT_draw_buffers2,GL_EXT_draw_instanced,GL_EXT_draw_range_elements,GL_EXT_external_buffer,GL_EXT_fog_coord,GL_EXT_framebuffer_blit,GL_EXT_framebuffer_blit_layers,GL_EXT_framebuffer_multisample,GL_EXT_framebuffer_multisample_blit_scaled,GL_EXT_framebuffer_object,GL_EXT_framebuffer_sRGB,GL_EXT_geometry_shader4,GL_EXT_gpu_program_parameters,GL_EXT_gpu_shader4,GL_EXT_histogram,GL_EXT_index_array_formats,GL_EXT_index_func,GL_EXT_index_material,GL_EXT_index_texture,GL_EXT_light_texture,GL_EXT_memory_object,GL_EXT_memory_object_fd,GL_EXT_memory_object_win32,GL_EXT_misc_attribute,GL_EXT_multi_draw_arrays,GL_EXT_multisample,GL_EXT_multiview_tessellation_geometry_shader,GL_EXT_multiview_texture_multisample,GL_EXT_multiview_timer_query,GL_EXT_packed_depth_stencil,GL_EXT_packed_float,GL_EXT_packed_pixels,GL_EXT_paletted_texture,GL_EXT_pixel_buffer_object,GL_EXT_pixel_transform,GL_EXT_pixel_transform_color_table,GL_EXT_point_parameters,GL_EXT_polygon_offset,GL_EXT_polygon_offset_clamp,GL_EXT_post_depth_coverage,GL_EXT_provoking_vertex,GL_EXT_raster_multisample,GL_EXT_rescale_normal,GL_EXT_secondary_color,GL_EXT_semaphore,GL_EXT_semaphore_fd,GL_EXT_semaphore_win32,GL_EXT_separate_shader_objects,GL_EXT_separate_specular_color,GL_EXT_shader_framebuffer_fetch,GL_EXT_shader_framebuffer_fetch_non_coherent,GL_EXT_shader_image_load_formatted,GL_EXT_shader_image_load_store,GL_EXT_shader_integer_mix,GL_EXT_shader_samples_identical,GL_EXT_shadow_funcs,GL_EXT_shared_texture_palette,GL_EXT_sparse_texture2,GL_EXT_stencil_clear_tag,GL_EXT_stencil_two_side,GL_EXT_stencil_wrap,GL_EXT_subtexture,GL_EXT_texture,GL_EXT_texture3D,GL_EXT_texture_array,GL_EXT_texture_buffer_object,GL_EXT_texture_compression_latc,GL_EXT_texture_compression_rgtc,GL_EXT_texture_compression_s3tc,GL_EXT_texture_cube_map,GL_EXT_texture_env_add,GL_EXT_texture_env_combine,GL_EXT_texture_env_dot3,GL_EXT_texture_filter_anisotropic,GL_EXT_texture_filter_minmax,GL_EXT_texture_integer,GL_EXT_texture_lod_bias,GL_EXT_texture_mirror_clamp,GL_EXT_texture_object,GL_EXT_texture_perturb_normal,GL_EXT_texture_sRGB,GL_EXT_texture_sRGB_R8,GL_EXT_texture_sRGB_RG8,GL_EXT_texture_sRGB_decode,GL_EXT_texture_shadow_lod,GL_EXT_texture_shared_exponent,GL_EXT_texture_snorm,GL_EXT_texture_storage,GL_EXT_texture_swizzle,GL_EXT_timer_query,GL_EXT_transform_feedback,GL_EXT_vertex_array,GL_EXT_vertex_array_bgra,GL_EXT_vertex_attrib_64bit,GL_EXT_vertex_shader,GL_EXT_vertex_weighting,GL_EXT_win32_keyed_mutex,GL_EXT_window_rectangles,GL_EXT_x11_sync_object,GL_GREMEDY_frame_terminator,GL_GREMEDY_string_marker,GL_HP_convolution_border_modes,GL_HP_image_transform,GL_HP_occlusion_test,GL_HP_texture_lighting,GL_IBM_cull_vertex,GL_IBM_multimode_draw_arrays,GL_IBM_rasterpos_clip,GL_IBM_static_data,GL_IBM_texture_mirrored_repeat,GL_IBM_vertex_array_lists,GL_INGR_blend_func_separate,GL_INGR_color_clamp,GL_INGR_interlace_read,GL_INTEL_blackhole_render,GL_INTEL_conservative_rasterization,GL_INTEL_fragment_shader_ordering,GL_INTEL_framebuffer_CMAA,GL_INTEL_map_texture,GL_INTEL_parallel_arrays,GL_INTEL_performance_query,GL_KHR_blend_equation_advanced,GL_KHR_blend_equation_advanced_coherent,GL_KHR_context_flush_control,GL_KHR_debug,GL_KHR_no_error,GL_KHR_parallel_shader_compile,GL_KHR_robust_buffer_access_behavior,GL_KHR_robustness,GL_KHR_shader_subgroup,GL_KHR_texture_compression_astc_hdr,GL_KHR_texture_compression_astc_ldr,GL_KHR_texture_compression_astc_sliced_3d,GL_MESAX_texture_stack,GL_MESA_framebuffer_flip_x,GL_MESA_framebuffer_flip_y,GL_MESA_framebuffer_swap_xy,GL_MESA_pack_invert,GL_MESA_program_binary_formats,GL_MESA_resize_buffers,GL_MESA_shader_integer_functions,GL_MESA_tile_raster_order,GL_MESA_window_pos,GL_MESA_ycbcr_texture,GL_NVX_blend_equation_advanced_multi_draw_buffers,GL_NVX_conditional_render,GL_NVX_gpu_memory_info,GL_NVX_gpu_multicast2,GL_NVX_linked_gpu_multicast,GL_NVX_progress_fence,GL_NV_alpha_to_coverage_dither_control,GL_NV_bindless_multi_draw_indirect,GL_NV_bindless_multi_draw_indirect_count,GL_NV_bindless_texture,GL_NV_blend_equation_advanced,GL_NV_blend_equation_advanced_coherent,GL_NV_blend_minmax_factor,GL_NV_blend_square,GL_NV_clip_space_w_scaling,GL_NV_command_list,GL_NV_compute_program5,GL_NV_compute_shader_derivatives,GL_NV_conditional_render,GL_NV_conservative_raster,GL_NV_conservative_raster_dilate,GL_NV_conservative_raster_pre_snap,GL_NV_conservative_raster_pre_snap_triangles,GL_NV_conservative_raster_underestimation,GL_NV_copy_depth_to_color,GL_NV_copy_image,GL_NV_deep_texture3D,GL_NV_depth_buffer_float,GL_NV_depth_clamp,GL_NV_draw_texture,GL_NV_draw_vulkan_image,GL_NV_evaluators,GL_NV_explicit_multisample,GL_NV_fence,GL_NV_fill_rectangle,GL_NV_float_buffer,GL_NV_fog_distance,GL_NV_fragment_coverage_to_color,GL_NV_fragment_program,GL_NV_fragment_program2,GL_NV_fragment_program4,GL_NV_fragment_program_option,GL_NV_fragment_shader_barycentric,GL_NV_fragment_shader_interlock,GL_NV_framebuffer_mixed_samples,GL_NV_framebuffer_multisample_coverage,GL_NV_geometry_program4,GL_NV_geometry_shader4,GL_NV_geometry_shader_passthrough,GL_NV_gpu_multicast,GL_NV_gpu_program4,GL_NV_gpu_program5,GL_NV_gpu_program5_mem_extended,GL_NV_gpu_shader5,GL_NV_half_float,GL_NV_internalformat_sample_query,GL_NV_light_max_exponent,GL_NV_memory_attachment,GL_NV_memory_object_sparse,GL_NV_mesh_shader,GL_NV_multisample_coverage,GL_NV_multisample_filter_hint,GL_NV_occlusion_query,GL_NV_packed_depth_stencil,GL_NV_parameter_buffer_object,GL_NV_parameter_buffer_object2,GL_NV_path_rendering,GL_NV_path_rendering_shared_edge,GL_NV_pixel_data_range,GL_NV_point_sprite,GL_NV_present_video,GL_NV_primitive_restart,GL_NV_primitive_shading_rate,GL_NV_query_resource,GL_NV_query_resource_tag,GL_NV_register_combiners,GL_NV_register_combiners2,GL_NV_representative_fragment_test,GL_NV_robustness_video_memory_purge,GL_NV_sample_locations,GL_NV_sample_mask_override_coverage,GL_NV_scissor_exclusive,GL_NV_shader_atomic_counters,GL_NV_shader_atomic_float,GL_NV_shader_atomic_float64,GL_NV_shader_atomic_fp16_vector,GL_NV_shader_atomic_int64,GL_NV_shader_buffer_load,GL_NV_shader_buffer_store,GL_NV_shader_storage_buffer_object,GL_NV_shader_subgroup_partitioned,GL_NV_shader_texture_footprint,GL_NV_shader_thread_group,GL_NV_shader_thread_shuffle,GL_NV_shading_rate_image,GL_NV_stereo_view_rendering,GL_NV_tessellation_program5,GL_NV_texgen_emboss,GL_NV_texgen_reflection,GL_NV_texture_barrier,GL_NV_texture_compression_vtc,GL_NV_texture_env_combine4,GL_NV_texture_expand_normal,GL_NV_texture_multisample,GL_NV_texture_rectangle,GL_NV_texture_rectangle_compressed,GL_NV_texture_shader,GL_NV_texture_shader2,GL_NV_texture_shader3,GL_NV_timeline_semaphore,GL_NV_transform_feedback,GL_NV_transform_feedback2,GL_NV_uniform_buffer_std430_layout,GL_NV_uniform_buffer_unified_memory,GL_NV_vdpau_interop,GL_NV_vdpau_interop2,GL_NV_vertex_array_range,GL_NV_vertex_array_range2,GL_NV_vertex_attrib_integer_64bit,GL_NV_vertex_buffer_unified_memory,GL_NV_vertex_program,GL_NV_vertex_program1_1,GL_NV_vertex_program2,GL_NV_vertex_program2_option,GL_NV_vertex_program3,GL_NV_vertex_program4,GL_NV_video_capture,GL_NV_viewport_array2,GL_NV_viewport_swizzle,GL_OES_byte_coordinates,GL_OES_compressed_paletted_texture,GL_OES_fixed_point,GL_OES_query_matrix,GL_OES_read_format,GL_OES_single_precision,GL_OML_interlace,GL_OML_resample,GL_OML_subsample,GL_OVR_multiview,GL_OVR_multiview2,GL_PGI_misc_hints,GL_PGI_vertex_hints,GL_REND_screen_coordinates,GL_S3_s3tc,GL_SGIS_detail_texture,GL_SGIS_fog_function,GL_SGIS_generate_mipmap,GL_SGIS_multisample,GL_SGIS_pixel_texture,GL_SGIS_point_line_texgen,GL_SGIS_point_parameters,GL_SGIS_sharpen_texture,GL_SGIS_texture4D,GL_SGIS_texture_border_clamp,GL_SGIS_texture_color_mask,GL_SGIS_texture_edge_clamp,GL_SGIS_texture_filter4,GL_SGIS_texture_lod,GL_SGIS_texture_select,GL_SGIX_async,GL_SGIX_async_histogram,GL_SGIX_async_pixel,GL_SGIX_blend_alpha_minmax,GL_SGIX_calligraphic_fragment,GL_SGIX_clipmap,GL_SGIX_convolution_accuracy,GL_SGIX_depth_pass_instrument,GL_SGIX_depth_texture,GL_SGIX_flush_raster,GL_SGIX_fog_offset,GL_SGIX_fragment_lighting,GL_SGIX_framezoom,GL_SGIX_igloo_interface,GL_SGIX_instruments,GL_SGIX_interlace,GL_SGIX_ir_instrument1,GL_SGIX_list_priority,GL_SGIX_pixel_texture,GL_SGIX_pixel_tiles,GL_SGIX_polynomial_ffd,GL_SGIX_reference_plane,GL_SGIX_resample,GL_SGIX_scalebias_hint,GL_SGIX_shadow,GL_SGIX_shadow_ambient,GL_SGIX_sprite,GL_SGIX_subsample,GL_SGIX_tag_sample_buffer,GL_SGIX_texture_add_env,GL_SGIX_texture_coordinate_clamp,GL_SGIX_texture_lod_bias,GL_SGIX_texture_multi_buffer,GL_SGIX_texture_scale_bias,GL_SGIX_vertex_preclip,GL_SGIX_ycrcb,GL_SGIX_ycrcb_subsample,GL_SGIX_ycrcba,GL_SGI_color_matrix,GL_SGI_color_table,GL_SGI_texture_color_table,GL_SUNX_constant_data,GL_SUN_convolution_border_modes,GL_SUN_global_alpha,GL_SUN_mesh_array,GL_SUN_slice_accum,GL_SUN_triangle_list,GL_SUN_vertex,GL_WIN_phong_shading,GL_WIN_specular_fog"
    Online:
        Too many extensions
}
unit oglglad_glExt;

{$IF Defined(FPC)}{$MODE Delphi}{$ENDIF}{$H+}

interface

uses
  dynlibs,
  oglglad_gl;

//procedure Load_GLADEExt;

(* Extensions *)
var
  GLAD_GL_3DFX_multisample: boolean;
const
  GL_MULTISAMPLE_3DFX = $86B2;
  GL_SAMPLE_BUFFERS_3DFX = $86B3;
  GL_SAMPLES_3DFX = $86B4;
  GL_MULTISAMPLE_BIT_3DFX = $20000000;
var
  GLAD_GL_3DFX_tbuffer: boolean;
var
  GLAD_GL_3DFX_texture_compression_FXT1: boolean;
const
  GL_COMPRESSED_RGB_FXT1_3DFX = $86B0;
  GL_COMPRESSED_RGBA_FXT1_3DFX = $86B1;
var
  GLAD_GL_AMD_blend_minmax_factor: boolean;
const
  GL_FACTOR_MIN_AMD = $901C;
  GL_FACTOR_MAX_AMD = $901D;
var
  GLAD_GL_AMD_conservative_depth: boolean;
var
  GLAD_GL_AMD_debug_output: boolean;
const
  GL_MAX_DEBUG_MESSAGE_LENGTH_AMD = $9143;
  GL_MAX_DEBUG_LOGGED_MESSAGES_AMD = $9144;
  GL_DEBUG_LOGGED_MESSAGES_AMD = $9145;
  GL_DEBUG_SEVERITY_HIGH_AMD = $9146;
  GL_DEBUG_SEVERITY_MEDIUM_AMD = $9147;
  GL_DEBUG_SEVERITY_LOW_AMD = $9148;
  GL_DEBUG_CATEGORY_API_ERROR_AMD = $9149;
  GL_DEBUG_CATEGORY_WINDOW_SYSTEM_AMD = $914A;
  GL_DEBUG_CATEGORY_DEPRECATION_AMD = $914B;
  GL_DEBUG_CATEGORY_UNDEFINED_BEHAVIOR_AMD = $914C;
  GL_DEBUG_CATEGORY_PERFORMANCE_AMD = $914D;
  GL_DEBUG_CATEGORY_SHADER_COMPILER_AMD = $914E;
  GL_DEBUG_CATEGORY_APPLICATION_AMD = $914F;
  GL_DEBUG_CATEGORY_OTHER_AMD = $9150;
var
  GLAD_GL_AMD_depth_clamp_separate: boolean;
const
  GL_DEPTH_CLAMP_NEAR_AMD = $901E;
  GL_DEPTH_CLAMP_FAR_AMD = $901F;
var
  GLAD_GL_AMD_draw_buffers_blend: boolean;
var
  GLAD_GL_AMD_framebuffer_multisample_advanced: boolean;
const
  GL_RENDERBUFFER_STORAGE_SAMPLES_AMD = $91B2;
  GL_MAX_COLOR_FRAMEBUFFER_SAMPLES_AMD = $91B3;
  GL_MAX_COLOR_FRAMEBUFFER_STORAGE_SAMPLES_AMD = $91B4;
  GL_MAX_DEPTH_STENCIL_FRAMEBUFFER_SAMPLES_AMD = $91B5;
  GL_NUM_SUPPORTED_MULTISAMPLE_MODES_AMD = $91B6;
  GL_SUPPORTED_MULTISAMPLE_MODES_AMD = $91B7;
var
  GLAD_GL_AMD_framebuffer_sample_positions: boolean;
const
  GL_SUBSAMPLE_DISTANCE_AMD = $883F;
  GL_PIXELS_PER_SAMPLE_PATTERN_X_AMD = $91AE;
  GL_PIXELS_PER_SAMPLE_PATTERN_Y_AMD = $91AF;
var
  GLAD_GL_AMD_gcn_shader: boolean;
var
  GLAD_GL_AMD_gpu_shader_half_float: boolean;
const
  GL_FLOAT16_NV = $8FF8;
  GL_FLOAT16_VEC2_NV = $8FF9;
  GL_FLOAT16_VEC3_NV = $8FFA;
  GL_FLOAT16_VEC4_NV = $8FFB;
  GL_FLOAT16_MAT2_AMD = $91C5;
  GL_FLOAT16_MAT3_AMD = $91C6;
  GL_FLOAT16_MAT4_AMD = $91C7;
  GL_FLOAT16_MAT2x3_AMD = $91C8;
  GL_FLOAT16_MAT2x4_AMD = $91C9;
  GL_FLOAT16_MAT3x2_AMD = $91CA;
  GL_FLOAT16_MAT3x4_AMD = $91CB;
  GL_FLOAT16_MAT4x2_AMD = $91CC;
  GL_FLOAT16_MAT4x3_AMD = $91CD;
var
  GLAD_GL_AMD_gpu_shader_int16: boolean;
var
  GLAD_GL_AMD_gpu_shader_int64: boolean;
const
  GL_INT64_NV = $140E;
  GL_UNSIGNED_INT64_NV = $140F;
  GL_INT8_NV = $8FE0;
  GL_INT8_VEC2_NV = $8FE1;
  GL_INT8_VEC3_NV = $8FE2;
  GL_INT8_VEC4_NV = $8FE3;
  GL_INT16_NV = $8FE4;
  GL_INT16_VEC2_NV = $8FE5;
  GL_INT16_VEC3_NV = $8FE6;
  GL_INT16_VEC4_NV = $8FE7;
  GL_INT64_VEC2_NV = $8FE9;
  GL_INT64_VEC3_NV = $8FEA;
  GL_INT64_VEC4_NV = $8FEB;
  GL_UNSIGNED_INT8_NV = $8FEC;
  GL_UNSIGNED_INT8_VEC2_NV = $8FED;
  GL_UNSIGNED_INT8_VEC3_NV = $8FEE;
  GL_UNSIGNED_INT8_VEC4_NV = $8FEF;
  GL_UNSIGNED_INT16_NV = $8FF0;
  GL_UNSIGNED_INT16_VEC2_NV = $8FF1;
  GL_UNSIGNED_INT16_VEC3_NV = $8FF2;
  GL_UNSIGNED_INT16_VEC4_NV = $8FF3;
  GL_UNSIGNED_INT64_VEC2_NV = $8FF5;
  GL_UNSIGNED_INT64_VEC3_NV = $8FF6;
  GL_UNSIGNED_INT64_VEC4_NV = $8FF7;
var
  GLAD_GL_AMD_interleaved_elements: boolean;
const
  GL_VERTEX_ELEMENT_SWIZZLE_AMD = $91A4;
  GL_VERTEX_ID_SWIZZLE_AMD = $91A5;
  GL_RG8UI = $8238;
  GL_RG16UI = $823A;
  GL_RGBA8UI = $8D7C;
var
  GLAD_GL_AMD_multi_draw_indirect: boolean;
var
  GLAD_GL_AMD_name_gen_delete: boolean;
const
  GL_DATA_BUFFER_AMD = $9151;
  GL_PERFORMANCE_MONITOR_AMD = $9152;
  GL_QUERY_OBJECT_AMD = $9153;
  GL_VERTEX_ARRAY_OBJECT_AMD = $9154;
  GL_SAMPLER_OBJECT_AMD = $9155;
var
  GLAD_GL_AMD_occlusion_query_event: boolean;
const
  GL_OCCLUSION_QUERY_EVENT_MASK_AMD = $874F;
  GL_QUERY_DEPTH_PASS_EVENT_BIT_AMD = $00000001;
  GL_QUERY_DEPTH_FAIL_EVENT_BIT_AMD = $00000002;
  GL_QUERY_STENCIL_FAIL_EVENT_BIT_AMD = $00000004;
  GL_QUERY_DEPTH_BOUNDS_FAIL_EVENT_BIT_AMD = $00000008;
  GL_QUERY_ALL_EVENT_BITS_AMD = $FFFFFFFF;
var
  GLAD_GL_AMD_performance_monitor: boolean;
const
  GL_COUNTER_TYPE_AMD = $8BC0;
  GL_COUNTER_RANGE_AMD = $8BC1;
  GL_UNSIGNED_INT64_AMD = $8BC2;
  GL_PERCENTAGE_AMD = $8BC3;
  GL_PERFMON_RESULT_AVAILABLE_AMD = $8BC4;
  GL_PERFMON_RESULT_SIZE_AMD = $8BC5;
  GL_PERFMON_RESULT_AMD = $8BC6;
var
  GLAD_GL_AMD_pinned_memory: boolean;
const
  GL_EXTERNAL_VIRTUAL_MEMORY_BUFFER_AMD = $9160;
var
  GLAD_GL_AMD_query_buffer_object: boolean;
const
  GL_QUERY_BUFFER_AMD = $9192;
  GL_QUERY_BUFFER_BINDING_AMD = $9193;
  GL_QUERY_RESULT_NO_WAIT_AMD = $9194;
var
  GLAD_GL_AMD_sample_positions: boolean;
var
  GLAD_GL_AMD_seamless_cubemap_per_texture: boolean;
const
  GL_TEXTURE_CUBE_MAP_SEAMLESS = $884F;
var
  GLAD_GL_AMD_shader_atomic_counter_ops: boolean;
var
  GLAD_GL_AMD_shader_ballot: boolean;
var
  GLAD_GL_AMD_shader_explicit_vertex_parameter: boolean;
var
  GLAD_GL_AMD_shader_gpu_shader_half_float_fetch: boolean;
var
  GLAD_GL_AMD_shader_image_load_store_lod: boolean;
var
  GLAD_GL_AMD_shader_stencil_export: boolean;
var
  GLAD_GL_AMD_shader_trinary_minmax: boolean;
var
  GLAD_GL_AMD_sparse_texture: boolean;
const
  GL_VIRTUAL_PAGE_SIZE_X_AMD = $9195;
  GL_VIRTUAL_PAGE_SIZE_Y_AMD = $9196;
  GL_VIRTUAL_PAGE_SIZE_Z_AMD = $9197;
  GL_MAX_SPARSE_TEXTURE_SIZE_AMD = $9198;
  GL_MAX_SPARSE_3D_TEXTURE_SIZE_AMD = $9199;
  GL_MAX_SPARSE_ARRAY_TEXTURE_LAYERS = $919A;
  GL_MIN_SPARSE_LEVEL_AMD = $919B;
  GL_MIN_LOD_WARNING_AMD = $919C;
  GL_TEXTURE_STORAGE_SPARSE_BIT_AMD = $00000001;
var
  GLAD_GL_AMD_stencil_operation_extended: boolean;
const
  GL_SET_AMD = $874A;
  GL_REPLACE_VALUE_AMD = $874B;
  GL_STENCIL_OP_VALUE_AMD = $874C;
  GL_STENCIL_BACK_OP_VALUE_AMD = $874D;
var
  GLAD_GL_AMD_texture_gather_bias_lod: boolean;
var
  GLAD_GL_AMD_texture_texture4: boolean;
var
  GLAD_GL_AMD_transform_feedback3_lines_triangles: boolean;
var
  GLAD_GL_AMD_transform_feedback4: boolean;
const
  GL_STREAM_RASTERIZATION_AMD = $91A0;
var
  GLAD_GL_AMD_vertex_shader_layer: boolean;
var
  GLAD_GL_AMD_vertex_shader_tessellator: boolean;
const
  GL_SAMPLER_BUFFER_AMD = $9001;
  GL_INT_SAMPLER_BUFFER_AMD = $9002;
  GL_UNSIGNED_INT_SAMPLER_BUFFER_AMD = $9003;
  GL_TESSELLATION_MODE_AMD = $9004;
  GL_TESSELLATION_FACTOR_AMD = $9005;
  GL_DISCRETE_AMD = $9006;
  GL_CONTINUOUS_AMD = $9007;
var
  GLAD_GL_AMD_vertex_shader_viewport_index: boolean;
var
  GLAD_GL_APPLE_aux_depth_stencil: boolean;
const
  GL_AUX_DEPTH_STENCIL_APPLE = $8A14;
var
  GLAD_GL_APPLE_client_storage: boolean;
const
  GL_UNPACK_CLIENT_STORAGE_APPLE = $85B2;
var
  GLAD_GL_APPLE_element_array: boolean;
const
  GL_ELEMENT_ARRAY_APPLE = $8A0C;
  GL_ELEMENT_ARRAY_TYPE_APPLE = $8A0D;
  GL_ELEMENT_ARRAY_POINTER_APPLE = $8A0E;
var
  GLAD_GL_APPLE_fence: boolean;
const
  GL_DRAW_PIXELS_APPLE = $8A0A;
  GL_FENCE_APPLE = $8A0B;
var
  GLAD_GL_APPLE_float_pixels: boolean;
const
  GL_HALF_APPLE = $140B;
  GL_RGBA_FLOAT32_APPLE = $8814;
  GL_RGB_FLOAT32_APPLE = $8815;
  GL_ALPHA_FLOAT32_APPLE = $8816;
  GL_INTENSITY_FLOAT32_APPLE = $8817;
  GL_LUMINANCE_FLOAT32_APPLE = $8818;
  GL_LUMINANCE_ALPHA_FLOAT32_APPLE = $8819;
  GL_RGBA_FLOAT16_APPLE = $881A;
  GL_RGB_FLOAT16_APPLE = $881B;
  GL_ALPHA_FLOAT16_APPLE = $881C;
  GL_INTENSITY_FLOAT16_APPLE = $881D;
  GL_LUMINANCE_FLOAT16_APPLE = $881E;
  GL_LUMINANCE_ALPHA_FLOAT16_APPLE = $881F;
  GL_COLOR_FLOAT_APPLE = $8A0F;
var
  GLAD_GL_APPLE_flush_buffer_range: boolean;
const
  GL_BUFFER_SERIALIZED_MODIFY_APPLE = $8A12;
  GL_BUFFER_FLUSHING_UNMAP_APPLE = $8A13;
var
  GLAD_GL_APPLE_object_purgeable: boolean;
const
  GL_BUFFER_OBJECT_APPLE = $85B3;
  GL_RELEASED_APPLE = $8A19;
  GL_VOLATILE_APPLE = $8A1A;
  GL_RETAINED_APPLE = $8A1B;
  GL_UNDEFINED_APPLE = $8A1C;
  GL_PURGEABLE_APPLE = $8A1D;
var
  GLAD_GL_APPLE_rgb_422: boolean;
const
  GL_RGB_422_APPLE = $8A1F;
  GL_UNSIGNED_SHORT_8_8_APPLE = $85BA;
  GL_UNSIGNED_SHORT_8_8_REV_APPLE = $85BB;
  GL_RGB_RAW_422_APPLE = $8A51;
var
  GLAD_GL_APPLE_row_bytes: boolean;
const
  GL_PACK_ROW_BYTES_APPLE = $8A15;
  GL_UNPACK_ROW_BYTES_APPLE = $8A16;
var
  GLAD_GL_APPLE_specular_vector: boolean;
const
  GL_LIGHT_MODEL_SPECULAR_VECTOR_APPLE = $85B0;
var
  GLAD_GL_APPLE_texture_range: boolean;
const
  GL_TEXTURE_RANGE_LENGTH_APPLE = $85B7;
  GL_TEXTURE_RANGE_POINTER_APPLE = $85B8;
  GL_TEXTURE_STORAGE_HINT_APPLE = $85BC;
  GL_STORAGE_PRIVATE_APPLE = $85BD;
  GL_STORAGE_CACHED_APPLE = $85BE;
  GL_STORAGE_SHARED_APPLE = $85BF;
var
  GLAD_GL_APPLE_transform_hint: boolean;
const
  GL_TRANSFORM_HINT_APPLE = $85B1;
var
  GLAD_GL_APPLE_vertex_array_object: boolean;
const
  GL_VERTEX_ARRAY_BINDING_APPLE = $85B5;
var
  GLAD_GL_APPLE_vertex_array_range: boolean;
const
  GL_VERTEX_ARRAY_RANGE_APPLE = $851D;
  GL_VERTEX_ARRAY_RANGE_LENGTH_APPLE = $851E;
  GL_VERTEX_ARRAY_STORAGE_HINT_APPLE = $851F;
  GL_VERTEX_ARRAY_RANGE_POINTER_APPLE = $8521;
  GL_STORAGE_CLIENT_APPLE = $85B4;
var
  GLAD_GL_APPLE_vertex_program_evaluators: boolean;
const
  GL_VERTEX_ATTRIB_MAP1_APPLE = $8A00;
  GL_VERTEX_ATTRIB_MAP2_APPLE = $8A01;
  GL_VERTEX_ATTRIB_MAP1_SIZE_APPLE = $8A02;
  GL_VERTEX_ATTRIB_MAP1_COEFF_APPLE = $8A03;
  GL_VERTEX_ATTRIB_MAP1_ORDER_APPLE = $8A04;
  GL_VERTEX_ATTRIB_MAP1_DOMAIN_APPLE = $8A05;
  GL_VERTEX_ATTRIB_MAP2_SIZE_APPLE = $8A06;
  GL_VERTEX_ATTRIB_MAP2_COEFF_APPLE = $8A07;
  GL_VERTEX_ATTRIB_MAP2_ORDER_APPLE = $8A08;
  GL_VERTEX_ATTRIB_MAP2_DOMAIN_APPLE = $8A09;
var
  GLAD_GL_APPLE_ycbcr_422: boolean;
const
  GL_YCBCR_422_APPLE = $85B9;
var
  GLAD_GL_ARB_ES2_compatibility: boolean;
const
  GL_FIXED = $140C;
  GL_IMPLEMENTATION_COLOR_READ_TYPE = $8B9A;
  GL_IMPLEMENTATION_COLOR_READ_FORMAT = $8B9B;
  GL_LOW_FLOAT = $8DF0;
  GL_MEDIUM_FLOAT = $8DF1;
  GL_HIGH_FLOAT = $8DF2;
  GL_LOW_INT = $8DF3;
  GL_MEDIUM_INT = $8DF4;
  GL_HIGH_INT = $8DF5;
  GL_SHADER_COMPILER = $8DFA;
  GL_SHADER_BINARY_FORMATS = $8DF8;
  GL_NUM_SHADER_BINARY_FORMATS = $8DF9;
  GL_MAX_VERTEX_UNIFORM_VECTORS = $8DFB;
  GL_MAX_VARYING_VECTORS = $8DFC;
  GL_MAX_FRAGMENT_UNIFORM_VECTORS = $8DFD;
  GL_RGB565 = $8D62;
var
  GLAD_GL_ARB_ES3_1_compatibility: boolean;
var
  GLAD_GL_ARB_ES3_2_compatibility: boolean;
const
  GL_PRIMITIVE_BOUNDING_BOX_ARB = $92BE;
  GL_MULTISAMPLE_LINE_WIDTH_RANGE_ARB = $9381;
  GL_MULTISAMPLE_LINE_WIDTH_GRANULARITY_ARB = $9382;
var
  GLAD_GL_ARB_ES3_compatibility: boolean;
const
  GL_COMPRESSED_RGB8_ETC2 = $9274;
  GL_COMPRESSED_SRGB8_ETC2 = $9275;
  GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = $9276;
  GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = $9277;
  GL_COMPRESSED_RGBA8_ETC2_EAC = $9278;
  GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = $9279;
  GL_COMPRESSED_R11_EAC = $9270;
  GL_COMPRESSED_SIGNED_R11_EAC = $9271;
  GL_COMPRESSED_RG11_EAC = $9272;
  GL_COMPRESSED_SIGNED_RG11_EAC = $9273;
  GL_PRIMITIVE_RESTART_FIXED_INDEX = $8D69;
  GL_ANY_SAMPLES_PASSED_CONSERVATIVE = $8D6A;
  GL_MAX_ELEMENT_INDEX = $8D6B;
var
  GLAD_GL_ARB_arrays_of_arrays: boolean;
var
  GLAD_GL_ARB_base_instance: boolean;
var
  GLAD_GL_ARB_bindless_texture: boolean;
const
  GL_UNSIGNED_INT64_ARB = $140F;
var
  GLAD_GL_ARB_blend_func_extended: boolean;
const
  GL_SRC1_COLOR = $88F9;
  GL_SRC1_ALPHA = $8589;
  GL_ONE_MINUS_SRC1_COLOR = $88FA;
  GL_ONE_MINUS_SRC1_ALPHA = $88FB;
  GL_MAX_DUAL_SOURCE_DRAW_BUFFERS = $88FC;
var
  GLAD_GL_ARB_buffer_storage: boolean;
const
  GL_MAP_READ_BIT = $0001;
  GL_MAP_WRITE_BIT = $0002;
  GL_MAP_PERSISTENT_BIT = $0040;
  GL_MAP_COHERENT_BIT = $0080;
  GL_DYNAMIC_STORAGE_BIT = $0100;
  GL_CLIENT_STORAGE_BIT = $0200;
  GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT = $00004000;
  GL_BUFFER_IMMUTABLE_STORAGE = $821F;
  GL_BUFFER_STORAGE_FLAGS = $8220;
var
  GLAD_GL_ARB_cl_event: boolean;
const
  GL_SYNC_CL_EVENT_ARB = $8240;
  GL_SYNC_CL_EVENT_COMPLETE_ARB = $8241;
var
  GLAD_GL_ARB_clear_buffer_object: boolean;
var
  GLAD_GL_ARB_clear_texture: boolean;
const
  GL_CLEAR_TEXTURE = $9365;
var
  GLAD_GL_ARB_clip_control: boolean;
const
  GL_LOWER_LEFT = $8CA1;
  GL_UPPER_LEFT = $8CA2;
  GL_NEGATIVE_ONE_TO_ONE = $935E;
  GL_ZERO_TO_ONE = $935F;
  GL_CLIP_ORIGIN = $935C;
  GL_CLIP_DEPTH_MODE = $935D;
var
  GLAD_GL_ARB_color_buffer_float: boolean;
const
  GL_RGBA_FLOAT_MODE_ARB = $8820;
  GL_CLAMP_VERTEX_COLOR_ARB = $891A;
  GL_CLAMP_FRAGMENT_COLOR_ARB = $891B;
  GL_CLAMP_READ_COLOR_ARB = $891C;
  GL_FIXED_ONLY_ARB = $891D;
var
  GLAD_GL_ARB_compatibility: boolean;
var
  GLAD_GL_ARB_compressed_texture_pixel_storage: boolean;
const
  GL_UNPACK_COMPRESSED_BLOCK_WIDTH = $9127;
  GL_UNPACK_COMPRESSED_BLOCK_HEIGHT = $9128;
  GL_UNPACK_COMPRESSED_BLOCK_DEPTH = $9129;
  GL_UNPACK_COMPRESSED_BLOCK_SIZE = $912A;
  GL_PACK_COMPRESSED_BLOCK_WIDTH = $912B;
  GL_PACK_COMPRESSED_BLOCK_HEIGHT = $912C;
  GL_PACK_COMPRESSED_BLOCK_DEPTH = $912D;
  GL_PACK_COMPRESSED_BLOCK_SIZE = $912E;
var
  GLAD_GL_ARB_compute_shader: boolean;
const
  GL_COMPUTE_SHADER = $91B9;
  GL_MAX_COMPUTE_UNIFORM_BLOCKS = $91BB;
  GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS = $91BC;
  GL_MAX_COMPUTE_IMAGE_UNIFORMS = $91BD;
  GL_MAX_COMPUTE_SHARED_MEMORY_SIZE = $8262;
  GL_MAX_COMPUTE_UNIFORM_COMPONENTS = $8263;
  GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS = $8264;
  GL_MAX_COMPUTE_ATOMIC_COUNTERS = $8265;
  GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS = $8266;
  GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS = $90EB;
  GL_MAX_COMPUTE_WORK_GROUP_COUNT = $91BE;
  GL_MAX_COMPUTE_WORK_GROUP_SIZE = $91BF;
  GL_COMPUTE_WORK_GROUP_SIZE = $8267;
  GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER = $90EC;
  GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER = $90ED;
  GL_DISPATCH_INDIRECT_BUFFER = $90EE;
  GL_DISPATCH_INDIRECT_BUFFER_BINDING = $90EF;
  GL_COMPUTE_SHADER_BIT = $00000020;
var
  GLAD_GL_ARB_compute_variable_group_size: boolean;
const
  GL_MAX_COMPUTE_VARIABLE_GROUP_INVOCATIONS_ARB = $9344;
  GL_MAX_COMPUTE_FIXED_GROUP_INVOCATIONS_ARB = $90EB;
  GL_MAX_COMPUTE_VARIABLE_GROUP_SIZE_ARB = $9345;
  GL_MAX_COMPUTE_FIXED_GROUP_SIZE_ARB = $91BF;
var
  GLAD_GL_ARB_conditional_render_inverted: boolean;
const
  GL_QUERY_WAIT_INVERTED = $8E17;
  GL_QUERY_NO_WAIT_INVERTED = $8E18;
  GL_QUERY_BY_REGION_WAIT_INVERTED = $8E19;
  GL_QUERY_BY_REGION_NO_WAIT_INVERTED = $8E1A;
var
  GLAD_GL_ARB_conservative_depth: boolean;
var
  GLAD_GL_ARB_copy_buffer: boolean;
const
  GL_COPY_READ_BUFFER = $8F36;
  GL_COPY_WRITE_BUFFER = $8F37;
var
  GLAD_GL_ARB_copy_image: boolean;
var
  GLAD_GL_ARB_cull_distance: boolean;
const
  GL_MAX_CULL_DISTANCES = $82F9;
  GL_MAX_COMBINED_CLIP_AND_CULL_DISTANCES = $82FA;
var
  GLAD_GL_ARB_debug_output: boolean;
const
  GL_DEBUG_OUTPUT_SYNCHRONOUS_ARB = $8242;
  GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH_ARB = $8243;
  GL_DEBUG_CALLBACK_FUNCTION_ARB = $8244;
  GL_DEBUG_CALLBACK_USER_PARAM_ARB = $8245;
  GL_DEBUG_SOURCE_API_ARB = $8246;
  GL_DEBUG_SOURCE_WINDOW_SYSTEM_ARB = $8247;
  GL_DEBUG_SOURCE_SHADER_COMPILER_ARB = $8248;
  GL_DEBUG_SOURCE_THIRD_PARTY_ARB = $8249;
  GL_DEBUG_SOURCE_APPLICATION_ARB = $824A;
  GL_DEBUG_SOURCE_OTHER_ARB = $824B;
  GL_DEBUG_TYPE_ERROR_ARB = $824C;
  GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR_ARB = $824D;
  GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR_ARB = $824E;
  GL_DEBUG_TYPE_PORTABILITY_ARB = $824F;
  GL_DEBUG_TYPE_PERFORMANCE_ARB = $8250;
  GL_DEBUG_TYPE_OTHER_ARB = $8251;
  GL_MAX_DEBUG_MESSAGE_LENGTH_ARB = $9143;
  GL_MAX_DEBUG_LOGGED_MESSAGES_ARB = $9144;
  GL_DEBUG_LOGGED_MESSAGES_ARB = $9145;
  GL_DEBUG_SEVERITY_HIGH_ARB = $9146;
  GL_DEBUG_SEVERITY_MEDIUM_ARB = $9147;
  GL_DEBUG_SEVERITY_LOW_ARB = $9148;
var
  GLAD_GL_ARB_depth_buffer_float: boolean;
const
  GL_DEPTH_COMPONENT32F = $8CAC;
  GL_DEPTH32F_STENCIL8 = $8CAD;
  GL_FLOAT_32_UNSIGNED_INT_24_8_REV = $8DAD;
var
  GLAD_GL_ARB_depth_clamp: boolean;
const
  GL_DEPTH_CLAMP = $864F;
var
  GLAD_GL_ARB_depth_texture: boolean;
const
  GL_DEPTH_COMPONENT16_ARB = $81A5;
  GL_DEPTH_COMPONENT24_ARB = $81A6;
  GL_DEPTH_COMPONENT32_ARB = $81A7;
  GL_TEXTURE_DEPTH_SIZE_ARB = $884A;
  GL_DEPTH_TEXTURE_MODE_ARB = $884B;
var
  GLAD_GL_ARB_derivative_control: boolean;
var
  GLAD_GL_ARB_direct_state_access: boolean;
const
  GL_TEXTURE_TARGET = $1006;
  GL_QUERY_TARGET = $82EA;
  GL_TEXTURE_BINDING_1D = $8068;
  GL_TEXTURE_BINDING_1D_ARRAY = $8C1C;
  GL_TEXTURE_BINDING_2D = $8069;
  GL_TEXTURE_BINDING_2D_ARRAY = $8C1D;
  GL_TEXTURE_BINDING_2D_MULTISAMPLE = $9104;
  GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY = $9105;
  GL_TEXTURE_BINDING_3D = $806A;
  GL_TEXTURE_BINDING_BUFFER = $8C2C;
  GL_TEXTURE_BINDING_CUBE_MAP = $8514;
  GL_TEXTURE_BINDING_CUBE_MAP_ARRAY = $900A;
  GL_TEXTURE_BINDING_RECTANGLE = $84F6;
var
  GLAD_GL_ARB_draw_buffers: boolean;
const
  GL_MAX_DRAW_BUFFERS_ARB = $8824;
  GL_DRAW_BUFFER0_ARB = $8825;
  GL_DRAW_BUFFER1_ARB = $8826;
  GL_DRAW_BUFFER2_ARB = $8827;
  GL_DRAW_BUFFER3_ARB = $8828;
  GL_DRAW_BUFFER4_ARB = $8829;
  GL_DRAW_BUFFER5_ARB = $882A;
  GL_DRAW_BUFFER6_ARB = $882B;
  GL_DRAW_BUFFER7_ARB = $882C;
  GL_DRAW_BUFFER8_ARB = $882D;
  GL_DRAW_BUFFER9_ARB = $882E;
  GL_DRAW_BUFFER10_ARB = $882F;
  GL_DRAW_BUFFER11_ARB = $8830;
  GL_DRAW_BUFFER12_ARB = $8831;
  GL_DRAW_BUFFER13_ARB = $8832;
  GL_DRAW_BUFFER14_ARB = $8833;
  GL_DRAW_BUFFER15_ARB = $8834;
var
  GLAD_GL_ARB_draw_buffers_blend: boolean;
var
  GLAD_GL_ARB_draw_elements_base_vertex: boolean;
var
  GLAD_GL_ARB_draw_indirect: boolean;
const
  GL_DRAW_INDIRECT_BUFFER = $8F3F;
  GL_DRAW_INDIRECT_BUFFER_BINDING = $8F43;
var
  GLAD_GL_ARB_draw_instanced: boolean;
var
  GLAD_GL_ARB_enhanced_layouts: boolean;
const
  GL_LOCATION_COMPONENT = $934A;
  GL_TRANSFORM_FEEDBACK_BUFFER = $8C8E;
  GL_TRANSFORM_FEEDBACK_BUFFER_INDEX = $934B;
  GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE = $934C;
var
  GLAD_GL_ARB_explicit_attrib_location: boolean;
var
  GLAD_GL_ARB_explicit_uniform_location: boolean;
const
  GL_MAX_UNIFORM_LOCATIONS = $826E;
var
  GLAD_GL_ARB_fragment_coord_conventions: boolean;
var
  GLAD_GL_ARB_fragment_layer_viewport: boolean;
var
  GLAD_GL_ARB_fragment_program: boolean;
const
  GL_FRAGMENT_PROGRAM_ARB = $8804;
  GL_PROGRAM_FORMAT_ASCII_ARB = $8875;
  GL_PROGRAM_LENGTH_ARB = $8627;
  GL_PROGRAM_FORMAT_ARB = $8876;
  GL_PROGRAM_BINDING_ARB = $8677;
  GL_PROGRAM_INSTRUCTIONS_ARB = $88A0;
  GL_MAX_PROGRAM_INSTRUCTIONS_ARB = $88A1;
  GL_PROGRAM_NATIVE_INSTRUCTIONS_ARB = $88A2;
  GL_MAX_PROGRAM_NATIVE_INSTRUCTIONS_ARB = $88A3;
  GL_PROGRAM_TEMPORARIES_ARB = $88A4;
  GL_MAX_PROGRAM_TEMPORARIES_ARB = $88A5;
  GL_PROGRAM_NATIVE_TEMPORARIES_ARB = $88A6;
  GL_MAX_PROGRAM_NATIVE_TEMPORARIES_ARB = $88A7;
  GL_PROGRAM_PARAMETERS_ARB = $88A8;
  GL_MAX_PROGRAM_PARAMETERS_ARB = $88A9;
  GL_PROGRAM_NATIVE_PARAMETERS_ARB = $88AA;
  GL_MAX_PROGRAM_NATIVE_PARAMETERS_ARB = $88AB;
  GL_PROGRAM_ATTRIBS_ARB = $88AC;
  GL_MAX_PROGRAM_ATTRIBS_ARB = $88AD;
  GL_PROGRAM_NATIVE_ATTRIBS_ARB = $88AE;
  GL_MAX_PROGRAM_NATIVE_ATTRIBS_ARB = $88AF;
  GL_MAX_PROGRAM_LOCAL_PARAMETERS_ARB = $88B4;
  GL_MAX_PROGRAM_ENV_PARAMETERS_ARB = $88B5;
  GL_PROGRAM_UNDER_NATIVE_LIMITS_ARB = $88B6;
  GL_PROGRAM_ALU_INSTRUCTIONS_ARB = $8805;
  GL_PROGRAM_TEX_INSTRUCTIONS_ARB = $8806;
  GL_PROGRAM_TEX_INDIRECTIONS_ARB = $8807;
  GL_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB = $8808;
  GL_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB = $8809;
  GL_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB = $880A;
  GL_MAX_PROGRAM_ALU_INSTRUCTIONS_ARB = $880B;
  GL_MAX_PROGRAM_TEX_INSTRUCTIONS_ARB = $880C;
  GL_MAX_PROGRAM_TEX_INDIRECTIONS_ARB = $880D;
  GL_MAX_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB = $880E;
  GL_MAX_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB = $880F;
  GL_MAX_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB = $8810;
  GL_PROGRAM_STRING_ARB = $8628;
  GL_PROGRAM_ERROR_POSITION_ARB = $864B;
  GL_CURRENT_MATRIX_ARB = $8641;
  GL_TRANSPOSE_CURRENT_MATRIX_ARB = $88B7;
  GL_CURRENT_MATRIX_STACK_DEPTH_ARB = $8640;
  GL_MAX_PROGRAM_MATRICES_ARB = $862F;
  GL_MAX_PROGRAM_MATRIX_STACK_DEPTH_ARB = $862E;
  GL_MAX_TEXTURE_COORDS_ARB = $8871;
  GL_MAX_TEXTURE_IMAGE_UNITS_ARB = $8872;
  GL_PROGRAM_ERROR_STRING_ARB = $8874;
  GL_MATRIX0_ARB = $88C0;
  GL_MATRIX1_ARB = $88C1;
  GL_MATRIX2_ARB = $88C2;
  GL_MATRIX3_ARB = $88C3;
  GL_MATRIX4_ARB = $88C4;
  GL_MATRIX5_ARB = $88C5;
  GL_MATRIX6_ARB = $88C6;
  GL_MATRIX7_ARB = $88C7;
  GL_MATRIX8_ARB = $88C8;
  GL_MATRIX9_ARB = $88C9;
  GL_MATRIX10_ARB = $88CA;
  GL_MATRIX11_ARB = $88CB;
  GL_MATRIX12_ARB = $88CC;
  GL_MATRIX13_ARB = $88CD;
  GL_MATRIX14_ARB = $88CE;
  GL_MATRIX15_ARB = $88CF;
  GL_MATRIX16_ARB = $88D0;
  GL_MATRIX17_ARB = $88D1;
  GL_MATRIX18_ARB = $88D2;
  GL_MATRIX19_ARB = $88D3;
  GL_MATRIX20_ARB = $88D4;
  GL_MATRIX21_ARB = $88D5;
  GL_MATRIX22_ARB = $88D6;
  GL_MATRIX23_ARB = $88D7;
  GL_MATRIX24_ARB = $88D8;
  GL_MATRIX25_ARB = $88D9;
  GL_MATRIX26_ARB = $88DA;
  GL_MATRIX27_ARB = $88DB;
  GL_MATRIX28_ARB = $88DC;
  GL_MATRIX29_ARB = $88DD;
  GL_MATRIX30_ARB = $88DE;
  GL_MATRIX31_ARB = $88DF;
var
  GLAD_GL_ARB_fragment_program_shadow: boolean;
var
  GLAD_GL_ARB_fragment_shader: boolean;
const
  GL_FRAGMENT_SHADER_ARB = $8B30;
  GL_MAX_FRAGMENT_UNIFORM_COMPONENTS_ARB = $8B49;
  GL_FRAGMENT_SHADER_DERIVATIVE_HINT_ARB = $8B8B;
var
  GLAD_GL_ARB_fragment_shader_interlock: boolean;
var
  GLAD_GL_ARB_framebuffer_no_attachments: boolean;
const
  GL_FRAMEBUFFER_DEFAULT_WIDTH = $9310;
  GL_FRAMEBUFFER_DEFAULT_HEIGHT = $9311;
  GL_FRAMEBUFFER_DEFAULT_LAYERS = $9312;
  GL_FRAMEBUFFER_DEFAULT_SAMPLES = $9313;
  GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS = $9314;
  GL_MAX_FRAMEBUFFER_WIDTH = $9315;
  GL_MAX_FRAMEBUFFER_HEIGHT = $9316;
  GL_MAX_FRAMEBUFFER_LAYERS = $9317;
  GL_MAX_FRAMEBUFFER_SAMPLES = $9318;
var
  GLAD_GL_ARB_framebuffer_object: boolean;
const
  GL_INVALID_FRAMEBUFFER_OPERATION = $0506;
  GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING = $8210;
  GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE = $8211;
  GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE = $8212;
  GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE = $8213;
  GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE = $8214;
  GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE = $8215;
  GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE = $8216;
  GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE = $8217;
  GL_FRAMEBUFFER_DEFAULT = $8218;
  GL_FRAMEBUFFER_UNDEFINED = $8219;
  GL_DEPTH_STENCIL_ATTACHMENT = $821A;
  GL_MAX_RENDERBUFFER_SIZE = $84E8;
  GL_DEPTH_STENCIL = $84F9;
  GL_UNSIGNED_INT_24_8 = $84FA;
  GL_DEPTH24_STENCIL8 = $88F0;
  GL_TEXTURE_STENCIL_SIZE = $88F1;
  GL_UNSIGNED_NORMALIZED = $8C17;
  GL_FRAMEBUFFER_BINDING = $8CA6;
  GL_DRAW_FRAMEBUFFER_BINDING = $8CA6;
  GL_RENDERBUFFER_BINDING = $8CA7;
  GL_READ_FRAMEBUFFER = $8CA8;
  GL_DRAW_FRAMEBUFFER = $8CA9;
  GL_READ_FRAMEBUFFER_BINDING = $8CAA;
  GL_RENDERBUFFER_SAMPLES = $8CAB;
  GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = $8CD0;
  GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = $8CD1;
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = $8CD2;
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = $8CD3;
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER = $8CD4;
  GL_FRAMEBUFFER_COMPLETE = $8CD5;
  GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT = $8CD6;
  GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = $8CD7;
  GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER = $8CDB;
  GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER = $8CDC;
  GL_FRAMEBUFFER_UNSUPPORTED = $8CDD;
  GL_MAX_COLOR_ATTACHMENTS = $8CDF;
  GL_COLOR_ATTACHMENT0 = $8CE0;
  GL_COLOR_ATTACHMENT1 = $8CE1;
  GL_COLOR_ATTACHMENT2 = $8CE2;
  GL_COLOR_ATTACHMENT3 = $8CE3;
  GL_COLOR_ATTACHMENT4 = $8CE4;
  GL_COLOR_ATTACHMENT5 = $8CE5;
  GL_COLOR_ATTACHMENT6 = $8CE6;
  GL_COLOR_ATTACHMENT7 = $8CE7;
  GL_COLOR_ATTACHMENT8 = $8CE8;
  GL_COLOR_ATTACHMENT9 = $8CE9;
  GL_COLOR_ATTACHMENT10 = $8CEA;
  GL_COLOR_ATTACHMENT11 = $8CEB;
  GL_COLOR_ATTACHMENT12 = $8CEC;
  GL_COLOR_ATTACHMENT13 = $8CED;
  GL_COLOR_ATTACHMENT14 = $8CEE;
  GL_COLOR_ATTACHMENT15 = $8CEF;
  GL_DEPTH_ATTACHMENT = $8D00;
  GL_STENCIL_ATTACHMENT = $8D20;
  GL_FRAMEBUFFER = $8D40;
  GL_RENDERBUFFER = $8D41;
  GL_RENDERBUFFER_WIDTH = $8D42;
  GL_RENDERBUFFER_HEIGHT = $8D43;
  GL_RENDERBUFFER_INTERNAL_FORMAT = $8D44;
  GL_STENCIL_INDEX1 = $8D46;
  GL_STENCIL_INDEX4 = $8D47;
  GL_STENCIL_INDEX8 = $8D48;
  GL_STENCIL_INDEX16 = $8D49;
  GL_RENDERBUFFER_RED_SIZE = $8D50;
  GL_RENDERBUFFER_GREEN_SIZE = $8D51;
  GL_RENDERBUFFER_BLUE_SIZE = $8D52;
  GL_RENDERBUFFER_ALPHA_SIZE = $8D53;
  GL_RENDERBUFFER_DEPTH_SIZE = $8D54;
  GL_RENDERBUFFER_STENCIL_SIZE = $8D55;
  GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE = $8D56;
  GL_MAX_SAMPLES = $8D57;
  GL_INDEX = $8222;
var
  GLAD_GL_ARB_framebuffer_sRGB: boolean;
const
  GL_FRAMEBUFFER_SRGB = $8DB9;
var
  GLAD_GL_ARB_geometry_shader4: boolean;
const
  GL_LINES_ADJACENCY_ARB = $000A;
  GL_LINE_STRIP_ADJACENCY_ARB = $000B;
  GL_TRIANGLES_ADJACENCY_ARB = $000C;
  GL_TRIANGLE_STRIP_ADJACENCY_ARB = $000D;
  GL_PROGRAM_POINT_SIZE_ARB = $8642;
  GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_ARB = $8C29;
  GL_FRAMEBUFFER_ATTACHMENT_LAYERED_ARB = $8DA7;
  GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_ARB = $8DA8;
  GL_FRAMEBUFFER_INCOMPLETE_LAYER_COUNT_ARB = $8DA9;
  GL_GEOMETRY_SHADER_ARB = $8DD9;
  GL_GEOMETRY_VERTICES_OUT_ARB = $8DDA;
  GL_GEOMETRY_INPUT_TYPE_ARB = $8DDB;
  GL_GEOMETRY_OUTPUT_TYPE_ARB = $8DDC;
  GL_MAX_GEOMETRY_VARYING_COMPONENTS_ARB = $8DDD;
  GL_MAX_VERTEX_VARYING_COMPONENTS_ARB = $8DDE;
  GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_ARB = $8DDF;
  GL_MAX_GEOMETRY_OUTPUT_VERTICES_ARB = $8DE0;
  GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_ARB = $8DE1;
  GL_MAX_VARYING_COMPONENTS = $8B4B;
var
  GLAD_GL_ARB_get_program_binary: boolean;
const
  GL_PROGRAM_BINARY_RETRIEVABLE_HINT = $8257;
  GL_PROGRAM_BINARY_LENGTH = $8741;
  GL_NUM_PROGRAM_BINARY_FORMATS = $87FE;
  GL_PROGRAM_BINARY_FORMATS = $87FF;
var
  GLAD_GL_ARB_get_texture_sub_image: boolean;
var
  GLAD_GL_ARB_gl_spirv: boolean;
const
  GL_SHADER_BINARY_FORMAT_SPIR_V_ARB = $9551;
  GL_SPIR_V_BINARY_ARB = $9552;
var
  GLAD_GL_ARB_gpu_shader5: boolean;
const
  GL_GEOMETRY_SHADER_INVOCATIONS = $887F;
  GL_MAX_GEOMETRY_SHADER_INVOCATIONS = $8E5A;
  GL_MIN_FRAGMENT_INTERPOLATION_OFFSET = $8E5B;
  GL_MAX_FRAGMENT_INTERPOLATION_OFFSET = $8E5C;
  GL_FRAGMENT_INTERPOLATION_OFFSET_BITS = $8E5D;
  GL_MAX_VERTEX_STREAMS = $8E71;
var
  GLAD_GL_ARB_gpu_shader_fp64: boolean;
const
  GL_DOUBLE = $140A;
  GL_DOUBLE_VEC2 = $8FFC;
  GL_DOUBLE_VEC3 = $8FFD;
  GL_DOUBLE_VEC4 = $8FFE;
  GL_DOUBLE_MAT2 = $8F46;
  GL_DOUBLE_MAT3 = $8F47;
  GL_DOUBLE_MAT4 = $8F48;
  GL_DOUBLE_MAT2x3 = $8F49;
  GL_DOUBLE_MAT2x4 = $8F4A;
  GL_DOUBLE_MAT3x2 = $8F4B;
  GL_DOUBLE_MAT3x4 = $8F4C;
  GL_DOUBLE_MAT4x2 = $8F4D;
  GL_DOUBLE_MAT4x3 = $8F4E;
var
  GLAD_GL_ARB_gpu_shader_int64: boolean;
const
  GL_INT64_ARB = $140E;
  GL_INT64_VEC2_ARB = $8FE9;
  GL_INT64_VEC3_ARB = $8FEA;
  GL_INT64_VEC4_ARB = $8FEB;
  GL_UNSIGNED_INT64_VEC2_ARB = $8FF5;
  GL_UNSIGNED_INT64_VEC3_ARB = $8FF6;
  GL_UNSIGNED_INT64_VEC4_ARB = $8FF7;
var
  GLAD_GL_ARB_half_float_pixel: boolean;
const
  GL_HALF_FLOAT_ARB = $140B;
var
  GLAD_GL_ARB_half_float_vertex: boolean;
const
  GL_HALF_FLOAT = $140B;
var
  GLAD_GL_ARB_imaging: boolean;
const
  GL_BLEND_COLOR = $8005;
  GL_BLEND_EQUATION = $8009;
  GL_CONSTANT_COLOR = $8001;
  GL_ONE_MINUS_CONSTANT_COLOR = $8002;
  GL_CONSTANT_ALPHA = $8003;
  GL_ONE_MINUS_CONSTANT_ALPHA = $8004;
  GL_FUNC_ADD = $8006;
  GL_FUNC_REVERSE_SUBTRACT = $800B;
  GL_FUNC_SUBTRACT = $800A;
  GL_MIN = $8007;
  GL_MAX = $8008;
  GL_CONVOLUTION_1D = $8010;
  GL_CONVOLUTION_2D = $8011;
  GL_SEPARABLE_2D = $8012;
  GL_CONVOLUTION_BORDER_MODE = $8013;
  GL_CONVOLUTION_FILTER_SCALE = $8014;
  GL_CONVOLUTION_FILTER_BIAS = $8015;
  GL_REDUCE = $8016;
  GL_CONVOLUTION_FORMAT = $8017;
  GL_CONVOLUTION_WIDTH = $8018;
  GL_CONVOLUTION_HEIGHT = $8019;
  GL_MAX_CONVOLUTION_WIDTH = $801A;
  GL_MAX_CONVOLUTION_HEIGHT = $801B;
  GL_POST_CONVOLUTION_RED_SCALE = $801C;
  GL_POST_CONVOLUTION_GREEN_SCALE = $801D;
  GL_POST_CONVOLUTION_BLUE_SCALE = $801E;
  GL_POST_CONVOLUTION_ALPHA_SCALE = $801F;
  GL_POST_CONVOLUTION_RED_BIAS = $8020;
  GL_POST_CONVOLUTION_GREEN_BIAS = $8021;
  GL_POST_CONVOLUTION_BLUE_BIAS = $8022;
  GL_POST_CONVOLUTION_ALPHA_BIAS = $8023;
  GL_HISTOGRAM = $8024;
  GL_PROXY_HISTOGRAM = $8025;
  GL_HISTOGRAM_WIDTH = $8026;
  GL_HISTOGRAM_FORMAT = $8027;
  GL_HISTOGRAM_RED_SIZE = $8028;
  GL_HISTOGRAM_GREEN_SIZE = $8029;
  GL_HISTOGRAM_BLUE_SIZE = $802A;
  GL_HISTOGRAM_ALPHA_SIZE = $802B;
  GL_HISTOGRAM_LUMINANCE_SIZE = $802C;
  GL_HISTOGRAM_SINK = $802D;
  GL_MINMAX = $802E;
  GL_MINMAX_FORMAT = $802F;
  GL_MINMAX_SINK = $8030;
  GL_TABLE_TOO_LARGE = $8031;
  GL_COLOR_MATRIX = $80B1;
  GL_COLOR_MATRIX_STACK_DEPTH = $80B2;
  GL_MAX_COLOR_MATRIX_STACK_DEPTH = $80B3;
  GL_POST_COLOR_MATRIX_RED_SCALE = $80B4;
  GL_POST_COLOR_MATRIX_GREEN_SCALE = $80B5;
  GL_POST_COLOR_MATRIX_BLUE_SCALE = $80B6;
  GL_POST_COLOR_MATRIX_ALPHA_SCALE = $80B7;
  GL_POST_COLOR_MATRIX_RED_BIAS = $80B8;
  GL_POST_COLOR_MATRIX_GREEN_BIAS = $80B9;
  GL_POST_COLOR_MATRIX_BLUE_BIAS = $80BA;
  GL_POST_COLOR_MATRIX_ALPHA_BIAS = $80BB;
  GL_COLOR_TABLE = $80D0;
  GL_POST_CONVOLUTION_COLOR_TABLE = $80D1;
  GL_POST_COLOR_MATRIX_COLOR_TABLE = $80D2;
  GL_PROXY_COLOR_TABLE = $80D3;
  GL_PROXY_POST_CONVOLUTION_COLOR_TABLE = $80D4;
  GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE = $80D5;
  GL_COLOR_TABLE_SCALE = $80D6;
  GL_COLOR_TABLE_BIAS = $80D7;
  GL_COLOR_TABLE_FORMAT = $80D8;
  GL_COLOR_TABLE_WIDTH = $80D9;
  GL_COLOR_TABLE_RED_SIZE = $80DA;
  GL_COLOR_TABLE_GREEN_SIZE = $80DB;
  GL_COLOR_TABLE_BLUE_SIZE = $80DC;
  GL_COLOR_TABLE_ALPHA_SIZE = $80DD;
  GL_COLOR_TABLE_LUMINANCE_SIZE = $80DE;
  GL_COLOR_TABLE_INTENSITY_SIZE = $80DF;
  GL_CONSTANT_BORDER = $8151;
  GL_REPLICATE_BORDER = $8153;
  GL_CONVOLUTION_BORDER_COLOR = $8154;
var
  GLAD_GL_ARB_indirect_parameters: boolean;
const
  GL_PARAMETER_BUFFER_ARB = $80EE;
  GL_PARAMETER_BUFFER_BINDING_ARB = $80EF;
var
  GLAD_GL_ARB_instanced_arrays: boolean;
const
  GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ARB = $88FE;
var
  GLAD_GL_ARB_internalformat_query: boolean;
const
  GL_NUM_SAMPLE_COUNTS = $9380;
var
  GLAD_GL_ARB_internalformat_query2: boolean;
const
  GL_IMAGE_FORMAT_COMPATIBILITY_TYPE = $90C7;
  GL_SAMPLES = $80A9;
  GL_TEXTURE_1D_ARRAY = $8C18;
  GL_TEXTURE_2D_ARRAY = $8C1A;
  GL_TEXTURE_3D = $806F;
  GL_TEXTURE_CUBE_MAP = $8513;
  GL_TEXTURE_CUBE_MAP_ARRAY = $9009;
  GL_TEXTURE_RECTANGLE = $84F5;
  GL_TEXTURE_BUFFER = $8C2A;
  GL_TEXTURE_2D_MULTISAMPLE = $9100;
  GL_TEXTURE_2D_MULTISAMPLE_ARRAY = $9102;
  GL_TEXTURE_COMPRESSED = $86A1;
  GL_INTERNALFORMAT_SUPPORTED = $826F;
  GL_INTERNALFORMAT_PREFERRED = $8270;
  GL_INTERNALFORMAT_RED_SIZE = $8271;
  GL_INTERNALFORMAT_GREEN_SIZE = $8272;
  GL_INTERNALFORMAT_BLUE_SIZE = $8273;
  GL_INTERNALFORMAT_ALPHA_SIZE = $8274;
  GL_INTERNALFORMAT_DEPTH_SIZE = $8275;
  GL_INTERNALFORMAT_STENCIL_SIZE = $8276;
  GL_INTERNALFORMAT_SHARED_SIZE = $8277;
  GL_INTERNALFORMAT_RED_TYPE = $8278;
  GL_INTERNALFORMAT_GREEN_TYPE = $8279;
  GL_INTERNALFORMAT_BLUE_TYPE = $827A;
  GL_INTERNALFORMAT_ALPHA_TYPE = $827B;
  GL_INTERNALFORMAT_DEPTH_TYPE = $827C;
  GL_INTERNALFORMAT_STENCIL_TYPE = $827D;
  GL_MAX_WIDTH = $827E;
  GL_MAX_HEIGHT = $827F;
  GL_MAX_DEPTH = $8280;
  GL_MAX_LAYERS = $8281;
  GL_MAX_COMBINED_DIMENSIONS = $8282;
  GL_COLOR_COMPONENTS = $8283;
  GL_DEPTH_COMPONENTS = $8284;
  GL_STENCIL_COMPONENTS = $8285;
  GL_COLOR_RENDERABLE = $8286;
  GL_DEPTH_RENDERABLE = $8287;
  GL_STENCIL_RENDERABLE = $8288;
  GL_FRAMEBUFFER_RENDERABLE = $8289;
  GL_FRAMEBUFFER_RENDERABLE_LAYERED = $828A;
  GL_FRAMEBUFFER_BLEND = $828B;
  GL_READ_PIXELS = $828C;
  GL_READ_PIXELS_FORMAT = $828D;
  GL_READ_PIXELS_TYPE = $828E;
  GL_TEXTURE_IMAGE_FORMAT = $828F;
  GL_TEXTURE_IMAGE_TYPE = $8290;
  GL_GET_TEXTURE_IMAGE_FORMAT = $8291;
  GL_GET_TEXTURE_IMAGE_TYPE = $8292;
  GL_MIPMAP = $8293;
  GL_MANUAL_GENERATE_MIPMAP = $8294;
  GL_AUTO_GENERATE_MIPMAP = $8295;
  GL_COLOR_ENCODING = $8296;
  GL_SRGB_READ = $8297;
  GL_SRGB_WRITE = $8298;
  GL_SRGB_DECODE_ARB = $8299;
  GL_FILTER = $829A;
  GL_VERTEX_TEXTURE = $829B;
  GL_TESS_CONTROL_TEXTURE = $829C;
  GL_TESS_EVALUATION_TEXTURE = $829D;
  GL_GEOMETRY_TEXTURE = $829E;
  GL_FRAGMENT_TEXTURE = $829F;
  GL_COMPUTE_TEXTURE = $82A0;
  GL_TEXTURE_SHADOW = $82A1;
  GL_TEXTURE_GATHER = $82A2;
  GL_TEXTURE_GATHER_SHADOW = $82A3;
  GL_SHADER_IMAGE_LOAD = $82A4;
  GL_SHADER_IMAGE_STORE = $82A5;
  GL_SHADER_IMAGE_ATOMIC = $82A6;
  GL_IMAGE_TEXEL_SIZE = $82A7;
  GL_IMAGE_COMPATIBILITY_CLASS = $82A8;
  GL_IMAGE_PIXEL_FORMAT = $82A9;
  GL_IMAGE_PIXEL_TYPE = $82AA;
  GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST = $82AC;
  GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST = $82AD;
  GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE = $82AE;
  GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE = $82AF;
  GL_TEXTURE_COMPRESSED_BLOCK_WIDTH = $82B1;
  GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT = $82B2;
  GL_TEXTURE_COMPRESSED_BLOCK_SIZE = $82B3;
  GL_CLEAR_BUFFER = $82B4;
  GL_TEXTURE_VIEW = $82B5;
  GL_VIEW_COMPATIBILITY_CLASS = $82B6;
  GL_FULL_SUPPORT = $82B7;
  GL_CAVEAT_SUPPORT = $82B8;
  GL_IMAGE_CLASS_4_X_32 = $82B9;
  GL_IMAGE_CLASS_2_X_32 = $82BA;
  GL_IMAGE_CLASS_1_X_32 = $82BB;
  GL_IMAGE_CLASS_4_X_16 = $82BC;
  GL_IMAGE_CLASS_2_X_16 = $82BD;
  GL_IMAGE_CLASS_1_X_16 = $82BE;
  GL_IMAGE_CLASS_4_X_8 = $82BF;
  GL_IMAGE_CLASS_2_X_8 = $82C0;
  GL_IMAGE_CLASS_1_X_8 = $82C1;
  GL_IMAGE_CLASS_11_11_10 = $82C2;
  GL_IMAGE_CLASS_10_10_10_2 = $82C3;
  GL_VIEW_CLASS_128_BITS = $82C4;
  GL_VIEW_CLASS_96_BITS = $82C5;
  GL_VIEW_CLASS_64_BITS = $82C6;
  GL_VIEW_CLASS_48_BITS = $82C7;
  GL_VIEW_CLASS_32_BITS = $82C8;
  GL_VIEW_CLASS_24_BITS = $82C9;
  GL_VIEW_CLASS_16_BITS = $82CA;
  GL_VIEW_CLASS_8_BITS = $82CB;
  GL_VIEW_CLASS_S3TC_DXT1_RGB = $82CC;
  GL_VIEW_CLASS_S3TC_DXT1_RGBA = $82CD;
  GL_VIEW_CLASS_S3TC_DXT3_RGBA = $82CE;
  GL_VIEW_CLASS_S3TC_DXT5_RGBA = $82CF;
  GL_VIEW_CLASS_RGTC1_RED = $82D0;
  GL_VIEW_CLASS_RGTC2_RG = $82D1;
  GL_VIEW_CLASS_BPTC_UNORM = $82D2;
  GL_VIEW_CLASS_BPTC_FLOAT = $82D3;
  GL_VIEW_CLASS_EAC_R11 = $9383;
  GL_VIEW_CLASS_EAC_RG11 = $9384;
  GL_VIEW_CLASS_ETC2_RGB = $9385;
  GL_VIEW_CLASS_ETC2_RGBA = $9386;
  GL_VIEW_CLASS_ETC2_EAC_RGBA = $9387;
  GL_VIEW_CLASS_ASTC_4x4_RGBA = $9388;
  GL_VIEW_CLASS_ASTC_5x4_RGBA = $9389;
  GL_VIEW_CLASS_ASTC_5x5_RGBA = $938A;
  GL_VIEW_CLASS_ASTC_6x5_RGBA = $938B;
  GL_VIEW_CLASS_ASTC_6x6_RGBA = $938C;
  GL_VIEW_CLASS_ASTC_8x5_RGBA = $938D;
  GL_VIEW_CLASS_ASTC_8x6_RGBA = $938E;
  GL_VIEW_CLASS_ASTC_8x8_RGBA = $938F;
  GL_VIEW_CLASS_ASTC_10x5_RGBA = $9390;
  GL_VIEW_CLASS_ASTC_10x6_RGBA = $9391;
  GL_VIEW_CLASS_ASTC_10x8_RGBA = $9392;
  GL_VIEW_CLASS_ASTC_10x10_RGBA = $9393;
  GL_VIEW_CLASS_ASTC_12x10_RGBA = $9394;
  GL_VIEW_CLASS_ASTC_12x12_RGBA = $9395;
var
  GLAD_GL_ARB_invalidate_subdata: boolean;
var
  GLAD_GL_ARB_map_buffer_alignment: boolean;
const
  GL_MIN_MAP_BUFFER_ALIGNMENT = $90BC;
var
  GLAD_GL_ARB_map_buffer_range: boolean;
const
  GL_MAP_INVALIDATE_RANGE_BIT = $0004;
  GL_MAP_INVALIDATE_BUFFER_BIT = $0008;
  GL_MAP_FLUSH_EXPLICIT_BIT = $0010;
  GL_MAP_UNSYNCHRONIZED_BIT = $0020;
var
  GLAD_GL_ARB_matrix_palette: boolean;
const
  GL_MATRIX_PALETTE_ARB = $8840;
  GL_MAX_MATRIX_PALETTE_STACK_DEPTH_ARB = $8841;
  GL_MAX_PALETTE_MATRICES_ARB = $8842;
  GL_CURRENT_PALETTE_MATRIX_ARB = $8843;
  GL_MATRIX_INDEX_ARRAY_ARB = $8844;
  GL_CURRENT_MATRIX_INDEX_ARB = $8845;
  GL_MATRIX_INDEX_ARRAY_SIZE_ARB = $8846;
  GL_MATRIX_INDEX_ARRAY_TYPE_ARB = $8847;
  GL_MATRIX_INDEX_ARRAY_STRIDE_ARB = $8848;
  GL_MATRIX_INDEX_ARRAY_POINTER_ARB = $8849;
var
  GLAD_GL_ARB_multi_bind: boolean;
var
  GLAD_GL_ARB_multi_draw_indirect: boolean;
var
  GLAD_GL_ARB_multisample: boolean;
const
  GL_MULTISAMPLE_ARB = $809D;
  GL_SAMPLE_ALPHA_TO_COVERAGE_ARB = $809E;
  GL_SAMPLE_ALPHA_TO_ONE_ARB = $809F;
  GL_SAMPLE_COVERAGE_ARB = $80A0;
  GL_SAMPLE_BUFFERS_ARB = $80A8;
  GL_SAMPLES_ARB = $80A9;
  GL_SAMPLE_COVERAGE_VALUE_ARB = $80AA;
  GL_SAMPLE_COVERAGE_INVERT_ARB = $80AB;
  GL_MULTISAMPLE_BIT_ARB = $20000000;
var
  GLAD_GL_ARB_multitexture: boolean;
const
  GL_TEXTURE0_ARB = $84C0;
  GL_TEXTURE1_ARB = $84C1;
  GL_TEXTURE2_ARB = $84C2;
  GL_TEXTURE3_ARB = $84C3;
  GL_TEXTURE4_ARB = $84C4;
  GL_TEXTURE5_ARB = $84C5;
  GL_TEXTURE6_ARB = $84C6;
  GL_TEXTURE7_ARB = $84C7;
  GL_TEXTURE8_ARB = $84C8;
  GL_TEXTURE9_ARB = $84C9;
  GL_TEXTURE10_ARB = $84CA;
  GL_TEXTURE11_ARB = $84CB;
  GL_TEXTURE12_ARB = $84CC;
  GL_TEXTURE13_ARB = $84CD;
  GL_TEXTURE14_ARB = $84CE;
  GL_TEXTURE15_ARB = $84CF;
  GL_TEXTURE16_ARB = $84D0;
  GL_TEXTURE17_ARB = $84D1;
  GL_TEXTURE18_ARB = $84D2;
  GL_TEXTURE19_ARB = $84D3;
  GL_TEXTURE20_ARB = $84D4;
  GL_TEXTURE21_ARB = $84D5;
  GL_TEXTURE22_ARB = $84D6;
  GL_TEXTURE23_ARB = $84D7;
  GL_TEXTURE24_ARB = $84D8;
  GL_TEXTURE25_ARB = $84D9;
  GL_TEXTURE26_ARB = $84DA;
  GL_TEXTURE27_ARB = $84DB;
  GL_TEXTURE28_ARB = $84DC;
  GL_TEXTURE29_ARB = $84DD;
  GL_TEXTURE30_ARB = $84DE;
  GL_TEXTURE31_ARB = $84DF;
  GL_ACTIVE_TEXTURE_ARB = $84E0;
  GL_CLIENT_ACTIVE_TEXTURE_ARB = $84E1;
  GL_MAX_TEXTURE_UNITS_ARB = $84E2;
var
  GLAD_GL_ARB_occlusion_query: boolean;
const
  GL_QUERY_COUNTER_BITS_ARB = $8864;
  GL_CURRENT_QUERY_ARB = $8865;
  GL_QUERY_RESULT_ARB = $8866;
  GL_QUERY_RESULT_AVAILABLE_ARB = $8867;
  GL_SAMPLES_PASSED_ARB = $8914;
var
  GLAD_GL_ARB_occlusion_query2: boolean;
const
  GL_ANY_SAMPLES_PASSED = $8C2F;
var
  GLAD_GL_ARB_parallel_shader_compile: boolean;
const
  GL_MAX_SHADER_COMPILER_THREADS_ARB = $91B0;
  GL_COMPLETION_STATUS_ARB = $91B1;
var
  GLAD_GL_ARB_pipeline_statistics_query: boolean;
const
  GL_VERTICES_SUBMITTED_ARB = $82EE;
  GL_PRIMITIVES_SUBMITTED_ARB = $82EF;
  GL_VERTEX_SHADER_INVOCATIONS_ARB = $82F0;
  GL_TESS_CONTROL_SHADER_PATCHES_ARB = $82F1;
  GL_TESS_EVALUATION_SHADER_INVOCATIONS_ARB = $82F2;
  GL_GEOMETRY_SHADER_PRIMITIVES_EMITTED_ARB = $82F3;
  GL_FRAGMENT_SHADER_INVOCATIONS_ARB = $82F4;
  GL_COMPUTE_SHADER_INVOCATIONS_ARB = $82F5;
  GL_CLIPPING_INPUT_PRIMITIVES_ARB = $82F6;
  GL_CLIPPING_OUTPUT_PRIMITIVES_ARB = $82F7;
var
  GLAD_GL_ARB_pixel_buffer_object: boolean;
const
  GL_PIXEL_PACK_BUFFER_ARB = $88EB;
  GL_PIXEL_UNPACK_BUFFER_ARB = $88EC;
  GL_PIXEL_PACK_BUFFER_BINDING_ARB = $88ED;
  GL_PIXEL_UNPACK_BUFFER_BINDING_ARB = $88EF;
var
  GLAD_GL_ARB_point_parameters: boolean;
const
  GL_POINT_SIZE_MIN_ARB = $8126;
  GL_POINT_SIZE_MAX_ARB = $8127;
  GL_POINT_FADE_THRESHOLD_SIZE_ARB = $8128;
  GL_POINT_DISTANCE_ATTENUATION_ARB = $8129;
var
  GLAD_GL_ARB_point_sprite: boolean;
const
  GL_POINT_SPRITE_ARB = $8861;
  GL_COORD_REPLACE_ARB = $8862;
var
  GLAD_GL_ARB_polygon_offset_clamp: boolean;
const
  GL_POLYGON_OFFSET_CLAMP = $8E1B;
var
  GLAD_GL_ARB_post_depth_coverage: boolean;
var
  GLAD_GL_ARB_program_interface_query: boolean;
const
  GL_UNIFORM = $92E1;
  GL_UNIFORM_BLOCK = $92E2;
  GL_PROGRAM_INPUT = $92E3;
  GL_PROGRAM_OUTPUT = $92E4;
  GL_BUFFER_VARIABLE = $92E5;
  GL_SHADER_STORAGE_BLOCK = $92E6;
  GL_ATOMIC_COUNTER_BUFFER = $92C0;
  GL_VERTEX_SUBROUTINE = $92E8;
  GL_TESS_CONTROL_SUBROUTINE = $92E9;
  GL_TESS_EVALUATION_SUBROUTINE = $92EA;
  GL_GEOMETRY_SUBROUTINE = $92EB;
  GL_FRAGMENT_SUBROUTINE = $92EC;
  GL_COMPUTE_SUBROUTINE = $92ED;
  GL_VERTEX_SUBROUTINE_UNIFORM = $92EE;
  GL_TESS_CONTROL_SUBROUTINE_UNIFORM = $92EF;
  GL_TESS_EVALUATION_SUBROUTINE_UNIFORM = $92F0;
  GL_GEOMETRY_SUBROUTINE_UNIFORM = $92F1;
  GL_FRAGMENT_SUBROUTINE_UNIFORM = $92F2;
  GL_COMPUTE_SUBROUTINE_UNIFORM = $92F3;
  GL_TRANSFORM_FEEDBACK_VARYING = $92F4;
  GL_ACTIVE_RESOURCES = $92F5;
  GL_MAX_NAME_LENGTH = $92F6;
  GL_MAX_NUM_ACTIVE_VARIABLES = $92F7;
  GL_MAX_NUM_COMPATIBLE_SUBROUTINES = $92F8;
  GL_NAME_LENGTH = $92F9;
  GL_TYPE = $92FA;
  GL_ARRAY_SIZE = $92FB;
  GL_OFFSET = $92FC;
  GL_BLOCK_INDEX = $92FD;
  GL_ARRAY_STRIDE = $92FE;
  GL_MATRIX_STRIDE = $92FF;
  GL_IS_ROW_MAJOR = $9300;
  GL_ATOMIC_COUNTER_BUFFER_INDEX = $9301;
  GL_BUFFER_BINDING = $9302;
  GL_BUFFER_DATA_SIZE = $9303;
  GL_NUM_ACTIVE_VARIABLES = $9304;
  GL_ACTIVE_VARIABLES = $9305;
  GL_REFERENCED_BY_VERTEX_SHADER = $9306;
  GL_REFERENCED_BY_TESS_CONTROL_SHADER = $9307;
  GL_REFERENCED_BY_TESS_EVALUATION_SHADER = $9308;
  GL_REFERENCED_BY_GEOMETRY_SHADER = $9309;
  GL_REFERENCED_BY_FRAGMENT_SHADER = $930A;
  GL_REFERENCED_BY_COMPUTE_SHADER = $930B;
  GL_TOP_LEVEL_ARRAY_SIZE = $930C;
  GL_TOP_LEVEL_ARRAY_STRIDE = $930D;
  GL_LOCATION = $930E;
  GL_LOCATION_INDEX = $930F;
  GL_IS_PER_PATCH = $92E7;
  GL_NUM_COMPATIBLE_SUBROUTINES = $8E4A;
  GL_COMPATIBLE_SUBROUTINES = $8E4B;
var
  GLAD_GL_ARB_provoking_vertex: boolean;
const
  GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION = $8E4C;
  GL_FIRST_VERTEX_CONVENTION = $8E4D;
  GL_LAST_VERTEX_CONVENTION = $8E4E;
  GL_PROVOKING_VERTEX = $8E4F;
var
  GLAD_GL_ARB_query_buffer_object: boolean;
const
  GL_QUERY_BUFFER = $9192;
  GL_QUERY_BUFFER_BARRIER_BIT = $00008000;
  GL_QUERY_BUFFER_BINDING = $9193;
  GL_QUERY_RESULT_NO_WAIT = $9194;
var
  GLAD_GL_ARB_robust_buffer_access_behavior: boolean;
var
  GLAD_GL_ARB_robustness: boolean;
const
  GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT_ARB = $00000004;
  GL_LOSE_CONTEXT_ON_RESET_ARB = $8252;
  GL_GUILTY_CONTEXT_RESET_ARB = $8253;
  GL_INNOCENT_CONTEXT_RESET_ARB = $8254;
  GL_UNKNOWN_CONTEXT_RESET_ARB = $8255;
  GL_RESET_NOTIFICATION_STRATEGY_ARB = $8256;
  GL_NO_RESET_NOTIFICATION_ARB = $8261;
var
  GLAD_GL_ARB_robustness_isolation: boolean;
var
  GLAD_GL_ARB_sample_locations: boolean;
const
  GL_SAMPLE_LOCATION_SUBPIXEL_BITS_ARB = $933D;
  GL_SAMPLE_LOCATION_PIXEL_GRID_WIDTH_ARB = $933E;
  GL_SAMPLE_LOCATION_PIXEL_GRID_HEIGHT_ARB = $933F;
  GL_PROGRAMMABLE_SAMPLE_LOCATION_TABLE_SIZE_ARB = $9340;
  GL_SAMPLE_LOCATION_ARB = $8E50;
  GL_PROGRAMMABLE_SAMPLE_LOCATION_ARB = $9341;
  GL_FRAMEBUFFER_PROGRAMMABLE_SAMPLE_LOCATIONS_ARB = $9342;
  GL_FRAMEBUFFER_SAMPLE_LOCATION_PIXEL_GRID_ARB = $9343;
var
  GLAD_GL_ARB_sample_shading: boolean;
const
  GL_SAMPLE_SHADING_ARB = $8C36;
  GL_MIN_SAMPLE_SHADING_VALUE_ARB = $8C37;
var
  GLAD_GL_ARB_sampler_objects: boolean;
const
  GL_SAMPLER_BINDING = $8919;
var
  GLAD_GL_ARB_seamless_cube_map: boolean;
var
  GLAD_GL_ARB_seamless_cubemap_per_texture: boolean;
var
  GLAD_GL_ARB_separate_shader_objects: boolean;
const
  GL_VERTEX_SHADER_BIT = $00000001;
  GL_FRAGMENT_SHADER_BIT = $00000002;
  GL_GEOMETRY_SHADER_BIT = $00000004;
  GL_TESS_CONTROL_SHADER_BIT = $00000008;
  GL_TESS_EVALUATION_SHADER_BIT = $00000010;
  GL_ALL_SHADER_BITS = $FFFFFFFF;
  GL_PROGRAM_SEPARABLE = $8258;
  GL_ACTIVE_PROGRAM = $8259;
  GL_PROGRAM_PIPELINE_BINDING = $825A;
var
  GLAD_GL_ARB_shader_atomic_counter_ops: boolean;
var
  GLAD_GL_ARB_shader_atomic_counters: boolean;
const
  GL_ATOMIC_COUNTER_BUFFER_BINDING = $92C1;
  GL_ATOMIC_COUNTER_BUFFER_START = $92C2;
  GL_ATOMIC_COUNTER_BUFFER_SIZE = $92C3;
  GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE = $92C4;
  GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS = $92C5;
  GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES = $92C6;
  GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER = $92C7;
  GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER = $92C8;
  GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER = $92C9;
  GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER = $92CA;
  GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER = $92CB;
  GL_MAX_VERTEX_ATOMIC_COUNTER_BUFFERS = $92CC;
  GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS = $92CD;
  GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS = $92CE;
  GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS = $92CF;
  GL_MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS = $92D0;
  GL_MAX_COMBINED_ATOMIC_COUNTER_BUFFERS = $92D1;
  GL_MAX_VERTEX_ATOMIC_COUNTERS = $92D2;
  GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS = $92D3;
  GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS = $92D4;
  GL_MAX_GEOMETRY_ATOMIC_COUNTERS = $92D5;
  GL_MAX_FRAGMENT_ATOMIC_COUNTERS = $92D6;
  GL_MAX_COMBINED_ATOMIC_COUNTERS = $92D7;
  GL_MAX_ATOMIC_COUNTER_BUFFER_SIZE = $92D8;
  GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS = $92DC;
  GL_ACTIVE_ATOMIC_COUNTER_BUFFERS = $92D9;
  GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX = $92DA;
  GL_UNSIGNED_INT_ATOMIC_COUNTER = $92DB;
var
  GLAD_GL_ARB_shader_ballot: boolean;
var
  GLAD_GL_ARB_shader_bit_encoding: boolean;
var
  GLAD_GL_ARB_shader_clock: boolean;
var
  GLAD_GL_ARB_shader_draw_parameters: boolean;
var
  GLAD_GL_ARB_shader_group_vote: boolean;
var
  GLAD_GL_ARB_shader_image_load_store: boolean;
const
  GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT = $00000001;
  GL_ELEMENT_ARRAY_BARRIER_BIT = $00000002;
  GL_UNIFORM_BARRIER_BIT = $00000004;
  GL_TEXTURE_FETCH_BARRIER_BIT = $00000008;
  GL_SHADER_IMAGE_ACCESS_BARRIER_BIT = $00000020;
  GL_COMMAND_BARRIER_BIT = $00000040;
  GL_PIXEL_BUFFER_BARRIER_BIT = $00000080;
  GL_TEXTURE_UPDATE_BARRIER_BIT = $00000100;
  GL_BUFFER_UPDATE_BARRIER_BIT = $00000200;
  GL_FRAMEBUFFER_BARRIER_BIT = $00000400;
  GL_TRANSFORM_FEEDBACK_BARRIER_BIT = $00000800;
  GL_ATOMIC_COUNTER_BARRIER_BIT = $00001000;
  GL_ALL_BARRIER_BITS = $FFFFFFFF;
  GL_MAX_IMAGE_UNITS = $8F38;
  GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS = $8F39;
  GL_IMAGE_BINDING_NAME = $8F3A;
  GL_IMAGE_BINDING_LEVEL = $8F3B;
  GL_IMAGE_BINDING_LAYERED = $8F3C;
  GL_IMAGE_BINDING_LAYER = $8F3D;
  GL_IMAGE_BINDING_ACCESS = $8F3E;
  GL_IMAGE_1D = $904C;
  GL_IMAGE_2D = $904D;
  GL_IMAGE_3D = $904E;
  GL_IMAGE_2D_RECT = $904F;
  GL_IMAGE_CUBE = $9050;
  GL_IMAGE_BUFFER = $9051;
  GL_IMAGE_1D_ARRAY = $9052;
  GL_IMAGE_2D_ARRAY = $9053;
  GL_IMAGE_CUBE_MAP_ARRAY = $9054;
  GL_IMAGE_2D_MULTISAMPLE = $9055;
  GL_IMAGE_2D_MULTISAMPLE_ARRAY = $9056;
  GL_INT_IMAGE_1D = $9057;
  GL_INT_IMAGE_2D = $9058;
  GL_INT_IMAGE_3D = $9059;
  GL_INT_IMAGE_2D_RECT = $905A;
  GL_INT_IMAGE_CUBE = $905B;
  GL_INT_IMAGE_BUFFER = $905C;
  GL_INT_IMAGE_1D_ARRAY = $905D;
  GL_INT_IMAGE_2D_ARRAY = $905E;
  GL_INT_IMAGE_CUBE_MAP_ARRAY = $905F;
  GL_INT_IMAGE_2D_MULTISAMPLE = $9060;
  GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY = $9061;
  GL_UNSIGNED_INT_IMAGE_1D = $9062;
  GL_UNSIGNED_INT_IMAGE_2D = $9063;
  GL_UNSIGNED_INT_IMAGE_3D = $9064;
  GL_UNSIGNED_INT_IMAGE_2D_RECT = $9065;
  GL_UNSIGNED_INT_IMAGE_CUBE = $9066;
  GL_UNSIGNED_INT_IMAGE_BUFFER = $9067;
  GL_UNSIGNED_INT_IMAGE_1D_ARRAY = $9068;
  GL_UNSIGNED_INT_IMAGE_2D_ARRAY = $9069;
  GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY = $906A;
  GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE = $906B;
  GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY = $906C;
  GL_MAX_IMAGE_SAMPLES = $906D;
  GL_IMAGE_BINDING_FORMAT = $906E;
  GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE = $90C8;
  GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS = $90C9;
  GL_MAX_VERTEX_IMAGE_UNIFORMS = $90CA;
  GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS = $90CB;
  GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS = $90CC;
  GL_MAX_GEOMETRY_IMAGE_UNIFORMS = $90CD;
  GL_MAX_FRAGMENT_IMAGE_UNIFORMS = $90CE;
  GL_MAX_COMBINED_IMAGE_UNIFORMS = $90CF;
var
  GLAD_GL_ARB_shader_image_size: boolean;
var
  GLAD_GL_ARB_shader_objects: boolean;
const
  GL_PROGRAM_OBJECT_ARB = $8B40;
  GL_SHADER_OBJECT_ARB = $8B48;
  GL_OBJECT_TYPE_ARB = $8B4E;
  GL_OBJECT_SUBTYPE_ARB = $8B4F;
  GL_FLOAT_VEC2_ARB = $8B50;
  GL_FLOAT_VEC3_ARB = $8B51;
  GL_FLOAT_VEC4_ARB = $8B52;
  GL_INT_VEC2_ARB = $8B53;
  GL_INT_VEC3_ARB = $8B54;
  GL_INT_VEC4_ARB = $8B55;
  GL_BOOL_ARB = $8B56;
  GL_BOOL_VEC2_ARB = $8B57;
  GL_BOOL_VEC3_ARB = $8B58;
  GL_BOOL_VEC4_ARB = $8B59;
  GL_FLOAT_MAT2_ARB = $8B5A;
  GL_FLOAT_MAT3_ARB = $8B5B;
  GL_FLOAT_MAT4_ARB = $8B5C;
  GL_SAMPLER_1D_ARB = $8B5D;
  GL_SAMPLER_2D_ARB = $8B5E;
  GL_SAMPLER_3D_ARB = $8B5F;
  GL_SAMPLER_CUBE_ARB = $8B60;
  GL_SAMPLER_1D_SHADOW_ARB = $8B61;
  GL_SAMPLER_2D_SHADOW_ARB = $8B62;
  GL_SAMPLER_2D_RECT_ARB = $8B63;
  GL_SAMPLER_2D_RECT_SHADOW_ARB = $8B64;
  GL_OBJECT_DELETE_STATUS_ARB = $8B80;
  GL_OBJECT_COMPILE_STATUS_ARB = $8B81;
  GL_OBJECT_LINK_STATUS_ARB = $8B82;
  GL_OBJECT_VALIDATE_STATUS_ARB = $8B83;
  GL_OBJECT_INFO_LOG_LENGTH_ARB = $8B84;
  GL_OBJECT_ATTACHED_OBJECTS_ARB = $8B85;
  GL_OBJECT_ACTIVE_UNIFORMS_ARB = $8B86;
  GL_OBJECT_ACTIVE_UNIFORM_MAX_LENGTH_ARB = $8B87;
  GL_OBJECT_SHADER_SOURCE_LENGTH_ARB = $8B88;
var
  GLAD_GL_ARB_shader_precision: boolean;
var
  GLAD_GL_ARB_shader_stencil_export: boolean;
var
  GLAD_GL_ARB_shader_storage_buffer_object: boolean;
const
  GL_SHADER_STORAGE_BUFFER = $90D2;
  GL_SHADER_STORAGE_BUFFER_BINDING = $90D3;
  GL_SHADER_STORAGE_BUFFER_START = $90D4;
  GL_SHADER_STORAGE_BUFFER_SIZE = $90D5;
  GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS = $90D6;
  GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS = $90D7;
  GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS = $90D8;
  GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS = $90D9;
  GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS = $90DA;
  GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS = $90DB;
  GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS = $90DC;
  GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS = $90DD;
  GL_MAX_SHADER_STORAGE_BLOCK_SIZE = $90DE;
  GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT = $90DF;
  GL_SHADER_STORAGE_BARRIER_BIT = $00002000;
  GL_MAX_COMBINED_SHADER_OUTPUT_RESOURCES = $8F39;
var
  GLAD_GL_ARB_shader_subroutine: boolean;
const
  GL_ACTIVE_SUBROUTINES = $8DE5;
  GL_ACTIVE_SUBROUTINE_UNIFORMS = $8DE6;
  GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS = $8E47;
  GL_ACTIVE_SUBROUTINE_MAX_LENGTH = $8E48;
  GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH = $8E49;
  GL_MAX_SUBROUTINES = $8DE7;
  GL_MAX_SUBROUTINE_UNIFORM_LOCATIONS = $8DE8;
  GL_UNIFORM_SIZE = $8A38;
  GL_UNIFORM_NAME_LENGTH = $8A39;
var
  GLAD_GL_ARB_shader_texture_image_samples: boolean;
var
  GLAD_GL_ARB_shader_texture_lod: boolean;
var
  GLAD_GL_ARB_shader_viewport_layer_array: boolean;
var
  GLAD_GL_ARB_shading_language_100: boolean;
const
  GL_SHADING_LANGUAGE_VERSION_ARB = $8B8C;
var
  GLAD_GL_ARB_shading_language_420pack: boolean;
var
  GLAD_GL_ARB_shading_language_include: boolean;
const
  GL_SHADER_INCLUDE_ARB = $8DAE;
  GL_NAMED_STRING_LENGTH_ARB = $8DE9;
  GL_NAMED_STRING_TYPE_ARB = $8DEA;
var
  GLAD_GL_ARB_shading_language_packing: boolean;
var
  GLAD_GL_ARB_shadow: boolean;
const
  GL_TEXTURE_COMPARE_MODE_ARB = $884C;
  GL_TEXTURE_COMPARE_FUNC_ARB = $884D;
  GL_COMPARE_R_TO_TEXTURE_ARB = $884E;
var
  GLAD_GL_ARB_shadow_ambient: boolean;
const
  GL_TEXTURE_COMPARE_FAIL_VALUE_ARB = $80BF;
var
  GLAD_GL_ARB_sparse_buffer: boolean;
const
  GL_SPARSE_STORAGE_BIT_ARB = $0400;
  GL_SPARSE_BUFFER_PAGE_SIZE_ARB = $82F8;
var
  GLAD_GL_ARB_sparse_texture: boolean;
const
  GL_TEXTURE_SPARSE_ARB = $91A6;
  GL_VIRTUAL_PAGE_SIZE_INDEX_ARB = $91A7;
  GL_NUM_SPARSE_LEVELS_ARB = $91AA;
  GL_NUM_VIRTUAL_PAGE_SIZES_ARB = $91A8;
  GL_VIRTUAL_PAGE_SIZE_X_ARB = $9195;
  GL_VIRTUAL_PAGE_SIZE_Y_ARB = $9196;
  GL_VIRTUAL_PAGE_SIZE_Z_ARB = $9197;
  GL_MAX_SPARSE_TEXTURE_SIZE_ARB = $9198;
  GL_MAX_SPARSE_3D_TEXTURE_SIZE_ARB = $9199;
  GL_MAX_SPARSE_ARRAY_TEXTURE_LAYERS_ARB = $919A;
  GL_SPARSE_TEXTURE_FULL_ARRAY_CUBE_MIPMAPS_ARB = $91A9;
var
  GLAD_GL_ARB_sparse_texture2: boolean;
var
  GLAD_GL_ARB_sparse_texture_clamp: boolean;
var
  GLAD_GL_ARB_spirv_extensions: boolean;
const
  GL_SPIR_V_EXTENSIONS = $9553;
  GL_NUM_SPIR_V_EXTENSIONS = $9554;
var
  GLAD_GL_ARB_stencil_texturing: boolean;
const
  GL_DEPTH_STENCIL_TEXTURE_MODE = $90EA;
var
  GLAD_GL_ARB_sync: boolean;
const
  GL_MAX_SERVER_WAIT_TIMEOUT = $9111;
  GL_OBJECT_TYPE = $9112;
  GL_SYNC_CONDITION = $9113;
  GL_SYNC_STATUS = $9114;
  GL_SYNC_FLAGS = $9115;
  GL_SYNC_FENCE = $9116;
  GL_SYNC_GPU_COMMANDS_COMPLETE = $9117;
  GL_UNSIGNALED = $9118;
  GL_SIGNALED = $9119;
  GL_ALREADY_SIGNALED = $911A;
  GL_TIMEOUT_EXPIRED = $911B;
  GL_CONDITION_SATISFIED = $911C;
  GL_WAIT_FAILED = $911D;
  GL_SYNC_FLUSH_COMMANDS_BIT = $00000001;
var
  GLAD_GL_ARB_tessellation_shader: boolean;
const
  GL_PATCHES = $000E;
  GL_PATCH_VERTICES = $8E72;
  GL_PATCH_DEFAULT_INNER_LEVEL = $8E73;
  GL_PATCH_DEFAULT_OUTER_LEVEL = $8E74;
  GL_TESS_CONTROL_OUTPUT_VERTICES = $8E75;
  GL_TESS_GEN_MODE = $8E76;
  GL_TESS_GEN_SPACING = $8E77;
  GL_TESS_GEN_VERTEX_ORDER = $8E78;
  GL_TESS_GEN_POINT_MODE = $8E79;
  GL_ISOLINES = $8E7A;
  GL_FRACTIONAL_ODD = $8E7B;
  GL_FRACTIONAL_EVEN = $8E7C;
  GL_MAX_PATCH_VERTICES = $8E7D;
  GL_MAX_TESS_GEN_LEVEL = $8E7E;
  GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS = $8E7F;
  GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS = $8E80;
  GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS = $8E81;
  GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS = $8E82;
  GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS = $8E83;
  GL_MAX_TESS_PATCH_COMPONENTS = $8E84;
  GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS = $8E85;
  GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS = $8E86;
  GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS = $8E89;
  GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS = $8E8A;
  GL_MAX_TESS_CONTROL_INPUT_COMPONENTS = $886C;
  GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS = $886D;
  GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS = $8E1E;
  GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS = $8E1F;
  GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER = $84F0;
  GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER = $84F1;
  GL_TESS_EVALUATION_SHADER = $8E87;
  GL_TESS_CONTROL_SHADER = $8E88;
var
  GLAD_GL_ARB_texture_barrier: boolean;
var
  GLAD_GL_ARB_texture_border_clamp: boolean;
const
  GL_CLAMP_TO_BORDER_ARB = $812D;
var
  GLAD_GL_ARB_texture_buffer_object: boolean;
const
  GL_TEXTURE_BUFFER_ARB = $8C2A;
  GL_MAX_TEXTURE_BUFFER_SIZE_ARB = $8C2B;
  GL_TEXTURE_BINDING_BUFFER_ARB = $8C2C;
  GL_TEXTURE_BUFFER_DATA_STORE_BINDING_ARB = $8C2D;
  GL_TEXTURE_BUFFER_FORMAT_ARB = $8C2E;
var
  GLAD_GL_ARB_texture_buffer_object_rgb32: boolean;
const
  GL_RGB32F = $8815;
  GL_RGB32UI = $8D71;
  GL_RGB32I = $8D83;
var
  GLAD_GL_ARB_texture_buffer_range: boolean;
const
  GL_TEXTURE_BUFFER_OFFSET = $919D;
  GL_TEXTURE_BUFFER_SIZE = $919E;
  GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT = $919F;
var
  GLAD_GL_ARB_texture_compression: boolean;
const
  GL_COMPRESSED_ALPHA_ARB = $84E9;
  GL_COMPRESSED_LUMINANCE_ARB = $84EA;
  GL_COMPRESSED_LUMINANCE_ALPHA_ARB = $84EB;
  GL_COMPRESSED_INTENSITY_ARB = $84EC;
  GL_COMPRESSED_RGB_ARB = $84ED;
  GL_COMPRESSED_RGBA_ARB = $84EE;
  GL_TEXTURE_COMPRESSION_HINT_ARB = $84EF;
  GL_TEXTURE_COMPRESSED_IMAGE_SIZE_ARB = $86A0;
  GL_TEXTURE_COMPRESSED_ARB = $86A1;
  GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB = $86A2;
  GL_COMPRESSED_TEXTURE_FORMATS_ARB = $86A3;
var
  GLAD_GL_ARB_texture_compression_bptc: boolean;
const
  GL_COMPRESSED_RGBA_BPTC_UNORM_ARB = $8E8C;
  GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM_ARB = $8E8D;
  GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_ARB = $8E8E;
  GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_ARB = $8E8F;
var
  GLAD_GL_ARB_texture_compression_rgtc: boolean;
const
  GL_COMPRESSED_RED_RGTC1 = $8DBB;
  GL_COMPRESSED_SIGNED_RED_RGTC1 = $8DBC;
  GL_COMPRESSED_RG_RGTC2 = $8DBD;
  GL_COMPRESSED_SIGNED_RG_RGTC2 = $8DBE;
var
  GLAD_GL_ARB_texture_cube_map: boolean;
const
  GL_NORMAL_MAP_ARB = $8511;
  GL_REFLECTION_MAP_ARB = $8512;
  GL_TEXTURE_CUBE_MAP_ARB = $8513;
  GL_TEXTURE_BINDING_CUBE_MAP_ARB = $8514;
  GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB = $8515;
  GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB = $8516;
  GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB = $8517;
  GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB = $8518;
  GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB = $8519;
  GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB = $851A;
  GL_PROXY_TEXTURE_CUBE_MAP_ARB = $851B;
  GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB = $851C;
var
  GLAD_GL_ARB_texture_cube_map_array: boolean;
const
  GL_TEXTURE_CUBE_MAP_ARRAY_ARB = $9009;
  GL_TEXTURE_BINDING_CUBE_MAP_ARRAY_ARB = $900A;
  GL_PROXY_TEXTURE_CUBE_MAP_ARRAY_ARB = $900B;
  GL_SAMPLER_CUBE_MAP_ARRAY_ARB = $900C;
  GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW_ARB = $900D;
  GL_INT_SAMPLER_CUBE_MAP_ARRAY_ARB = $900E;
  GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY_ARB = $900F;
var
  GLAD_GL_ARB_texture_env_add: boolean;
var
  GLAD_GL_ARB_texture_env_combine: boolean;
const
  GL_COMBINE_ARB = $8570;
  GL_COMBINE_RGB_ARB = $8571;
  GL_COMBINE_ALPHA_ARB = $8572;
  GL_SOURCE0_RGB_ARB = $8580;
  GL_SOURCE1_RGB_ARB = $8581;
  GL_SOURCE2_RGB_ARB = $8582;
  GL_SOURCE0_ALPHA_ARB = $8588;
  GL_SOURCE1_ALPHA_ARB = $8589;
  GL_SOURCE2_ALPHA_ARB = $858A;
  GL_OPERAND0_RGB_ARB = $8590;
  GL_OPERAND1_RGB_ARB = $8591;
  GL_OPERAND2_RGB_ARB = $8592;
  GL_OPERAND0_ALPHA_ARB = $8598;
  GL_OPERAND1_ALPHA_ARB = $8599;
  GL_OPERAND2_ALPHA_ARB = $859A;
  GL_RGB_SCALE_ARB = $8573;
  GL_ADD_SIGNED_ARB = $8574;
  GL_INTERPOLATE_ARB = $8575;
  GL_SUBTRACT_ARB = $84E7;
  GL_CONSTANT_ARB = $8576;
  GL_PRIMARY_COLOR_ARB = $8577;
  GL_PREVIOUS_ARB = $8578;
var
  GLAD_GL_ARB_texture_env_crossbar: boolean;
var
  GLAD_GL_ARB_texture_env_dot3: boolean;
const
  GL_DOT3_RGB_ARB = $86AE;
  GL_DOT3_RGBA_ARB = $86AF;
var
  GLAD_GL_ARB_texture_filter_anisotropic: boolean;
const
  GL_TEXTURE_MAX_ANISOTROPY = $84FE;
  GL_MAX_TEXTURE_MAX_ANISOTROPY = $84FF;
var
  GLAD_GL_ARB_texture_filter_minmax: boolean;
const
  GL_TEXTURE_REDUCTION_MODE_ARB = $9366;
  GL_WEIGHTED_AVERAGE_ARB = $9367;
var
  GLAD_GL_ARB_texture_float: boolean;
const
  GL_TEXTURE_RED_TYPE_ARB = $8C10;
  GL_TEXTURE_GREEN_TYPE_ARB = $8C11;
  GL_TEXTURE_BLUE_TYPE_ARB = $8C12;
  GL_TEXTURE_ALPHA_TYPE_ARB = $8C13;
  GL_TEXTURE_LUMINANCE_TYPE_ARB = $8C14;
  GL_TEXTURE_INTENSITY_TYPE_ARB = $8C15;
  GL_TEXTURE_DEPTH_TYPE_ARB = $8C16;
  GL_UNSIGNED_NORMALIZED_ARB = $8C17;
  GL_RGBA32F_ARB = $8814;
  GL_RGB32F_ARB = $8815;
  GL_ALPHA32F_ARB = $8816;
  GL_INTENSITY32F_ARB = $8817;
  GL_LUMINANCE32F_ARB = $8818;
  GL_LUMINANCE_ALPHA32F_ARB = $8819;
  GL_RGBA16F_ARB = $881A;
  GL_RGB16F_ARB = $881B;
  GL_ALPHA16F_ARB = $881C;
  GL_INTENSITY16F_ARB = $881D;
  GL_LUMINANCE16F_ARB = $881E;
  GL_LUMINANCE_ALPHA16F_ARB = $881F;
var
  GLAD_GL_ARB_texture_gather: boolean;
const
  GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET_ARB = $8E5E;
  GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET_ARB = $8E5F;
  GL_MAX_PROGRAM_TEXTURE_GATHER_COMPONENTS_ARB = $8F9F;
var
  GLAD_GL_ARB_texture_mirror_clamp_to_edge: boolean;
const
  GL_MIRROR_CLAMP_TO_EDGE = $8743;
var
  GLAD_GL_ARB_texture_mirrored_repeat: boolean;
const
  GL_MIRRORED_REPEAT_ARB = $8370;
var
  GLAD_GL_ARB_texture_multisample: boolean;
const
  GL_SAMPLE_POSITION = $8E50;
  GL_SAMPLE_MASK = $8E51;
  GL_SAMPLE_MASK_VALUE = $8E52;
  GL_MAX_SAMPLE_MASK_WORDS = $8E59;
  GL_PROXY_TEXTURE_2D_MULTISAMPLE = $9101;
  GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY = $9103;
  GL_TEXTURE_SAMPLES = $9106;
  GL_TEXTURE_FIXED_SAMPLE_LOCATIONS = $9107;
  GL_SAMPLER_2D_MULTISAMPLE = $9108;
  GL_INT_SAMPLER_2D_MULTISAMPLE = $9109;
  GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE = $910A;
  GL_SAMPLER_2D_MULTISAMPLE_ARRAY = $910B;
  GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY = $910C;
  GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY = $910D;
  GL_MAX_COLOR_TEXTURE_SAMPLES = $910E;
  GL_MAX_DEPTH_TEXTURE_SAMPLES = $910F;
  GL_MAX_INTEGER_SAMPLES = $9110;
var
  GLAD_GL_ARB_texture_non_power_of_two: boolean;
var
  GLAD_GL_ARB_texture_query_levels: boolean;
var
  GLAD_GL_ARB_texture_query_lod: boolean;
var
  GLAD_GL_ARB_texture_rectangle: boolean;
const
  GL_TEXTURE_RECTANGLE_ARB = $84F5;
  GL_TEXTURE_BINDING_RECTANGLE_ARB = $84F6;
  GL_PROXY_TEXTURE_RECTANGLE_ARB = $84F7;
  GL_MAX_RECTANGLE_TEXTURE_SIZE_ARB = $84F8;
var
  GLAD_GL_ARB_texture_rg: boolean;
const
  GL_RG = $8227;
  GL_RG_INTEGER = $8228;
  GL_R8 = $8229;
  GL_R16 = $822A;
  GL_RG8 = $822B;
  GL_RG16 = $822C;
  GL_R16F = $822D;
  GL_R32F = $822E;
  GL_RG16F = $822F;
  GL_RG32F = $8230;
  GL_R8I = $8231;
  GL_R8UI = $8232;
  GL_R16I = $8233;
  GL_R16UI = $8234;
  GL_R32I = $8235;
  GL_R32UI = $8236;
  GL_RG8I = $8237;
  GL_RG16I = $8239;
  GL_RG32I = $823B;
  GL_RG32UI = $823C;
var
  GLAD_GL_ARB_texture_rgb10_a2ui: boolean;
const
  GL_RGB10_A2UI = $906F;
var
  GLAD_GL_ARB_texture_stencil8: boolean;
var
  GLAD_GL_ARB_texture_storage: boolean;
const
  GL_TEXTURE_IMMUTABLE_FORMAT = $912F;
var
  GLAD_GL_ARB_texture_storage_multisample: boolean;
var
  GLAD_GL_ARB_texture_swizzle: boolean;
const
  GL_TEXTURE_SWIZZLE_R = $8E42;
  GL_TEXTURE_SWIZZLE_G = $8E43;
  GL_TEXTURE_SWIZZLE_B = $8E44;
  GL_TEXTURE_SWIZZLE_A = $8E45;
  GL_TEXTURE_SWIZZLE_RGBA = $8E46;
var
  GLAD_GL_ARB_texture_view: boolean;
const
  GL_TEXTURE_VIEW_MIN_LEVEL = $82DB;
  GL_TEXTURE_VIEW_NUM_LEVELS = $82DC;
  GL_TEXTURE_VIEW_MIN_LAYER = $82DD;
  GL_TEXTURE_VIEW_NUM_LAYERS = $82DE;
  GL_TEXTURE_IMMUTABLE_LEVELS = $82DF;
var
  GLAD_GL_ARB_timer_query: boolean;
const
  GL_TIME_ELAPSED = $88BF;
  GL_TIMESTAMP = $8E28;
var
  GLAD_GL_ARB_transform_feedback2: boolean;
const
  GL_TRANSFORM_FEEDBACK = $8E22;
  GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED = $8E23;
  GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE = $8E24;
  GL_TRANSFORM_FEEDBACK_BINDING = $8E25;
var
  GLAD_GL_ARB_transform_feedback3: boolean;
const
  GL_MAX_TRANSFORM_FEEDBACK_BUFFERS = $8E70;
var
  GLAD_GL_ARB_transform_feedback_instanced: boolean;
var
  GLAD_GL_ARB_transform_feedback_overflow_query: boolean;
const
  GL_TRANSFORM_FEEDBACK_OVERFLOW_ARB = $82EC;
  GL_TRANSFORM_FEEDBACK_STREAM_OVERFLOW_ARB = $82ED;
var
  GLAD_GL_ARB_transpose_matrix: boolean;
const
  GL_TRANSPOSE_MODELVIEW_MATRIX_ARB = $84E3;
  GL_TRANSPOSE_PROJECTION_MATRIX_ARB = $84E4;
  GL_TRANSPOSE_TEXTURE_MATRIX_ARB = $84E5;
  GL_TRANSPOSE_COLOR_MATRIX_ARB = $84E6;
var
  GLAD_GL_ARB_uniform_buffer_object: boolean;
const
  GL_UNIFORM_BUFFER = $8A11;
  GL_UNIFORM_BUFFER_BINDING = $8A28;
  GL_UNIFORM_BUFFER_START = $8A29;
  GL_UNIFORM_BUFFER_SIZE = $8A2A;
  GL_MAX_VERTEX_UNIFORM_BLOCKS = $8A2B;
  GL_MAX_GEOMETRY_UNIFORM_BLOCKS = $8A2C;
  GL_MAX_FRAGMENT_UNIFORM_BLOCKS = $8A2D;
  GL_MAX_COMBINED_UNIFORM_BLOCKS = $8A2E;
  GL_MAX_UNIFORM_BUFFER_BINDINGS = $8A2F;
  GL_MAX_UNIFORM_BLOCK_SIZE = $8A30;
  GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS = $8A31;
  GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS = $8A32;
  GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS = $8A33;
  GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT = $8A34;
  GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH = $8A35;
  GL_ACTIVE_UNIFORM_BLOCKS = $8A36;
  GL_UNIFORM_TYPE = $8A37;
  GL_UNIFORM_BLOCK_INDEX = $8A3A;
  GL_UNIFORM_OFFSET = $8A3B;
  GL_UNIFORM_ARRAY_STRIDE = $8A3C;
  GL_UNIFORM_MATRIX_STRIDE = $8A3D;
  GL_UNIFORM_IS_ROW_MAJOR = $8A3E;
  GL_UNIFORM_BLOCK_BINDING = $8A3F;
  GL_UNIFORM_BLOCK_DATA_SIZE = $8A40;
  GL_UNIFORM_BLOCK_NAME_LENGTH = $8A41;
  GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS = $8A42;
  GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES = $8A43;
  GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER = $8A44;
  GL_UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER = $8A45;
  GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER = $8A46;
var
  GLAD_GL_ARB_vertex_array_bgra: boolean;
const
  GL_BGRA = $80E1;
var
  GLAD_GL_ARB_vertex_array_object: boolean;
const
  GL_VERTEX_ARRAY_BINDING = $85B5;
var
  GLAD_GL_ARB_vertex_attrib_64bit: boolean;
var
  GLAD_GL_ARB_vertex_attrib_binding: boolean;
const
  GL_VERTEX_ATTRIB_BINDING = $82D4;
  GL_VERTEX_ATTRIB_RELATIVE_OFFSET = $82D5;
  GL_VERTEX_BINDING_DIVISOR = $82D6;
  GL_VERTEX_BINDING_OFFSET = $82D7;
  GL_VERTEX_BINDING_STRIDE = $82D8;
  GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET = $82D9;
  GL_MAX_VERTEX_ATTRIB_BINDINGS = $82DA;
var
  GLAD_GL_ARB_vertex_blend: boolean;
const
  GL_MAX_VERTEX_UNITS_ARB = $86A4;
  GL_ACTIVE_VERTEX_UNITS_ARB = $86A5;
  GL_WEIGHT_SUM_UNITY_ARB = $86A6;
  GL_VERTEX_BLEND_ARB = $86A7;
  GL_CURRENT_WEIGHT_ARB = $86A8;
  GL_WEIGHT_ARRAY_TYPE_ARB = $86A9;
  GL_WEIGHT_ARRAY_STRIDE_ARB = $86AA;
  GL_WEIGHT_ARRAY_SIZE_ARB = $86AB;
  GL_WEIGHT_ARRAY_POINTER_ARB = $86AC;
  GL_WEIGHT_ARRAY_ARB = $86AD;
  GL_MODELVIEW0_ARB = $1700;
  GL_MODELVIEW1_ARB = $850A;
  GL_MODELVIEW2_ARB = $8722;
  GL_MODELVIEW3_ARB = $8723;
  GL_MODELVIEW4_ARB = $8724;
  GL_MODELVIEW5_ARB = $8725;
  GL_MODELVIEW6_ARB = $8726;
  GL_MODELVIEW7_ARB = $8727;
  GL_MODELVIEW8_ARB = $8728;
  GL_MODELVIEW9_ARB = $8729;
  GL_MODELVIEW10_ARB = $872A;
  GL_MODELVIEW11_ARB = $872B;
  GL_MODELVIEW12_ARB = $872C;
  GL_MODELVIEW13_ARB = $872D;
  GL_MODELVIEW14_ARB = $872E;
  GL_MODELVIEW15_ARB = $872F;
  GL_MODELVIEW16_ARB = $8730;
  GL_MODELVIEW17_ARB = $8731;
  GL_MODELVIEW18_ARB = $8732;
  GL_MODELVIEW19_ARB = $8733;
  GL_MODELVIEW20_ARB = $8734;
  GL_MODELVIEW21_ARB = $8735;
  GL_MODELVIEW22_ARB = $8736;
  GL_MODELVIEW23_ARB = $8737;
  GL_MODELVIEW24_ARB = $8738;
  GL_MODELVIEW25_ARB = $8739;
  GL_MODELVIEW26_ARB = $873A;
  GL_MODELVIEW27_ARB = $873B;
  GL_MODELVIEW28_ARB = $873C;
  GL_MODELVIEW29_ARB = $873D;
  GL_MODELVIEW30_ARB = $873E;
  GL_MODELVIEW31_ARB = $873F;
var
  GLAD_GL_ARB_vertex_buffer_object: boolean;
const
  GL_BUFFER_SIZE_ARB = $8764;
  GL_BUFFER_USAGE_ARB = $8765;
  GL_ARRAY_BUFFER_ARB = $8892;
  GL_ELEMENT_ARRAY_BUFFER_ARB = $8893;
  GL_ARRAY_BUFFER_BINDING_ARB = $8894;
  GL_ELEMENT_ARRAY_BUFFER_BINDING_ARB = $8895;
  GL_VERTEX_ARRAY_BUFFER_BINDING_ARB = $8896;
  GL_NORMAL_ARRAY_BUFFER_BINDING_ARB = $8897;
  GL_COLOR_ARRAY_BUFFER_BINDING_ARB = $8898;
  GL_INDEX_ARRAY_BUFFER_BINDING_ARB = $8899;
  GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING_ARB = $889A;
  GL_EDGE_FLAG_ARRAY_BUFFER_BINDING_ARB = $889B;
  GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING_ARB = $889C;
  GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING_ARB = $889D;
  GL_WEIGHT_ARRAY_BUFFER_BINDING_ARB = $889E;
  GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING_ARB = $889F;
  GL_READ_ONLY_ARB = $88B8;
  GL_WRITE_ONLY_ARB = $88B9;
  GL_READ_WRITE_ARB = $88BA;
  GL_BUFFER_ACCESS_ARB = $88BB;
  GL_BUFFER_MAPPED_ARB = $88BC;
  GL_BUFFER_MAP_POINTER_ARB = $88BD;
  GL_STREAM_DRAW_ARB = $88E0;
  GL_STREAM_READ_ARB = $88E1;
  GL_STREAM_COPY_ARB = $88E2;
  GL_STATIC_DRAW_ARB = $88E4;
  GL_STATIC_READ_ARB = $88E5;
  GL_STATIC_COPY_ARB = $88E6;
  GL_DYNAMIC_DRAW_ARB = $88E8;
  GL_DYNAMIC_READ_ARB = $88E9;
  GL_DYNAMIC_COPY_ARB = $88EA;
var
  GLAD_GL_ARB_vertex_program: boolean;
const
  GL_COLOR_SUM_ARB = $8458;
  GL_VERTEX_PROGRAM_ARB = $8620;
  GL_VERTEX_ATTRIB_ARRAY_ENABLED_ARB = $8622;
  GL_VERTEX_ATTRIB_ARRAY_SIZE_ARB = $8623;
  GL_VERTEX_ATTRIB_ARRAY_STRIDE_ARB = $8624;
  GL_VERTEX_ATTRIB_ARRAY_TYPE_ARB = $8625;
  GL_CURRENT_VERTEX_ATTRIB_ARB = $8626;
  GL_VERTEX_PROGRAM_POINT_SIZE_ARB = $8642;
  GL_VERTEX_PROGRAM_TWO_SIDE_ARB = $8643;
  GL_VERTEX_ATTRIB_ARRAY_POINTER_ARB = $8645;
  GL_MAX_VERTEX_ATTRIBS_ARB = $8869;
  GL_VERTEX_ATTRIB_ARRAY_NORMALIZED_ARB = $886A;
  GL_PROGRAM_ADDRESS_REGISTERS_ARB = $88B0;
  GL_MAX_PROGRAM_ADDRESS_REGISTERS_ARB = $88B1;
  GL_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB = $88B2;
  GL_MAX_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB = $88B3;
var
  GLAD_GL_ARB_vertex_shader: boolean;
const
  GL_VERTEX_SHADER_ARB = $8B31;
  GL_MAX_VERTEX_UNIFORM_COMPONENTS_ARB = $8B4A;
  GL_MAX_VARYING_FLOATS_ARB = $8B4B;
  GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB = $8B4C;
  GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS_ARB = $8B4D;
  GL_OBJECT_ACTIVE_ATTRIBUTES_ARB = $8B89;
  GL_OBJECT_ACTIVE_ATTRIBUTE_MAX_LENGTH_ARB = $8B8A;
var
  GLAD_GL_ARB_vertex_type_10f_11f_11f_rev: boolean;
const
  GL_UNSIGNED_INT_10F_11F_11F_REV = $8C3B;
var
  GLAD_GL_ARB_vertex_type_2_10_10_10_rev: boolean;
const
  GL_UNSIGNED_INT_2_10_10_10_REV = $8368;
  GL_INT_2_10_10_10_REV = $8D9F;
var
  GLAD_GL_ARB_viewport_array: boolean;
const
  GL_MAX_VIEWPORTS = $825B;
  GL_VIEWPORT_SUBPIXEL_BITS = $825C;
  GL_VIEWPORT_BOUNDS_RANGE = $825D;
  GL_LAYER_PROVOKING_VERTEX = $825E;
  GL_VIEWPORT_INDEX_PROVOKING_VERTEX = $825F;
  GL_UNDEFINED_VERTEX = $8260;
var
  GLAD_GL_ARB_window_pos: boolean;
var
  GLAD_GL_ATI_draw_buffers: boolean;
const
  GL_MAX_DRAW_BUFFERS_ATI = $8824;
  GL_DRAW_BUFFER0_ATI = $8825;
  GL_DRAW_BUFFER1_ATI = $8826;
  GL_DRAW_BUFFER2_ATI = $8827;
  GL_DRAW_BUFFER3_ATI = $8828;
  GL_DRAW_BUFFER4_ATI = $8829;
  GL_DRAW_BUFFER5_ATI = $882A;
  GL_DRAW_BUFFER6_ATI = $882B;
  GL_DRAW_BUFFER7_ATI = $882C;
  GL_DRAW_BUFFER8_ATI = $882D;
  GL_DRAW_BUFFER9_ATI = $882E;
  GL_DRAW_BUFFER10_ATI = $882F;
  GL_DRAW_BUFFER11_ATI = $8830;
  GL_DRAW_BUFFER12_ATI = $8831;
  GL_DRAW_BUFFER13_ATI = $8832;
  GL_DRAW_BUFFER14_ATI = $8833;
  GL_DRAW_BUFFER15_ATI = $8834;
var
  GLAD_GL_ATI_element_array: boolean;
const
  GL_ELEMENT_ARRAY_ATI = $8768;
  GL_ELEMENT_ARRAY_TYPE_ATI = $8769;
  GL_ELEMENT_ARRAY_POINTER_ATI = $876A;
var
  GLAD_GL_ATI_envmap_bumpmap: boolean;
const
  GL_BUMP_ROT_MATRIX_ATI = $8775;
  GL_BUMP_ROT_MATRIX_SIZE_ATI = $8776;
  GL_BUMP_NUM_TEX_UNITS_ATI = $8777;
  GL_BUMP_TEX_UNITS_ATI = $8778;
  GL_DUDV_ATI = $8779;
  GL_DU8DV8_ATI = $877A;
  GL_BUMP_ENVMAP_ATI = $877B;
  GL_BUMP_TARGET_ATI = $877C;
var
  GLAD_GL_ATI_fragment_shader: boolean;
const
  GL_FRAGMENT_SHADER_ATI = $8920;
  GL_REG_0_ATI = $8921;
  GL_REG_1_ATI = $8922;
  GL_REG_2_ATI = $8923;
  GL_REG_3_ATI = $8924;
  GL_REG_4_ATI = $8925;
  GL_REG_5_ATI = $8926;
  GL_REG_6_ATI = $8927;
  GL_REG_7_ATI = $8928;
  GL_REG_8_ATI = $8929;
  GL_REG_9_ATI = $892A;
  GL_REG_10_ATI = $892B;
  GL_REG_11_ATI = $892C;
  GL_REG_12_ATI = $892D;
  GL_REG_13_ATI = $892E;
  GL_REG_14_ATI = $892F;
  GL_REG_15_ATI = $8930;
  GL_REG_16_ATI = $8931;
  GL_REG_17_ATI = $8932;
  GL_REG_18_ATI = $8933;
  GL_REG_19_ATI = $8934;
  GL_REG_20_ATI = $8935;
  GL_REG_21_ATI = $8936;
  GL_REG_22_ATI = $8937;
  GL_REG_23_ATI = $8938;
  GL_REG_24_ATI = $8939;
  GL_REG_25_ATI = $893A;
  GL_REG_26_ATI = $893B;
  GL_REG_27_ATI = $893C;
  GL_REG_28_ATI = $893D;
  GL_REG_29_ATI = $893E;
  GL_REG_30_ATI = $893F;
  GL_REG_31_ATI = $8940;
  GL_CON_0_ATI = $8941;
  GL_CON_1_ATI = $8942;
  GL_CON_2_ATI = $8943;
  GL_CON_3_ATI = $8944;
  GL_CON_4_ATI = $8945;
  GL_CON_5_ATI = $8946;
  GL_CON_6_ATI = $8947;
  GL_CON_7_ATI = $8948;
  GL_CON_8_ATI = $8949;
  GL_CON_9_ATI = $894A;
  GL_CON_10_ATI = $894B;
  GL_CON_11_ATI = $894C;
  GL_CON_12_ATI = $894D;
  GL_CON_13_ATI = $894E;
  GL_CON_14_ATI = $894F;
  GL_CON_15_ATI = $8950;
  GL_CON_16_ATI = $8951;
  GL_CON_17_ATI = $8952;
  GL_CON_18_ATI = $8953;
  GL_CON_19_ATI = $8954;
  GL_CON_20_ATI = $8955;
  GL_CON_21_ATI = $8956;
  GL_CON_22_ATI = $8957;
  GL_CON_23_ATI = $8958;
  GL_CON_24_ATI = $8959;
  GL_CON_25_ATI = $895A;
  GL_CON_26_ATI = $895B;
  GL_CON_27_ATI = $895C;
  GL_CON_28_ATI = $895D;
  GL_CON_29_ATI = $895E;
  GL_CON_30_ATI = $895F;
  GL_CON_31_ATI = $8960;
  GL_MOV_ATI = $8961;
  GL_ADD_ATI = $8963;
  GL_MUL_ATI = $8964;
  GL_SUB_ATI = $8965;
  GL_DOT3_ATI = $8966;
  GL_DOT4_ATI = $8967;
  GL_MAD_ATI = $8968;
  GL_LERP_ATI = $8969;
  GL_CND_ATI = $896A;
  GL_CND0_ATI = $896B;
  GL_DOT2_ADD_ATI = $896C;
  GL_SECONDARY_INTERPOLATOR_ATI = $896D;
  GL_NUM_FRAGMENT_REGISTERS_ATI = $896E;
  GL_NUM_FRAGMENT_CONSTANTS_ATI = $896F;
  GL_NUM_PASSES_ATI = $8970;
  GL_NUM_INSTRUCTIONS_PER_PASS_ATI = $8971;
  GL_NUM_INSTRUCTIONS_TOTAL_ATI = $8972;
  GL_NUM_INPUT_INTERPOLATOR_COMPONENTS_ATI = $8973;
  GL_NUM_LOOPBACK_COMPONENTS_ATI = $8974;
  GL_COLOR_ALPHA_PAIRING_ATI = $8975;
  GL_SWIZZLE_STR_ATI = $8976;
  GL_SWIZZLE_STQ_ATI = $8977;
  GL_SWIZZLE_STR_DR_ATI = $8978;
  GL_SWIZZLE_STQ_DQ_ATI = $8979;
  GL_SWIZZLE_STRQ_ATI = $897A;
  GL_SWIZZLE_STRQ_DQ_ATI = $897B;
  GL_RED_BIT_ATI = $00000001;
  GL_GREEN_BIT_ATI = $00000002;
  GL_BLUE_BIT_ATI = $00000004;
  GL_2X_BIT_ATI = $00000001;
  GL_4X_BIT_ATI = $00000002;
  GL_8X_BIT_ATI = $00000004;
  GL_HALF_BIT_ATI = $00000008;
  GL_QUARTER_BIT_ATI = $00000010;
  GL_EIGHTH_BIT_ATI = $00000020;
  GL_SATURATE_BIT_ATI = $00000040;
  GL_COMP_BIT_ATI = $00000002;
  GL_NEGATE_BIT_ATI = $00000004;
  GL_BIAS_BIT_ATI = $00000008;
var
  GLAD_GL_ATI_map_object_buffer: boolean;
var
  GLAD_GL_ATI_meminfo: boolean;
const
  GL_VBO_FREE_MEMORY_ATI = $87FB;
  GL_TEXTURE_FREE_MEMORY_ATI = $87FC;
  GL_RENDERBUFFER_FREE_MEMORY_ATI = $87FD;
var
  GLAD_GL_ATI_pixel_format_float: boolean;
const
  GL_RGBA_FLOAT_MODE_ATI = $8820;
  GL_COLOR_CLEAR_UNCLAMPED_VALUE_ATI = $8835;
var
  GLAD_GL_ATI_pn_triangles: boolean;
const
  GL_PN_TRIANGLES_ATI = $87F0;
  GL_MAX_PN_TRIANGLES_TESSELATION_LEVEL_ATI = $87F1;
  GL_PN_TRIANGLES_POINT_MODE_ATI = $87F2;
  GL_PN_TRIANGLES_NORMAL_MODE_ATI = $87F3;
  GL_PN_TRIANGLES_TESSELATION_LEVEL_ATI = $87F4;
  GL_PN_TRIANGLES_POINT_MODE_LINEAR_ATI = $87F5;
  GL_PN_TRIANGLES_POINT_MODE_CUBIC_ATI = $87F6;
  GL_PN_TRIANGLES_NORMAL_MODE_LINEAR_ATI = $87F7;
  GL_PN_TRIANGLES_NORMAL_MODE_QUADRATIC_ATI = $87F8;
var
  GLAD_GL_ATI_separate_stencil: boolean;
const
  GL_STENCIL_BACK_FUNC_ATI = $8800;
  GL_STENCIL_BACK_FAIL_ATI = $8801;
  GL_STENCIL_BACK_PASS_DEPTH_FAIL_ATI = $8802;
  GL_STENCIL_BACK_PASS_DEPTH_PASS_ATI = $8803;
var
  GLAD_GL_ATI_text_fragment_shader: boolean;
const
  GL_TEXT_FRAGMENT_SHADER_ATI = $8200;
var
  GLAD_GL_ATI_texture_env_combine3: boolean;
const
  GL_MODULATE_ADD_ATI = $8744;
  GL_MODULATE_SIGNED_ADD_ATI = $8745;
  GL_MODULATE_SUBTRACT_ATI = $8746;
var
  GLAD_GL_ATI_texture_float: boolean;
const
  GL_RGBA_FLOAT32_ATI = $8814;
  GL_RGB_FLOAT32_ATI = $8815;
  GL_ALPHA_FLOAT32_ATI = $8816;
  GL_INTENSITY_FLOAT32_ATI = $8817;
  GL_LUMINANCE_FLOAT32_ATI = $8818;
  GL_LUMINANCE_ALPHA_FLOAT32_ATI = $8819;
  GL_RGBA_FLOAT16_ATI = $881A;
  GL_RGB_FLOAT16_ATI = $881B;
  GL_ALPHA_FLOAT16_ATI = $881C;
  GL_INTENSITY_FLOAT16_ATI = $881D;
  GL_LUMINANCE_FLOAT16_ATI = $881E;
  GL_LUMINANCE_ALPHA_FLOAT16_ATI = $881F;
var
  GLAD_GL_ATI_texture_mirror_once: boolean;
const
  GL_MIRROR_CLAMP_ATI = $8742;
  GL_MIRROR_CLAMP_TO_EDGE_ATI = $8743;
var
  GLAD_GL_ATI_vertex_array_object: boolean;
const
  GL_STATIC_ATI = $8760;
  GL_DYNAMIC_ATI = $8761;
  GL_PRESERVE_ATI = $8762;
  GL_DISCARD_ATI = $8763;
  GL_OBJECT_BUFFER_SIZE_ATI = $8764;
  GL_OBJECT_BUFFER_USAGE_ATI = $8765;
  GL_ARRAY_OBJECT_BUFFER_ATI = $8766;
  GL_ARRAY_OBJECT_OFFSET_ATI = $8767;
var
  GLAD_GL_ATI_vertex_attrib_array_object: boolean;
var
  GLAD_GL_ATI_vertex_streams: boolean;
const
  GL_MAX_VERTEX_STREAMS_ATI = $876B;
  GL_VERTEX_STREAM0_ATI = $876C;
  GL_VERTEX_STREAM1_ATI = $876D;
  GL_VERTEX_STREAM2_ATI = $876E;
  GL_VERTEX_STREAM3_ATI = $876F;
  GL_VERTEX_STREAM4_ATI = $8770;
  GL_VERTEX_STREAM5_ATI = $8771;
  GL_VERTEX_STREAM6_ATI = $8772;
  GL_VERTEX_STREAM7_ATI = $8773;
  GL_VERTEX_SOURCE_ATI = $8774;
var
  GLAD_GL_EXT_422_pixels: boolean;
const
  GL_422_EXT = $80CC;
  GL_422_REV_EXT = $80CD;
  GL_422_AVERAGE_EXT = $80CE;
  GL_422_REV_AVERAGE_EXT = $80CF;
var
  GLAD_GL_EXT_EGL_image_storage: boolean;
var
  GLAD_GL_EXT_EGL_sync: boolean;
var
  GLAD_GL_EXT_abgr: boolean;
const
  GL_ABGR_EXT = $8000;
var
  GLAD_GL_EXT_bgra: boolean;
const
  GL_BGR_EXT = $80E0;
  GL_BGRA_EXT = $80E1;
var
  GLAD_GL_EXT_bindable_uniform: boolean;
const
  GL_MAX_VERTEX_BINDABLE_UNIFORMS_EXT = $8DE2;
  GL_MAX_FRAGMENT_BINDABLE_UNIFORMS_EXT = $8DE3;
  GL_MAX_GEOMETRY_BINDABLE_UNIFORMS_EXT = $8DE4;
  GL_MAX_BINDABLE_UNIFORM_SIZE_EXT = $8DED;
  GL_UNIFORM_BUFFER_EXT = $8DEE;
  GL_UNIFORM_BUFFER_BINDING_EXT = $8DEF;
var
  GLAD_GL_EXT_blend_color: boolean;
const
  GL_CONSTANT_COLOR_EXT = $8001;
  GL_ONE_MINUS_CONSTANT_COLOR_EXT = $8002;
  GL_CONSTANT_ALPHA_EXT = $8003;
  GL_ONE_MINUS_CONSTANT_ALPHA_EXT = $8004;
  GL_BLEND_COLOR_EXT = $8005;
var
  GLAD_GL_EXT_blend_equation_separate: boolean;
const
  GL_BLEND_EQUATION_RGB_EXT = $8009;
  GL_BLEND_EQUATION_ALPHA_EXT = $883D;
var
  GLAD_GL_EXT_blend_func_separate: boolean;
const
  GL_BLEND_DST_RGB_EXT = $80C8;
  GL_BLEND_SRC_RGB_EXT = $80C9;
  GL_BLEND_DST_ALPHA_EXT = $80CA;
  GL_BLEND_SRC_ALPHA_EXT = $80CB;
var
  GLAD_GL_EXT_blend_logic_op: boolean;
var
  GLAD_GL_EXT_blend_minmax: boolean;
const
  GL_MIN_EXT = $8007;
  GL_MAX_EXT = $8008;
  GL_FUNC_ADD_EXT = $8006;
  GL_BLEND_EQUATION_EXT = $8009;
var
  GLAD_GL_EXT_blend_subtract: boolean;
const
  GL_FUNC_SUBTRACT_EXT = $800A;
  GL_FUNC_REVERSE_SUBTRACT_EXT = $800B;
var
  GLAD_GL_EXT_clip_volume_hint: boolean;
const
  GL_CLIP_VOLUME_CLIPPING_HINT_EXT = $80F0;
var
  GLAD_GL_EXT_cmyka: boolean;
const
  GL_CMYK_EXT = $800C;
  GL_CMYKA_EXT = $800D;
  GL_PACK_CMYK_HINT_EXT = $800E;
  GL_UNPACK_CMYK_HINT_EXT = $800F;
var
  GLAD_GL_EXT_color_subtable: boolean;
var
  GLAD_GL_EXT_compiled_vertex_array: boolean;
const
  GL_ARRAY_ELEMENT_LOCK_FIRST_EXT = $81A8;
  GL_ARRAY_ELEMENT_LOCK_COUNT_EXT = $81A9;
var
  GLAD_GL_EXT_convolution: boolean;
const
  GL_CONVOLUTION_1D_EXT = $8010;
  GL_CONVOLUTION_2D_EXT = $8011;
  GL_SEPARABLE_2D_EXT = $8012;
  GL_CONVOLUTION_BORDER_MODE_EXT = $8013;
  GL_CONVOLUTION_FILTER_SCALE_EXT = $8014;
  GL_CONVOLUTION_FILTER_BIAS_EXT = $8015;
  GL_REDUCE_EXT = $8016;
  GL_CONVOLUTION_FORMAT_EXT = $8017;
  GL_CONVOLUTION_WIDTH_EXT = $8018;
  GL_CONVOLUTION_HEIGHT_EXT = $8019;
  GL_MAX_CONVOLUTION_WIDTH_EXT = $801A;
  GL_MAX_CONVOLUTION_HEIGHT_EXT = $801B;
  GL_POST_CONVOLUTION_RED_SCALE_EXT = $801C;
  GL_POST_CONVOLUTION_GREEN_SCALE_EXT = $801D;
  GL_POST_CONVOLUTION_BLUE_SCALE_EXT = $801E;
  GL_POST_CONVOLUTION_ALPHA_SCALE_EXT = $801F;
  GL_POST_CONVOLUTION_RED_BIAS_EXT = $8020;
  GL_POST_CONVOLUTION_GREEN_BIAS_EXT = $8021;
  GL_POST_CONVOLUTION_BLUE_BIAS_EXT = $8022;
  GL_POST_CONVOLUTION_ALPHA_BIAS_EXT = $8023;
var
  GLAD_GL_EXT_coordinate_frame: boolean;
const
  GL_TANGENT_ARRAY_EXT = $8439;
  GL_BINORMAL_ARRAY_EXT = $843A;
  GL_CURRENT_TANGENT_EXT = $843B;
  GL_CURRENT_BINORMAL_EXT = $843C;
  GL_TANGENT_ARRAY_TYPE_EXT = $843E;
  GL_TANGENT_ARRAY_STRIDE_EXT = $843F;
  GL_BINORMAL_ARRAY_TYPE_EXT = $8440;
  GL_BINORMAL_ARRAY_STRIDE_EXT = $8441;
  GL_TANGENT_ARRAY_POINTER_EXT = $8442;
  GL_BINORMAL_ARRAY_POINTER_EXT = $8443;
  GL_MAP1_TANGENT_EXT = $8444;
  GL_MAP2_TANGENT_EXT = $8445;
  GL_MAP1_BINORMAL_EXT = $8446;
  GL_MAP2_BINORMAL_EXT = $8447;
var
  GLAD_GL_EXT_copy_texture: boolean;
var
  GLAD_GL_EXT_cull_vertex: boolean;
const
  GL_CULL_VERTEX_EXT = $81AA;
  GL_CULL_VERTEX_EYE_POSITION_EXT = $81AB;
  GL_CULL_VERTEX_OBJECT_POSITION_EXT = $81AC;
var
  GLAD_GL_EXT_debug_label: boolean;
const
  GL_PROGRAM_PIPELINE_OBJECT_EXT = $8A4F;
  GL_PROGRAM_OBJECT_EXT = $8B40;
  GL_SHADER_OBJECT_EXT = $8B48;
  GL_BUFFER_OBJECT_EXT = $9151;
  GL_QUERY_OBJECT_EXT = $9153;
  GL_VERTEX_ARRAY_OBJECT_EXT = $9154;
  GL_SAMPLER = $82E6;
var
  GLAD_GL_EXT_debug_marker: boolean;
var
  GLAD_GL_EXT_depth_bounds_test: boolean;
const
  GL_DEPTH_BOUNDS_TEST_EXT = $8890;
  GL_DEPTH_BOUNDS_EXT = $8891;
var
  GLAD_GL_EXT_direct_state_access: boolean;
const
  GL_PROGRAM_MATRIX_EXT = $8E2D;
  GL_TRANSPOSE_PROGRAM_MATRIX_EXT = $8E2E;
  GL_PROGRAM_MATRIX_STACK_DEPTH_EXT = $8E2F;
var
  GLAD_GL_EXT_draw_buffers2: boolean;
var
  GLAD_GL_EXT_draw_instanced: boolean;
var
  GLAD_GL_EXT_draw_range_elements: boolean;
const
  GL_MAX_ELEMENTS_VERTICES_EXT = $80E8;
  GL_MAX_ELEMENTS_INDICES_EXT = $80E9;
var
  GLAD_GL_EXT_external_buffer: boolean;
var
  GLAD_GL_EXT_fog_coord: boolean;
const
  GL_FOG_COORDINATE_SOURCE_EXT = $8450;
  GL_FOG_COORDINATE_EXT = $8451;
  GL_FRAGMENT_DEPTH_EXT = $8452;
  GL_CURRENT_FOG_COORDINATE_EXT = $8453;
  GL_FOG_COORDINATE_ARRAY_TYPE_EXT = $8454;
  GL_FOG_COORDINATE_ARRAY_STRIDE_EXT = $8455;
  GL_FOG_COORDINATE_ARRAY_POINTER_EXT = $8456;
  GL_FOG_COORDINATE_ARRAY_EXT = $8457;
var
  GLAD_GL_EXT_framebuffer_blit: boolean;
const
  GL_READ_FRAMEBUFFER_EXT = $8CA8;
  GL_DRAW_FRAMEBUFFER_EXT = $8CA9;
  GL_DRAW_FRAMEBUFFER_BINDING_EXT = $8CA6;
  GL_READ_FRAMEBUFFER_BINDING_EXT = $8CAA;
var
  GLAD_GL_EXT_framebuffer_blit_layers: boolean;
var
  GLAD_GL_EXT_framebuffer_multisample: boolean;
const
  GL_RENDERBUFFER_SAMPLES_EXT = $8CAB;
  GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_EXT = $8D56;
  GL_MAX_SAMPLES_EXT = $8D57;
var
  GLAD_GL_EXT_framebuffer_multisample_blit_scaled: boolean;
const
  GL_SCALED_RESOLVE_FASTEST_EXT = $90BA;
  GL_SCALED_RESOLVE_NICEST_EXT = $90BB;
var
  GLAD_GL_EXT_framebuffer_object: boolean;
const
  GL_INVALID_FRAMEBUFFER_OPERATION_EXT = $0506;
  GL_MAX_RENDERBUFFER_SIZE_EXT = $84E8;
  GL_FRAMEBUFFER_BINDING_EXT = $8CA6;
  GL_RENDERBUFFER_BINDING_EXT = $8CA7;
  GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_EXT = $8CD0;
  GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_EXT = $8CD1;
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL_EXT = $8CD2;
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE_EXT = $8CD3;
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_EXT = $8CD4;
  GL_FRAMEBUFFER_COMPLETE_EXT = $8CD5;
  GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_EXT = $8CD6;
  GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_EXT = $8CD7;
  GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT = $8CD9;
  GL_FRAMEBUFFER_INCOMPLETE_FORMATS_EXT = $8CDA;
  GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_EXT = $8CDB;
  GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER_EXT = $8CDC;
  GL_FRAMEBUFFER_UNSUPPORTED_EXT = $8CDD;
  GL_MAX_COLOR_ATTACHMENTS_EXT = $8CDF;
  GL_COLOR_ATTACHMENT0_EXT = $8CE0;
  GL_COLOR_ATTACHMENT1_EXT = $8CE1;
  GL_COLOR_ATTACHMENT2_EXT = $8CE2;
  GL_COLOR_ATTACHMENT3_EXT = $8CE3;
  GL_COLOR_ATTACHMENT4_EXT = $8CE4;
  GL_COLOR_ATTACHMENT5_EXT = $8CE5;
  GL_COLOR_ATTACHMENT6_EXT = $8CE6;
  GL_COLOR_ATTACHMENT7_EXT = $8CE7;
  GL_COLOR_ATTACHMENT8_EXT = $8CE8;
  GL_COLOR_ATTACHMENT9_EXT = $8CE9;
  GL_COLOR_ATTACHMENT10_EXT = $8CEA;
  GL_COLOR_ATTACHMENT11_EXT = $8CEB;
  GL_COLOR_ATTACHMENT12_EXT = $8CEC;
  GL_COLOR_ATTACHMENT13_EXT = $8CED;
  GL_COLOR_ATTACHMENT14_EXT = $8CEE;
  GL_COLOR_ATTACHMENT15_EXT = $8CEF;
  GL_DEPTH_ATTACHMENT_EXT = $8D00;
  GL_STENCIL_ATTACHMENT_EXT = $8D20;
  GL_FRAMEBUFFER_EXT = $8D40;
  GL_RENDERBUFFER_EXT = $8D41;
  GL_RENDERBUFFER_WIDTH_EXT = $8D42;
  GL_RENDERBUFFER_HEIGHT_EXT = $8D43;
  GL_RENDERBUFFER_INTERNAL_FORMAT_EXT = $8D44;
  GL_STENCIL_INDEX1_EXT = $8D46;
  GL_STENCIL_INDEX4_EXT = $8D47;
  GL_STENCIL_INDEX8_EXT = $8D48;
  GL_STENCIL_INDEX16_EXT = $8D49;
  GL_RENDERBUFFER_RED_SIZE_EXT = $8D50;
  GL_RENDERBUFFER_GREEN_SIZE_EXT = $8D51;
  GL_RENDERBUFFER_BLUE_SIZE_EXT = $8D52;
  GL_RENDERBUFFER_ALPHA_SIZE_EXT = $8D53;
  GL_RENDERBUFFER_DEPTH_SIZE_EXT = $8D54;
  GL_RENDERBUFFER_STENCIL_SIZE_EXT = $8D55;
var
  GLAD_GL_EXT_framebuffer_sRGB: boolean;
const
  GL_FRAMEBUFFER_SRGB_EXT = $8DB9;
  GL_FRAMEBUFFER_SRGB_CAPABLE_EXT = $8DBA;
var
  GLAD_GL_EXT_geometry_shader4: boolean;
const
  GL_GEOMETRY_SHADER_EXT = $8DD9;
  GL_GEOMETRY_VERTICES_OUT_EXT = $8DDA;
  GL_GEOMETRY_INPUT_TYPE_EXT = $8DDB;
  GL_GEOMETRY_OUTPUT_TYPE_EXT = $8DDC;
  GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_EXT = $8C29;
  GL_MAX_GEOMETRY_VARYING_COMPONENTS_EXT = $8DDD;
  GL_MAX_VERTEX_VARYING_COMPONENTS_EXT = $8DDE;
  GL_MAX_VARYING_COMPONENTS_EXT = $8B4B;
  GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_EXT = $8DDF;
  GL_MAX_GEOMETRY_OUTPUT_VERTICES_EXT = $8DE0;
  GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_EXT = $8DE1;
  GL_LINES_ADJACENCY_EXT = $000A;
  GL_LINE_STRIP_ADJACENCY_EXT = $000B;
  GL_TRIANGLES_ADJACENCY_EXT = $000C;
  GL_TRIANGLE_STRIP_ADJACENCY_EXT = $000D;
  GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_EXT = $8DA8;
  GL_FRAMEBUFFER_INCOMPLETE_LAYER_COUNT_EXT = $8DA9;
  GL_FRAMEBUFFER_ATTACHMENT_LAYERED_EXT = $8DA7;
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER_EXT = $8CD4;
  GL_PROGRAM_POINT_SIZE_EXT = $8642;
var
  GLAD_GL_EXT_gpu_program_parameters: boolean;
var
  GLAD_GL_EXT_gpu_shader4: boolean;
const
  GL_SAMPLER_1D_ARRAY_EXT = $8DC0;
  GL_SAMPLER_2D_ARRAY_EXT = $8DC1;
  GL_SAMPLER_BUFFER_EXT = $8DC2;
  GL_SAMPLER_1D_ARRAY_SHADOW_EXT = $8DC3;
  GL_SAMPLER_2D_ARRAY_SHADOW_EXT = $8DC4;
  GL_SAMPLER_CUBE_SHADOW_EXT = $8DC5;
  GL_UNSIGNED_INT_VEC2_EXT = $8DC6;
  GL_UNSIGNED_INT_VEC3_EXT = $8DC7;
  GL_UNSIGNED_INT_VEC4_EXT = $8DC8;
  GL_INT_SAMPLER_1D_EXT = $8DC9;
  GL_INT_SAMPLER_2D_EXT = $8DCA;
  GL_INT_SAMPLER_3D_EXT = $8DCB;
  GL_INT_SAMPLER_CUBE_EXT = $8DCC;
  GL_INT_SAMPLER_2D_RECT_EXT = $8DCD;
  GL_INT_SAMPLER_1D_ARRAY_EXT = $8DCE;
  GL_INT_SAMPLER_2D_ARRAY_EXT = $8DCF;
  GL_INT_SAMPLER_BUFFER_EXT = $8DD0;
  GL_UNSIGNED_INT_SAMPLER_1D_EXT = $8DD1;
  GL_UNSIGNED_INT_SAMPLER_2D_EXT = $8DD2;
  GL_UNSIGNED_INT_SAMPLER_3D_EXT = $8DD3;
  GL_UNSIGNED_INT_SAMPLER_CUBE_EXT = $8DD4;
  GL_UNSIGNED_INT_SAMPLER_2D_RECT_EXT = $8DD5;
  GL_UNSIGNED_INT_SAMPLER_1D_ARRAY_EXT = $8DD6;
  GL_UNSIGNED_INT_SAMPLER_2D_ARRAY_EXT = $8DD7;
  GL_UNSIGNED_INT_SAMPLER_BUFFER_EXT = $8DD8;
  GL_MIN_PROGRAM_TEXEL_OFFSET_EXT = $8904;
  GL_MAX_PROGRAM_TEXEL_OFFSET_EXT = $8905;
  GL_VERTEX_ATTRIB_ARRAY_INTEGER_EXT = $88FD;
var
  GLAD_GL_EXT_histogram: boolean;
const
  GL_HISTOGRAM_EXT = $8024;
  GL_PROXY_HISTOGRAM_EXT = $8025;
  GL_HISTOGRAM_WIDTH_EXT = $8026;
  GL_HISTOGRAM_FORMAT_EXT = $8027;
  GL_HISTOGRAM_RED_SIZE_EXT = $8028;
  GL_HISTOGRAM_GREEN_SIZE_EXT = $8029;
  GL_HISTOGRAM_BLUE_SIZE_EXT = $802A;
  GL_HISTOGRAM_ALPHA_SIZE_EXT = $802B;
  GL_HISTOGRAM_LUMINANCE_SIZE_EXT = $802C;
  GL_HISTOGRAM_SINK_EXT = $802D;
  GL_MINMAX_EXT = $802E;
  GL_MINMAX_FORMAT_EXT = $802F;
  GL_MINMAX_SINK_EXT = $8030;
  GL_TABLE_TOO_LARGE_EXT = $8031;
var
  GLAD_GL_EXT_index_array_formats: boolean;
const
  GL_IUI_V2F_EXT = $81AD;
  GL_IUI_V3F_EXT = $81AE;
  GL_IUI_N3F_V2F_EXT = $81AF;
  GL_IUI_N3F_V3F_EXT = $81B0;
  GL_T2F_IUI_V2F_EXT = $81B1;
  GL_T2F_IUI_V3F_EXT = $81B2;
  GL_T2F_IUI_N3F_V2F_EXT = $81B3;
  GL_T2F_IUI_N3F_V3F_EXT = $81B4;
var
  GLAD_GL_EXT_index_func: boolean;
const
  GL_INDEX_TEST_EXT = $81B5;
  GL_INDEX_TEST_FUNC_EXT = $81B6;
  GL_INDEX_TEST_REF_EXT = $81B7;
var
  GLAD_GL_EXT_index_material: boolean;
const
  GL_INDEX_MATERIAL_EXT = $81B8;
  GL_INDEX_MATERIAL_PARAMETER_EXT = $81B9;
  GL_INDEX_MATERIAL_FACE_EXT = $81BA;
var
  GLAD_GL_EXT_index_texture: boolean;
var
  GLAD_GL_EXT_light_texture: boolean;
const
  GL_FRAGMENT_MATERIAL_EXT = $8349;
  GL_FRAGMENT_NORMAL_EXT = $834A;
  GL_FRAGMENT_COLOR_EXT = $834C;
  GL_ATTENUATION_EXT = $834D;
  GL_SHADOW_ATTENUATION_EXT = $834E;
  GL_TEXTURE_APPLICATION_MODE_EXT = $834F;
  GL_TEXTURE_LIGHT_EXT = $8350;
  GL_TEXTURE_MATERIAL_FACE_EXT = $8351;
  GL_TEXTURE_MATERIAL_PARAMETER_EXT = $8352;
var
  GLAD_GL_EXT_memory_object: boolean;
const
  GL_TEXTURE_TILING_EXT = $9580;
  GL_DEDICATED_MEMORY_OBJECT_EXT = $9581;
  GL_PROTECTED_MEMORY_OBJECT_EXT = $959B;
  GL_NUM_TILING_TYPES_EXT = $9582;
  GL_TILING_TYPES_EXT = $9583;
  GL_OPTIMAL_TILING_EXT = $9584;
  GL_LINEAR_TILING_EXT = $9585;
  GL_NUM_DEVICE_UUIDS_EXT = $9596;
  GL_DEVICE_UUID_EXT = $9597;
  GL_DRIVER_UUID_EXT = $9598;
var
  GLAD_GL_EXT_memory_object_fd: boolean;
const
  GL_HANDLE_TYPE_OPAQUE_FD_EXT = $9586;
var
  GLAD_GL_EXT_memory_object_win32: boolean;
const
  GL_HANDLE_TYPE_OPAQUE_WIN32_EXT = $9587;
  GL_HANDLE_TYPE_OPAQUE_WIN32_KMT_EXT = $9588;
  GL_DEVICE_LUID_EXT = $9599;
  GL_DEVICE_NODE_MASK_EXT = $959A;
  GL_HANDLE_TYPE_D3D12_TILEPOOL_EXT = $9589;
  GL_HANDLE_TYPE_D3D12_RESOURCE_EXT = $958A;
  GL_HANDLE_TYPE_D3D11_IMAGE_EXT = $958B;
  GL_HANDLE_TYPE_D3D11_IMAGE_KMT_EXT = $958C;
var
  GLAD_GL_EXT_misc_attribute: boolean;
var
  GLAD_GL_EXT_multi_draw_arrays: boolean;
var
  GLAD_GL_EXT_multisample: boolean;
const
  GL_MULTISAMPLE_EXT = $809D;
  GL_SAMPLE_ALPHA_TO_MASK_EXT = $809E;
  GL_SAMPLE_ALPHA_TO_ONE_EXT = $809F;
  GL_SAMPLE_MASK_EXT = $80A0;
  GL_1PASS_EXT = $80A1;
  GL_2PASS_0_EXT = $80A2;
  GL_2PASS_1_EXT = $80A3;
  GL_4PASS_0_EXT = $80A4;
  GL_4PASS_1_EXT = $80A5;
  GL_4PASS_2_EXT = $80A6;
  GL_4PASS_3_EXT = $80A7;
  GL_SAMPLE_BUFFERS_EXT = $80A8;
  GL_SAMPLES_EXT = $80A9;
  GL_SAMPLE_MASK_VALUE_EXT = $80AA;
  GL_SAMPLE_MASK_INVERT_EXT = $80AB;
  GL_SAMPLE_PATTERN_EXT = $80AC;
  GL_MULTISAMPLE_BIT_EXT = $20000000;
var
  GLAD_GL_EXT_multiview_tessellation_geometry_shader: boolean;
var
  GLAD_GL_EXT_multiview_texture_multisample: boolean;
var
  GLAD_GL_EXT_multiview_timer_query: boolean;
var
  GLAD_GL_EXT_packed_depth_stencil: boolean;
const
  GL_DEPTH_STENCIL_EXT = $84F9;
  GL_UNSIGNED_INT_24_8_EXT = $84FA;
  GL_DEPTH24_STENCIL8_EXT = $88F0;
  GL_TEXTURE_STENCIL_SIZE_EXT = $88F1;
var
  GLAD_GL_EXT_packed_float: boolean;
const
  GL_R11F_G11F_B10F_EXT = $8C3A;
  GL_UNSIGNED_INT_10F_11F_11F_REV_EXT = $8C3B;
  GL_RGBA_SIGNED_COMPONENTS_EXT = $8C3C;
var
  GLAD_GL_EXT_packed_pixels: boolean;
const
  GL_UNSIGNED_BYTE_3_3_2_EXT = $8032;
  GL_UNSIGNED_SHORT_4_4_4_4_EXT = $8033;
  GL_UNSIGNED_SHORT_5_5_5_1_EXT = $8034;
  GL_UNSIGNED_INT_8_8_8_8_EXT = $8035;
  GL_UNSIGNED_INT_10_10_10_2_EXT = $8036;
var
  GLAD_GL_EXT_paletted_texture: boolean;
const
  GL_COLOR_INDEX1_EXT = $80E2;
  GL_COLOR_INDEX2_EXT = $80E3;
  GL_COLOR_INDEX4_EXT = $80E4;
  GL_COLOR_INDEX8_EXT = $80E5;
  GL_COLOR_INDEX12_EXT = $80E6;
  GL_COLOR_INDEX16_EXT = $80E7;
  GL_TEXTURE_INDEX_SIZE_EXT = $80ED;
var
  GLAD_GL_EXT_pixel_buffer_object: boolean;
const
  GL_PIXEL_PACK_BUFFER_EXT = $88EB;
  GL_PIXEL_UNPACK_BUFFER_EXT = $88EC;
  GL_PIXEL_PACK_BUFFER_BINDING_EXT = $88ED;
  GL_PIXEL_UNPACK_BUFFER_BINDING_EXT = $88EF;
var
  GLAD_GL_EXT_pixel_transform: boolean;
const
  GL_PIXEL_TRANSFORM_2D_EXT = $8330;
  GL_PIXEL_MAG_FILTER_EXT = $8331;
  GL_PIXEL_MIN_FILTER_EXT = $8332;
  GL_PIXEL_CUBIC_WEIGHT_EXT = $8333;
  GL_CUBIC_EXT = $8334;
  GL_AVERAGE_EXT = $8335;
  GL_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT = $8336;
  GL_MAX_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT = $8337;
  GL_PIXEL_TRANSFORM_2D_MATRIX_EXT = $8338;
var
  GLAD_GL_EXT_pixel_transform_color_table: boolean;
var
  GLAD_GL_EXT_point_parameters: boolean;
const
  GL_POINT_SIZE_MIN_EXT = $8126;
  GL_POINT_SIZE_MAX_EXT = $8127;
  GL_POINT_FADE_THRESHOLD_SIZE_EXT = $8128;
  GL_DISTANCE_ATTENUATION_EXT = $8129;
var
  GLAD_GL_EXT_polygon_offset: boolean;
const
  GL_POLYGON_OFFSET_EXT = $8037;
  GL_POLYGON_OFFSET_FACTOR_EXT = $8038;
  GL_POLYGON_OFFSET_BIAS_EXT = $8039;
var
  GLAD_GL_EXT_polygon_offset_clamp: boolean;
const
  GL_POLYGON_OFFSET_CLAMP_EXT = $8E1B;
var
  GLAD_GL_EXT_post_depth_coverage: boolean;
var
  GLAD_GL_EXT_provoking_vertex: boolean;
const
  GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION_EXT = $8E4C;
  GL_FIRST_VERTEX_CONVENTION_EXT = $8E4D;
  GL_LAST_VERTEX_CONVENTION_EXT = $8E4E;
  GL_PROVOKING_VERTEX_EXT = $8E4F;
var
  GLAD_GL_EXT_raster_multisample: boolean;
const
  GL_RASTER_MULTISAMPLE_EXT = $9327;
  GL_RASTER_SAMPLES_EXT = $9328;
  GL_MAX_RASTER_SAMPLES_EXT = $9329;
  GL_RASTER_FIXED_SAMPLE_LOCATIONS_EXT = $932A;
  GL_MULTISAMPLE_RASTERIZATION_ALLOWED_EXT = $932B;
  GL_EFFECTIVE_RASTER_SAMPLES_EXT = $932C;
var
  GLAD_GL_EXT_rescale_normal: boolean;
const
  GL_RESCALE_NORMAL_EXT = $803A;
var
  GLAD_GL_EXT_secondary_color: boolean;
const
  GL_COLOR_SUM_EXT = $8458;
  GL_CURRENT_SECONDARY_COLOR_EXT = $8459;
  GL_SECONDARY_COLOR_ARRAY_SIZE_EXT = $845A;
  GL_SECONDARY_COLOR_ARRAY_TYPE_EXT = $845B;
  GL_SECONDARY_COLOR_ARRAY_STRIDE_EXT = $845C;
  GL_SECONDARY_COLOR_ARRAY_POINTER_EXT = $845D;
  GL_SECONDARY_COLOR_ARRAY_EXT = $845E;
var
  GLAD_GL_EXT_semaphore: boolean;
const
  GL_LAYOUT_GENERAL_EXT = $958D;
  GL_LAYOUT_COLOR_ATTACHMENT_EXT = $958E;
  GL_LAYOUT_DEPTH_STENCIL_ATTACHMENT_EXT = $958F;
  GL_LAYOUT_DEPTH_STENCIL_READ_ONLY_EXT = $9590;
  GL_LAYOUT_SHADER_READ_ONLY_EXT = $9591;
  GL_LAYOUT_TRANSFER_SRC_EXT = $9592;
  GL_LAYOUT_TRANSFER_DST_EXT = $9593;
  GL_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_EXT = $9530;
  GL_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_EXT = $9531;
var
  GLAD_GL_EXT_semaphore_fd: boolean;
var
  GLAD_GL_EXT_semaphore_win32: boolean;
const
  GL_HANDLE_TYPE_D3D12_FENCE_EXT = $9594;
  GL_D3D12_FENCE_VALUE_EXT = $9595;
var
  GLAD_GL_EXT_separate_shader_objects: boolean;
const
  GL_ACTIVE_PROGRAM_EXT = $8B8D;
  GL_VERTEX_SHADER_BIT_EXT = $00000001;
  GL_FRAGMENT_SHADER_BIT_EXT = $00000002;
  GL_ALL_SHADER_BITS_EXT = $FFFFFFFF;
  GL_PROGRAM_SEPARABLE_EXT = $8258;
  GL_PROGRAM_PIPELINE_BINDING_EXT = $825A;
var
  GLAD_GL_EXT_separate_specular_color: boolean;
const
  GL_LIGHT_MODEL_COLOR_CONTROL_EXT = $81F8;
  GL_SINGLE_COLOR_EXT = $81F9;
  GL_SEPARATE_SPECULAR_COLOR_EXT = $81FA;
var
  GLAD_GL_EXT_shader_framebuffer_fetch: boolean;
const
  GL_FRAGMENT_SHADER_DISCARDS_SAMPLES_EXT = $8A52;
var
  GLAD_GL_EXT_shader_framebuffer_fetch_non_coherent: boolean;
var
  GLAD_GL_EXT_shader_image_load_formatted: boolean;
var
  GLAD_GL_EXT_shader_image_load_store: boolean;
const
  GL_MAX_IMAGE_UNITS_EXT = $8F38;
  GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS_EXT = $8F39;
  GL_IMAGE_BINDING_NAME_EXT = $8F3A;
  GL_IMAGE_BINDING_LEVEL_EXT = $8F3B;
  GL_IMAGE_BINDING_LAYERED_EXT = $8F3C;
  GL_IMAGE_BINDING_LAYER_EXT = $8F3D;
  GL_IMAGE_BINDING_ACCESS_EXT = $8F3E;
  GL_IMAGE_1D_EXT = $904C;
  GL_IMAGE_2D_EXT = $904D;
  GL_IMAGE_3D_EXT = $904E;
  GL_IMAGE_2D_RECT_EXT = $904F;
  GL_IMAGE_CUBE_EXT = $9050;
  GL_IMAGE_BUFFER_EXT = $9051;
  GL_IMAGE_1D_ARRAY_EXT = $9052;
  GL_IMAGE_2D_ARRAY_EXT = $9053;
  GL_IMAGE_CUBE_MAP_ARRAY_EXT = $9054;
  GL_IMAGE_2D_MULTISAMPLE_EXT = $9055;
  GL_IMAGE_2D_MULTISAMPLE_ARRAY_EXT = $9056;
  GL_INT_IMAGE_1D_EXT = $9057;
  GL_INT_IMAGE_2D_EXT = $9058;
  GL_INT_IMAGE_3D_EXT = $9059;
  GL_INT_IMAGE_2D_RECT_EXT = $905A;
  GL_INT_IMAGE_CUBE_EXT = $905B;
  GL_INT_IMAGE_BUFFER_EXT = $905C;
  GL_INT_IMAGE_1D_ARRAY_EXT = $905D;
  GL_INT_IMAGE_2D_ARRAY_EXT = $905E;
  GL_INT_IMAGE_CUBE_MAP_ARRAY_EXT = $905F;
  GL_INT_IMAGE_2D_MULTISAMPLE_EXT = $9060;
  GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY_EXT = $9061;
  GL_UNSIGNED_INT_IMAGE_1D_EXT = $9062;
  GL_UNSIGNED_INT_IMAGE_2D_EXT = $9063;
  GL_UNSIGNED_INT_IMAGE_3D_EXT = $9064;
  GL_UNSIGNED_INT_IMAGE_2D_RECT_EXT = $9065;
  GL_UNSIGNED_INT_IMAGE_CUBE_EXT = $9066;
  GL_UNSIGNED_INT_IMAGE_BUFFER_EXT = $9067;
  GL_UNSIGNED_INT_IMAGE_1D_ARRAY_EXT = $9068;
  GL_UNSIGNED_INT_IMAGE_2D_ARRAY_EXT = $9069;
  GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY_EXT = $906A;
  GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_EXT = $906B;
  GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY_EXT = $906C;
  GL_MAX_IMAGE_SAMPLES_EXT = $906D;
  GL_IMAGE_BINDING_FORMAT_EXT = $906E;
  GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT_EXT = $00000001;
  GL_ELEMENT_ARRAY_BARRIER_BIT_EXT = $00000002;
  GL_UNIFORM_BARRIER_BIT_EXT = $00000004;
  GL_TEXTURE_FETCH_BARRIER_BIT_EXT = $00000008;
  GL_SHADER_IMAGE_ACCESS_BARRIER_BIT_EXT = $00000020;
  GL_COMMAND_BARRIER_BIT_EXT = $00000040;
  GL_PIXEL_BUFFER_BARRIER_BIT_EXT = $00000080;
  GL_TEXTURE_UPDATE_BARRIER_BIT_EXT = $00000100;
  GL_BUFFER_UPDATE_BARRIER_BIT_EXT = $00000200;
  GL_FRAMEBUFFER_BARRIER_BIT_EXT = $00000400;
  GL_TRANSFORM_FEEDBACK_BARRIER_BIT_EXT = $00000800;
  GL_ATOMIC_COUNTER_BARRIER_BIT_EXT = $00001000;
  GL_ALL_BARRIER_BITS_EXT = $FFFFFFFF;
var
  GLAD_GL_EXT_shader_integer_mix: boolean;
var
  GLAD_GL_EXT_shader_samples_identical: boolean;
var
  GLAD_GL_EXT_shadow_funcs: boolean;
var
  GLAD_GL_EXT_shared_texture_palette: boolean;
const
  GL_SHARED_TEXTURE_PALETTE_EXT = $81FB;
var
  GLAD_GL_EXT_sparse_texture2: boolean;
var
  GLAD_GL_EXT_stencil_clear_tag: boolean;
const
  GL_STENCIL_TAG_BITS_EXT = $88F2;
  GL_STENCIL_CLEAR_TAG_VALUE_EXT = $88F3;
var
  GLAD_GL_EXT_stencil_two_side: boolean;
const
  GL_STENCIL_TEST_TWO_SIDE_EXT = $8910;
  GL_ACTIVE_STENCIL_FACE_EXT = $8911;
var
  GLAD_GL_EXT_stencil_wrap: boolean;
const
  GL_INCR_WRAP_EXT = $8507;
  GL_DECR_WRAP_EXT = $8508;
var
  GLAD_GL_EXT_subtexture: boolean;
var
  GLAD_GL_EXT_texture: boolean;
const
  GL_ALPHA4_EXT = $803B;
  GL_ALPHA8_EXT = $803C;
  GL_ALPHA12_EXT = $803D;
  GL_ALPHA16_EXT = $803E;
  GL_LUMINANCE4_EXT = $803F;
  GL_LUMINANCE8_EXT = $8040;
  GL_LUMINANCE12_EXT = $8041;
  GL_LUMINANCE16_EXT = $8042;
  GL_LUMINANCE4_ALPHA4_EXT = $8043;
  GL_LUMINANCE6_ALPHA2_EXT = $8044;
  GL_LUMINANCE8_ALPHA8_EXT = $8045;
  GL_LUMINANCE12_ALPHA4_EXT = $8046;
  GL_LUMINANCE12_ALPHA12_EXT = $8047;
  GL_LUMINANCE16_ALPHA16_EXT = $8048;
  GL_INTENSITY_EXT = $8049;
  GL_INTENSITY4_EXT = $804A;
  GL_INTENSITY8_EXT = $804B;
  GL_INTENSITY12_EXT = $804C;
  GL_INTENSITY16_EXT = $804D;
  GL_RGB2_EXT = $804E;
  GL_RGB4_EXT = $804F;
  GL_RGB5_EXT = $8050;
  GL_RGB8_EXT = $8051;
  GL_RGB10_EXT = $8052;
  GL_RGB12_EXT = $8053;
  GL_RGB16_EXT = $8054;
  GL_RGBA2_EXT = $8055;
  GL_RGBA4_EXT = $8056;
  GL_RGB5_A1_EXT = $8057;
  GL_RGBA8_EXT = $8058;
  GL_RGB10_A2_EXT = $8059;
  GL_RGBA12_EXT = $805A;
  GL_RGBA16_EXT = $805B;
  GL_TEXTURE_RED_SIZE_EXT = $805C;
  GL_TEXTURE_GREEN_SIZE_EXT = $805D;
  GL_TEXTURE_BLUE_SIZE_EXT = $805E;
  GL_TEXTURE_ALPHA_SIZE_EXT = $805F;
  GL_TEXTURE_LUMINANCE_SIZE_EXT = $8060;
  GL_TEXTURE_INTENSITY_SIZE_EXT = $8061;
  GL_REPLACE_EXT = $8062;
  GL_PROXY_TEXTURE_1D_EXT = $8063;
  GL_PROXY_TEXTURE_2D_EXT = $8064;
  GL_TEXTURE_TOO_LARGE_EXT = $8065;
var
  GLAD_GL_EXT_texture3D: boolean;
const
  GL_PACK_SKIP_IMAGES_EXT = $806B;
  GL_PACK_IMAGE_HEIGHT_EXT = $806C;
  GL_UNPACK_SKIP_IMAGES_EXT = $806D;
  GL_UNPACK_IMAGE_HEIGHT_EXT = $806E;
  GL_TEXTURE_3D_EXT = $806F;
  GL_PROXY_TEXTURE_3D_EXT = $8070;
  GL_TEXTURE_DEPTH_EXT = $8071;
  GL_TEXTURE_WRAP_R_EXT = $8072;
  GL_MAX_3D_TEXTURE_SIZE_EXT = $8073;
var
  GLAD_GL_EXT_texture_array: boolean;
const
  GL_TEXTURE_1D_ARRAY_EXT = $8C18;
  GL_PROXY_TEXTURE_1D_ARRAY_EXT = $8C19;
  GL_TEXTURE_2D_ARRAY_EXT = $8C1A;
  GL_PROXY_TEXTURE_2D_ARRAY_EXT = $8C1B;
  GL_TEXTURE_BINDING_1D_ARRAY_EXT = $8C1C;
  GL_TEXTURE_BINDING_2D_ARRAY_EXT = $8C1D;
  GL_MAX_ARRAY_TEXTURE_LAYERS_EXT = $88FF;
  GL_COMPARE_REF_DEPTH_TO_TEXTURE_EXT = $884E;
var
  GLAD_GL_EXT_texture_buffer_object: boolean;
const
  GL_TEXTURE_BUFFER_EXT = $8C2A;
  GL_MAX_TEXTURE_BUFFER_SIZE_EXT = $8C2B;
  GL_TEXTURE_BINDING_BUFFER_EXT = $8C2C;
  GL_TEXTURE_BUFFER_DATA_STORE_BINDING_EXT = $8C2D;
  GL_TEXTURE_BUFFER_FORMAT_EXT = $8C2E;
var
  GLAD_GL_EXT_texture_compression_latc: boolean;
const
  GL_COMPRESSED_LUMINANCE_LATC1_EXT = $8C70;
  GL_COMPRESSED_SIGNED_LUMINANCE_LATC1_EXT = $8C71;
  GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT = $8C72;
  GL_COMPRESSED_SIGNED_LUMINANCE_ALPHA_LATC2_EXT = $8C73;
var
  GLAD_GL_EXT_texture_compression_rgtc: boolean;
const
  GL_COMPRESSED_RED_RGTC1_EXT = $8DBB;
  GL_COMPRESSED_SIGNED_RED_RGTC1_EXT = $8DBC;
  GL_COMPRESSED_RED_GREEN_RGTC2_EXT = $8DBD;
  GL_COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT = $8DBE;
var
  GLAD_GL_EXT_texture_compression_s3tc: boolean;
const
  GL_COMPRESSED_RGB_S3TC_DXT1_EXT = $83F0;
  GL_COMPRESSED_RGBA_S3TC_DXT1_EXT = $83F1;
  GL_COMPRESSED_RGBA_S3TC_DXT3_EXT = $83F2;
  GL_COMPRESSED_RGBA_S3TC_DXT5_EXT = $83F3;
var
  GLAD_GL_EXT_texture_cube_map: boolean;
const
  GL_NORMAL_MAP_EXT = $8511;
  GL_REFLECTION_MAP_EXT = $8512;
  GL_TEXTURE_CUBE_MAP_EXT = $8513;
  GL_TEXTURE_BINDING_CUBE_MAP_EXT = $8514;
  GL_TEXTURE_CUBE_MAP_POSITIVE_X_EXT = $8515;
  GL_TEXTURE_CUBE_MAP_NEGATIVE_X_EXT = $8516;
  GL_TEXTURE_CUBE_MAP_POSITIVE_Y_EXT = $8517;
  GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_EXT = $8518;
  GL_TEXTURE_CUBE_MAP_POSITIVE_Z_EXT = $8519;
  GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_EXT = $851A;
  GL_PROXY_TEXTURE_CUBE_MAP_EXT = $851B;
  GL_MAX_CUBE_MAP_TEXTURE_SIZE_EXT = $851C;
var
  GLAD_GL_EXT_texture_env_add: boolean;
var
  GLAD_GL_EXT_texture_env_combine: boolean;
const
  GL_COMBINE_EXT = $8570;
  GL_COMBINE_RGB_EXT = $8571;
  GL_COMBINE_ALPHA_EXT = $8572;
  GL_RGB_SCALE_EXT = $8573;
  GL_ADD_SIGNED_EXT = $8574;
  GL_INTERPOLATE_EXT = $8575;
  GL_CONSTANT_EXT = $8576;
  GL_PRIMARY_COLOR_EXT = $8577;
  GL_PREVIOUS_EXT = $8578;
  GL_SOURCE0_RGB_EXT = $8580;
  GL_SOURCE1_RGB_EXT = $8581;
  GL_SOURCE2_RGB_EXT = $8582;
  GL_SOURCE0_ALPHA_EXT = $8588;
  GL_SOURCE1_ALPHA_EXT = $8589;
  GL_SOURCE2_ALPHA_EXT = $858A;
  GL_OPERAND0_RGB_EXT = $8590;
  GL_OPERAND1_RGB_EXT = $8591;
  GL_OPERAND2_RGB_EXT = $8592;
  GL_OPERAND0_ALPHA_EXT = $8598;
  GL_OPERAND1_ALPHA_EXT = $8599;
  GL_OPERAND2_ALPHA_EXT = $859A;
var
  GLAD_GL_EXT_texture_env_dot3: boolean;
const
  GL_DOT3_RGB_EXT = $8740;
  GL_DOT3_RGBA_EXT = $8741;
var
  GLAD_GL_EXT_texture_filter_anisotropic: boolean;
const
  GL_TEXTURE_MAX_ANISOTROPY_EXT = $84FE;
  GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = $84FF;
var
  GLAD_GL_EXT_texture_filter_minmax: boolean;
const
  GL_TEXTURE_REDUCTION_MODE_EXT = $9366;
  GL_WEIGHTED_AVERAGE_EXT = $9367;
var
  GLAD_GL_EXT_texture_integer: boolean;
const
  GL_RGBA32UI_EXT = $8D70;
  GL_RGB32UI_EXT = $8D71;
  GL_ALPHA32UI_EXT = $8D72;
  GL_INTENSITY32UI_EXT = $8D73;
  GL_LUMINANCE32UI_EXT = $8D74;
  GL_LUMINANCE_ALPHA32UI_EXT = $8D75;
  GL_RGBA16UI_EXT = $8D76;
  GL_RGB16UI_EXT = $8D77;
  GL_ALPHA16UI_EXT = $8D78;
  GL_INTENSITY16UI_EXT = $8D79;
  GL_LUMINANCE16UI_EXT = $8D7A;
  GL_LUMINANCE_ALPHA16UI_EXT = $8D7B;
  GL_RGBA8UI_EXT = $8D7C;
  GL_RGB8UI_EXT = $8D7D;
  GL_ALPHA8UI_EXT = $8D7E;
  GL_INTENSITY8UI_EXT = $8D7F;
  GL_LUMINANCE8UI_EXT = $8D80;
  GL_LUMINANCE_ALPHA8UI_EXT = $8D81;
  GL_RGBA32I_EXT = $8D82;
  GL_RGB32I_EXT = $8D83;
  GL_ALPHA32I_EXT = $8D84;
  GL_INTENSITY32I_EXT = $8D85;
  GL_LUMINANCE32I_EXT = $8D86;
  GL_LUMINANCE_ALPHA32I_EXT = $8D87;
  GL_RGBA16I_EXT = $8D88;
  GL_RGB16I_EXT = $8D89;
  GL_ALPHA16I_EXT = $8D8A;
  GL_INTENSITY16I_EXT = $8D8B;
  GL_LUMINANCE16I_EXT = $8D8C;
  GL_LUMINANCE_ALPHA16I_EXT = $8D8D;
  GL_RGBA8I_EXT = $8D8E;
  GL_RGB8I_EXT = $8D8F;
  GL_ALPHA8I_EXT = $8D90;
  GL_INTENSITY8I_EXT = $8D91;
  GL_LUMINANCE8I_EXT = $8D92;
  GL_LUMINANCE_ALPHA8I_EXT = $8D93;
  GL_RED_INTEGER_EXT = $8D94;
  GL_GREEN_INTEGER_EXT = $8D95;
  GL_BLUE_INTEGER_EXT = $8D96;
  GL_ALPHA_INTEGER_EXT = $8D97;
  GL_RGB_INTEGER_EXT = $8D98;
  GL_RGBA_INTEGER_EXT = $8D99;
  GL_BGR_INTEGER_EXT = $8D9A;
  GL_BGRA_INTEGER_EXT = $8D9B;
  GL_LUMINANCE_INTEGER_EXT = $8D9C;
  GL_LUMINANCE_ALPHA_INTEGER_EXT = $8D9D;
  GL_RGBA_INTEGER_MODE_EXT = $8D9E;
var
  GLAD_GL_EXT_texture_lod_bias: boolean;
const
  GL_MAX_TEXTURE_LOD_BIAS_EXT = $84FD;
  GL_TEXTURE_FILTER_CONTROL_EXT = $8500;
  GL_TEXTURE_LOD_BIAS_EXT = $8501;
var
  GLAD_GL_EXT_texture_mirror_clamp: boolean;
const
  GL_MIRROR_CLAMP_EXT = $8742;
  GL_MIRROR_CLAMP_TO_EDGE_EXT = $8743;
  GL_MIRROR_CLAMP_TO_BORDER_EXT = $8912;
var
  GLAD_GL_EXT_texture_object: boolean;
const
  GL_TEXTURE_PRIORITY_EXT = $8066;
  GL_TEXTURE_RESIDENT_EXT = $8067;
  GL_TEXTURE_1D_BINDING_EXT = $8068;
  GL_TEXTURE_2D_BINDING_EXT = $8069;
  GL_TEXTURE_3D_BINDING_EXT = $806A;
var
  GLAD_GL_EXT_texture_perturb_normal: boolean;
const
  GL_PERTURB_EXT = $85AE;
  GL_TEXTURE_NORMAL_EXT = $85AF;
var
  GLAD_GL_EXT_texture_sRGB: boolean;
const
  GL_SRGB_EXT = $8C40;
  GL_SRGB8_EXT = $8C41;
  GL_SRGB_ALPHA_EXT = $8C42;
  GL_SRGB8_ALPHA8_EXT = $8C43;
  GL_SLUMINANCE_ALPHA_EXT = $8C44;
  GL_SLUMINANCE8_ALPHA8_EXT = $8C45;
  GL_SLUMINANCE_EXT = $8C46;
  GL_SLUMINANCE8_EXT = $8C47;
  GL_COMPRESSED_SRGB_EXT = $8C48;
  GL_COMPRESSED_SRGB_ALPHA_EXT = $8C49;
  GL_COMPRESSED_SLUMINANCE_EXT = $8C4A;
  GL_COMPRESSED_SLUMINANCE_ALPHA_EXT = $8C4B;
  GL_COMPRESSED_SRGB_S3TC_DXT1_EXT = $8C4C;
  GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = $8C4D;
  GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = $8C4E;
  GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = $8C4F;
var
  GLAD_GL_EXT_texture_sRGB_R8: boolean;
const
  GL_SR8_EXT = $8FBD;
var
  GLAD_GL_EXT_texture_sRGB_RG8: boolean;
const
  GL_SRG8_EXT = $8FBE;
var
  GLAD_GL_EXT_texture_sRGB_decode: boolean;
const
  GL_TEXTURE_SRGB_DECODE_EXT = $8A48;
  GL_DECODE_EXT = $8A49;
  GL_SKIP_DECODE_EXT = $8A4A;
var
  GLAD_GL_EXT_texture_shadow_lod: boolean;
var
  GLAD_GL_EXT_texture_shared_exponent: boolean;
const
  GL_RGB9_E5_EXT = $8C3D;
  GL_UNSIGNED_INT_5_9_9_9_REV_EXT = $8C3E;
  GL_TEXTURE_SHARED_SIZE_EXT = $8C3F;
var
  GLAD_GL_EXT_texture_snorm: boolean;
const
  GL_ALPHA_SNORM = $9010;
  GL_LUMINANCE_SNORM = $9011;
  GL_LUMINANCE_ALPHA_SNORM = $9012;
  GL_INTENSITY_SNORM = $9013;
  GL_ALPHA8_SNORM = $9014;
  GL_LUMINANCE8_SNORM = $9015;
  GL_LUMINANCE8_ALPHA8_SNORM = $9016;
  GL_INTENSITY8_SNORM = $9017;
  GL_ALPHA16_SNORM = $9018;
  GL_LUMINANCE16_SNORM = $9019;
  GL_LUMINANCE16_ALPHA16_SNORM = $901A;
  GL_INTENSITY16_SNORM = $901B;
  GL_RED_SNORM = $8F90;
  GL_RG_SNORM = $8F91;
  GL_RGB_SNORM = $8F92;
  GL_RGBA_SNORM = $8F93;
  GL_R8_SNORM = $8F94;
  GL_RG8_SNORM = $8F95;
  GL_RGB8_SNORM = $8F96;
  GL_RGBA8_SNORM = $8F97;
  GL_R16_SNORM = $8F98;
  GL_RG16_SNORM = $8F99;
  GL_RGB16_SNORM = $8F9A;
  GL_RGBA16_SNORM = $8F9B;
  GL_SIGNED_NORMALIZED = $8F9C;
var
  GLAD_GL_EXT_texture_storage: boolean;
const
  GL_TEXTURE_IMMUTABLE_FORMAT_EXT = $912F;
  GL_RGBA32F_EXT = $8814;
  GL_RGB32F_EXT = $8815;
  GL_ALPHA32F_EXT = $8816;
  GL_LUMINANCE32F_EXT = $8818;
  GL_LUMINANCE_ALPHA32F_EXT = $8819;
  GL_RGBA16F_EXT = $881A;
  GL_RGB16F_EXT = $881B;
  GL_ALPHA16F_EXT = $881C;
  GL_LUMINANCE16F_EXT = $881E;
  GL_LUMINANCE_ALPHA16F_EXT = $881F;
  GL_BGRA8_EXT = $93A1;
  GL_R8_EXT = $8229;
  GL_RG8_EXT = $822B;
  GL_R32F_EXT = $822E;
  GL_RG32F_EXT = $8230;
  GL_R16F_EXT = $822D;
  GL_RG16F_EXT = $822F;
var
  GLAD_GL_EXT_texture_swizzle: boolean;
const
  GL_TEXTURE_SWIZZLE_R_EXT = $8E42;
  GL_TEXTURE_SWIZZLE_G_EXT = $8E43;
  GL_TEXTURE_SWIZZLE_B_EXT = $8E44;
  GL_TEXTURE_SWIZZLE_A_EXT = $8E45;
  GL_TEXTURE_SWIZZLE_RGBA_EXT = $8E46;
var
  GLAD_GL_EXT_timer_query: boolean;
const
  GL_TIME_ELAPSED_EXT = $88BF;
var
  GLAD_GL_EXT_transform_feedback: boolean;
const
  GL_TRANSFORM_FEEDBACK_BUFFER_EXT = $8C8E;
  GL_TRANSFORM_FEEDBACK_BUFFER_START_EXT = $8C84;
  GL_TRANSFORM_FEEDBACK_BUFFER_SIZE_EXT = $8C85;
  GL_TRANSFORM_FEEDBACK_BUFFER_BINDING_EXT = $8C8F;
  GL_INTERLEAVED_ATTRIBS_EXT = $8C8C;
  GL_SEPARATE_ATTRIBS_EXT = $8C8D;
  GL_PRIMITIVES_GENERATED_EXT = $8C87;
  GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN_EXT = $8C88;
  GL_RASTERIZER_DISCARD_EXT = $8C89;
  GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS_EXT = $8C8A;
  GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS_EXT = $8C8B;
  GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS_EXT = $8C80;
  GL_TRANSFORM_FEEDBACK_VARYINGS_EXT = $8C83;
  GL_TRANSFORM_FEEDBACK_BUFFER_MODE_EXT = $8C7F;
  GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH_EXT = $8C76;
var
  GLAD_GL_EXT_vertex_array: boolean;
const
  GL_VERTEX_ARRAY_EXT = $8074;
  GL_NORMAL_ARRAY_EXT = $8075;
  GL_COLOR_ARRAY_EXT = $8076;
  GL_INDEX_ARRAY_EXT = $8077;
  GL_TEXTURE_COORD_ARRAY_EXT = $8078;
  GL_EDGE_FLAG_ARRAY_EXT = $8079;
  GL_VERTEX_ARRAY_SIZE_EXT = $807A;
  GL_VERTEX_ARRAY_TYPE_EXT = $807B;
  GL_VERTEX_ARRAY_STRIDE_EXT = $807C;
  GL_VERTEX_ARRAY_COUNT_EXT = $807D;
  GL_NORMAL_ARRAY_TYPE_EXT = $807E;
  GL_NORMAL_ARRAY_STRIDE_EXT = $807F;
  GL_NORMAL_ARRAY_COUNT_EXT = $8080;
  GL_COLOR_ARRAY_SIZE_EXT = $8081;
  GL_COLOR_ARRAY_TYPE_EXT = $8082;
  GL_COLOR_ARRAY_STRIDE_EXT = $8083;
  GL_COLOR_ARRAY_COUNT_EXT = $8084;
  GL_INDEX_ARRAY_TYPE_EXT = $8085;
  GL_INDEX_ARRAY_STRIDE_EXT = $8086;
  GL_INDEX_ARRAY_COUNT_EXT = $8087;
  GL_TEXTURE_COORD_ARRAY_SIZE_EXT = $8088;
  GL_TEXTURE_COORD_ARRAY_TYPE_EXT = $8089;
  GL_TEXTURE_COORD_ARRAY_STRIDE_EXT = $808A;
  GL_TEXTURE_COORD_ARRAY_COUNT_EXT = $808B;
  GL_EDGE_FLAG_ARRAY_STRIDE_EXT = $808C;
  GL_EDGE_FLAG_ARRAY_COUNT_EXT = $808D;
  GL_VERTEX_ARRAY_POINTER_EXT = $808E;
  GL_NORMAL_ARRAY_POINTER_EXT = $808F;
  GL_COLOR_ARRAY_POINTER_EXT = $8090;
  GL_INDEX_ARRAY_POINTER_EXT = $8091;
  GL_TEXTURE_COORD_ARRAY_POINTER_EXT = $8092;
  GL_EDGE_FLAG_ARRAY_POINTER_EXT = $8093;
var
  GLAD_GL_EXT_vertex_array_bgra: boolean;
var
  GLAD_GL_EXT_vertex_attrib_64bit: boolean;
const
  GL_DOUBLE_VEC2_EXT = $8FFC;
  GL_DOUBLE_VEC3_EXT = $8FFD;
  GL_DOUBLE_VEC4_EXT = $8FFE;
  GL_DOUBLE_MAT2_EXT = $8F46;
  GL_DOUBLE_MAT3_EXT = $8F47;
  GL_DOUBLE_MAT4_EXT = $8F48;
  GL_DOUBLE_MAT2x3_EXT = $8F49;
  GL_DOUBLE_MAT2x4_EXT = $8F4A;
  GL_DOUBLE_MAT3x2_EXT = $8F4B;
  GL_DOUBLE_MAT3x4_EXT = $8F4C;
  GL_DOUBLE_MAT4x2_EXT = $8F4D;
  GL_DOUBLE_MAT4x3_EXT = $8F4E;
var
  GLAD_GL_EXT_vertex_shader: boolean;
const
  GL_VERTEX_SHADER_EXT = $8780;
  GL_VERTEX_SHADER_BINDING_EXT = $8781;
  GL_OP_INDEX_EXT = $8782;
  GL_OP_NEGATE_EXT = $8783;
  GL_OP_DOT3_EXT = $8784;
  GL_OP_DOT4_EXT = $8785;
  GL_OP_MUL_EXT = $8786;
  GL_OP_ADD_EXT = $8787;
  GL_OP_MADD_EXT = $8788;
  GL_OP_FRAC_EXT = $8789;
  GL_OP_MAX_EXT = $878A;
  GL_OP_MIN_EXT = $878B;
  GL_OP_SET_GE_EXT = $878C;
  GL_OP_SET_LT_EXT = $878D;
  GL_OP_CLAMP_EXT = $878E;
  GL_OP_FLOOR_EXT = $878F;
  GL_OP_ROUND_EXT = $8790;
  GL_OP_EXP_BASE_2_EXT = $8791;
  GL_OP_LOG_BASE_2_EXT = $8792;
  GL_OP_POWER_EXT = $8793;
  GL_OP_RECIP_EXT = $8794;
  GL_OP_RECIP_SQRT_EXT = $8795;
  GL_OP_SUB_EXT = $8796;
  GL_OP_CROSS_PRODUCT_EXT = $8797;
  GL_OP_MULTIPLY_MATRIX_EXT = $8798;
  GL_OP_MOV_EXT = $8799;
  GL_OUTPUT_VERTEX_EXT = $879A;
  GL_OUTPUT_COLOR0_EXT = $879B;
  GL_OUTPUT_COLOR1_EXT = $879C;
  GL_OUTPUT_TEXTURE_COORD0_EXT = $879D;
  GL_OUTPUT_TEXTURE_COORD1_EXT = $879E;
  GL_OUTPUT_TEXTURE_COORD2_EXT = $879F;
  GL_OUTPUT_TEXTURE_COORD3_EXT = $87A0;
  GL_OUTPUT_TEXTURE_COORD4_EXT = $87A1;
  GL_OUTPUT_TEXTURE_COORD5_EXT = $87A2;
  GL_OUTPUT_TEXTURE_COORD6_EXT = $87A3;
  GL_OUTPUT_TEXTURE_COORD7_EXT = $87A4;
  GL_OUTPUT_TEXTURE_COORD8_EXT = $87A5;
  GL_OUTPUT_TEXTURE_COORD9_EXT = $87A6;
  GL_OUTPUT_TEXTURE_COORD10_EXT = $87A7;
  GL_OUTPUT_TEXTURE_COORD11_EXT = $87A8;
  GL_OUTPUT_TEXTURE_COORD12_EXT = $87A9;
  GL_OUTPUT_TEXTURE_COORD13_EXT = $87AA;
  GL_OUTPUT_TEXTURE_COORD14_EXT = $87AB;
  GL_OUTPUT_TEXTURE_COORD15_EXT = $87AC;
  GL_OUTPUT_TEXTURE_COORD16_EXT = $87AD;
  GL_OUTPUT_TEXTURE_COORD17_EXT = $87AE;
  GL_OUTPUT_TEXTURE_COORD18_EXT = $87AF;
  GL_OUTPUT_TEXTURE_COORD19_EXT = $87B0;
  GL_OUTPUT_TEXTURE_COORD20_EXT = $87B1;
  GL_OUTPUT_TEXTURE_COORD21_EXT = $87B2;
  GL_OUTPUT_TEXTURE_COORD22_EXT = $87B3;
  GL_OUTPUT_TEXTURE_COORD23_EXT = $87B4;
  GL_OUTPUT_TEXTURE_COORD24_EXT = $87B5;
  GL_OUTPUT_TEXTURE_COORD25_EXT = $87B6;
  GL_OUTPUT_TEXTURE_COORD26_EXT = $87B7;
  GL_OUTPUT_TEXTURE_COORD27_EXT = $87B8;
  GL_OUTPUT_TEXTURE_COORD28_EXT = $87B9;
  GL_OUTPUT_TEXTURE_COORD29_EXT = $87BA;
  GL_OUTPUT_TEXTURE_COORD30_EXT = $87BB;
  GL_OUTPUT_TEXTURE_COORD31_EXT = $87BC;
  GL_OUTPUT_FOG_EXT = $87BD;
  GL_SCALAR_EXT = $87BE;
  GL_VECTOR_EXT = $87BF;
  GL_MATRIX_EXT = $87C0;
  GL_VARIANT_EXT = $87C1;
  GL_INVARIANT_EXT = $87C2;
  GL_LOCAL_CONSTANT_EXT = $87C3;
  GL_LOCAL_EXT = $87C4;
  GL_MAX_VERTEX_SHADER_INSTRUCTIONS_EXT = $87C5;
  GL_MAX_VERTEX_SHADER_VARIANTS_EXT = $87C6;
  GL_MAX_VERTEX_SHADER_INVARIANTS_EXT = $87C7;
  GL_MAX_VERTEX_SHADER_LOCAL_CONSTANTS_EXT = $87C8;
  GL_MAX_VERTEX_SHADER_LOCALS_EXT = $87C9;
  GL_MAX_OPTIMIZED_VERTEX_SHADER_INSTRUCTIONS_EXT = $87CA;
  GL_MAX_OPTIMIZED_VERTEX_SHADER_VARIANTS_EXT = $87CB;
  GL_MAX_OPTIMIZED_VERTEX_SHADER_LOCAL_CONSTANTS_EXT = $87CC;
  GL_MAX_OPTIMIZED_VERTEX_SHADER_INVARIANTS_EXT = $87CD;
  GL_MAX_OPTIMIZED_VERTEX_SHADER_LOCALS_EXT = $87CE;
  GL_VERTEX_SHADER_INSTRUCTIONS_EXT = $87CF;
  GL_VERTEX_SHADER_VARIANTS_EXT = $87D0;
  GL_VERTEX_SHADER_INVARIANTS_EXT = $87D1;
  GL_VERTEX_SHADER_LOCAL_CONSTANTS_EXT = $87D2;
  GL_VERTEX_SHADER_LOCALS_EXT = $87D3;
  GL_VERTEX_SHADER_OPTIMIZED_EXT = $87D4;
  GL_X_EXT = $87D5;
  GL_Y_EXT = $87D6;
  GL_Z_EXT = $87D7;
  GL_W_EXT = $87D8;
  GL_NEGATIVE_X_EXT = $87D9;
  GL_NEGATIVE_Y_EXT = $87DA;
  GL_NEGATIVE_Z_EXT = $87DB;
  GL_NEGATIVE_W_EXT = $87DC;
  GL_ZERO_EXT = $87DD;
  GL_ONE_EXT = $87DE;
  GL_NEGATIVE_ONE_EXT = $87DF;
  GL_NORMALIZED_RANGE_EXT = $87E0;
  GL_FULL_RANGE_EXT = $87E1;
  GL_CURRENT_VERTEX_EXT = $87E2;
  GL_MVP_MATRIX_EXT = $87E3;
  GL_VARIANT_VALUE_EXT = $87E4;
  GL_VARIANT_DATATYPE_EXT = $87E5;
  GL_VARIANT_ARRAY_STRIDE_EXT = $87E6;
  GL_VARIANT_ARRAY_TYPE_EXT = $87E7;
  GL_VARIANT_ARRAY_EXT = $87E8;
  GL_VARIANT_ARRAY_POINTER_EXT = $87E9;
  GL_INVARIANT_VALUE_EXT = $87EA;
  GL_INVARIANT_DATATYPE_EXT = $87EB;
  GL_LOCAL_CONSTANT_VALUE_EXT = $87EC;
  GL_LOCAL_CONSTANT_DATATYPE_EXT = $87ED;
var
  GLAD_GL_EXT_vertex_weighting: boolean;
const
  GL_MODELVIEW0_STACK_DEPTH_EXT = $0BA3;
  GL_MODELVIEW1_STACK_DEPTH_EXT = $8502;
  GL_MODELVIEW0_MATRIX_EXT = $0BA6;
  GL_MODELVIEW1_MATRIX_EXT = $8506;
  GL_VERTEX_WEIGHTING_EXT = $8509;
  GL_MODELVIEW0_EXT = $1700;
  GL_MODELVIEW1_EXT = $850A;
  GL_CURRENT_VERTEX_WEIGHT_EXT = $850B;
  GL_VERTEX_WEIGHT_ARRAY_EXT = $850C;
  GL_VERTEX_WEIGHT_ARRAY_SIZE_EXT = $850D;
  GL_VERTEX_WEIGHT_ARRAY_TYPE_EXT = $850E;
  GL_VERTEX_WEIGHT_ARRAY_STRIDE_EXT = $850F;
  GL_VERTEX_WEIGHT_ARRAY_POINTER_EXT = $8510;
var
  GLAD_GL_EXT_win32_keyed_mutex: boolean;
var
  GLAD_GL_EXT_window_rectangles: boolean;
const
  GL_INCLUSIVE_EXT = $8F10;
  GL_EXCLUSIVE_EXT = $8F11;
  GL_WINDOW_RECTANGLE_EXT = $8F12;
  GL_WINDOW_RECTANGLE_MODE_EXT = $8F13;
  GL_MAX_WINDOW_RECTANGLES_EXT = $8F14;
  GL_NUM_WINDOW_RECTANGLES_EXT = $8F15;
var
  GLAD_GL_EXT_x11_sync_object: boolean;
const
  GL_SYNC_X11_FENCE_EXT = $90E1;
var
  GLAD_GL_GREMEDY_frame_terminator: boolean;
var
  GLAD_GL_GREMEDY_string_marker: boolean;
var
  GLAD_GL_HP_convolution_border_modes: boolean;
const
  GL_IGNORE_BORDER_HP = $8150;
  GL_CONSTANT_BORDER_HP = $8151;
  GL_REPLICATE_BORDER_HP = $8153;
  GL_CONVOLUTION_BORDER_COLOR_HP = $8154;
var
  GLAD_GL_HP_image_transform: boolean;
const
  GL_IMAGE_SCALE_X_HP = $8155;
  GL_IMAGE_SCALE_Y_HP = $8156;
  GL_IMAGE_TRANSLATE_X_HP = $8157;
  GL_IMAGE_TRANSLATE_Y_HP = $8158;
  GL_IMAGE_ROTATE_ANGLE_HP = $8159;
  GL_IMAGE_ROTATE_ORIGIN_X_HP = $815A;
  GL_IMAGE_ROTATE_ORIGIN_Y_HP = $815B;
  GL_IMAGE_MAG_FILTER_HP = $815C;
  GL_IMAGE_MIN_FILTER_HP = $815D;
  GL_IMAGE_CUBIC_WEIGHT_HP = $815E;
  GL_CUBIC_HP = $815F;
  GL_AVERAGE_HP = $8160;
  GL_IMAGE_TRANSFORM_2D_HP = $8161;
  GL_POST_IMAGE_TRANSFORM_COLOR_TABLE_HP = $8162;
  GL_PROXY_POST_IMAGE_TRANSFORM_COLOR_TABLE_HP = $8163;
var
  GLAD_GL_HP_occlusion_test: boolean;
const
  GL_OCCLUSION_TEST_HP = $8165;
  GL_OCCLUSION_TEST_RESULT_HP = $8166;
var
  GLAD_GL_HP_texture_lighting: boolean;
const
  GL_TEXTURE_LIGHTING_MODE_HP = $8167;
  GL_TEXTURE_POST_SPECULAR_HP = $8168;
  GL_TEXTURE_PRE_SPECULAR_HP = $8169;
var
  GLAD_GL_IBM_cull_vertex: boolean;
const
  GL_CULL_VERTEX_IBM = 103050;
var
  GLAD_GL_IBM_multimode_draw_arrays: boolean;
var
  GLAD_GL_IBM_rasterpos_clip: boolean;
const
  GL_RASTER_POSITION_UNCLIPPED_IBM = $19262;
var
  GLAD_GL_IBM_static_data: boolean;
const
  GL_ALL_STATIC_DATA_IBM = 103060;
  GL_STATIC_VERTEX_ARRAY_IBM = 103061;
var
  GLAD_GL_IBM_texture_mirrored_repeat: boolean;
const
  GL_MIRRORED_REPEAT_IBM = $8370;
var
  GLAD_GL_IBM_vertex_array_lists: boolean;
const
  GL_VERTEX_ARRAY_LIST_IBM = 103070;
  GL_NORMAL_ARRAY_LIST_IBM = 103071;
  GL_COLOR_ARRAY_LIST_IBM = 103072;
  GL_INDEX_ARRAY_LIST_IBM = 103073;
  GL_TEXTURE_COORD_ARRAY_LIST_IBM = 103074;
  GL_EDGE_FLAG_ARRAY_LIST_IBM = 103075;
  GL_FOG_COORDINATE_ARRAY_LIST_IBM = 103076;
  GL_SECONDARY_COLOR_ARRAY_LIST_IBM = 103077;
  GL_VERTEX_ARRAY_LIST_STRIDE_IBM = 103080;
  GL_NORMAL_ARRAY_LIST_STRIDE_IBM = 103081;
  GL_COLOR_ARRAY_LIST_STRIDE_IBM = 103082;
  GL_INDEX_ARRAY_LIST_STRIDE_IBM = 103083;
  GL_TEXTURE_COORD_ARRAY_LIST_STRIDE_IBM = 103084;
  GL_EDGE_FLAG_ARRAY_LIST_STRIDE_IBM = 103085;
  GL_FOG_COORDINATE_ARRAY_LIST_STRIDE_IBM = 103086;
  GL_SECONDARY_COLOR_ARRAY_LIST_STRIDE_IBM = 103087;
var
  GLAD_GL_INGR_blend_func_separate: boolean;
var
  GLAD_GL_INGR_color_clamp: boolean;
const
  GL_RED_MIN_CLAMP_INGR = $8560;
  GL_GREEN_MIN_CLAMP_INGR = $8561;
  GL_BLUE_MIN_CLAMP_INGR = $8562;
  GL_ALPHA_MIN_CLAMP_INGR = $8563;
  GL_RED_MAX_CLAMP_INGR = $8564;
  GL_GREEN_MAX_CLAMP_INGR = $8565;
  GL_BLUE_MAX_CLAMP_INGR = $8566;
  GL_ALPHA_MAX_CLAMP_INGR = $8567;
var
  GLAD_GL_INGR_interlace_read: boolean;
const
  GL_INTERLACE_READ_INGR = $8568;
var
  GLAD_GL_INTEL_blackhole_render: boolean;
const
  GL_BLACKHOLE_RENDER_INTEL = $83FC;
var
  GLAD_GL_INTEL_conservative_rasterization: boolean;
const
  GL_CONSERVATIVE_RASTERIZATION_INTEL = $83FE;
var
  GLAD_GL_INTEL_fragment_shader_ordering: boolean;
var
  GLAD_GL_INTEL_framebuffer_CMAA: boolean;
var
  GLAD_GL_INTEL_map_texture: boolean;
const
  GL_TEXTURE_MEMORY_LAYOUT_INTEL = $83FF;
  GL_LAYOUT_DEFAULT_INTEL = 0;
  GL_LAYOUT_LINEAR_INTEL = 1;
  GL_LAYOUT_LINEAR_CPU_CACHED_INTEL = 2;
var
  GLAD_GL_INTEL_parallel_arrays: boolean;
const
  GL_PARALLEL_ARRAYS_INTEL = $83F4;
  GL_VERTEX_ARRAY_PARALLEL_POINTERS_INTEL = $83F5;
  GL_NORMAL_ARRAY_PARALLEL_POINTERS_INTEL = $83F6;
  GL_COLOR_ARRAY_PARALLEL_POINTERS_INTEL = $83F7;
  GL_TEXTURE_COORD_ARRAY_PARALLEL_POINTERS_INTEL = $83F8;
var
  GLAD_GL_INTEL_performance_query: boolean;
const
  GL_PERFQUERY_SINGLE_CONTEXT_INTEL = $00000000;
  GL_PERFQUERY_GLOBAL_CONTEXT_INTEL = $00000001;
  GL_PERFQUERY_WAIT_INTEL = $83FB;
  GL_PERFQUERY_FLUSH_INTEL = $83FA;
  GL_PERFQUERY_DONOT_FLUSH_INTEL = $83F9;
  GL_PERFQUERY_COUNTER_EVENT_INTEL = $94F0;
  GL_PERFQUERY_COUNTER_DURATION_NORM_INTEL = $94F1;
  GL_PERFQUERY_COUNTER_DURATION_RAW_INTEL = $94F2;
  GL_PERFQUERY_COUNTER_THROUGHPUT_INTEL = $94F3;
  GL_PERFQUERY_COUNTER_RAW_INTEL = $94F4;
  GL_PERFQUERY_COUNTER_TIMESTAMP_INTEL = $94F5;
  GL_PERFQUERY_COUNTER_DATA_UINT32_INTEL = $94F8;
  GL_PERFQUERY_COUNTER_DATA_UINT64_INTEL = $94F9;
  GL_PERFQUERY_COUNTER_DATA_FLOAT_INTEL = $94FA;
  GL_PERFQUERY_COUNTER_DATA_DOUBLE_INTEL = $94FB;
  GL_PERFQUERY_COUNTER_DATA_BOOL32_INTEL = $94FC;
  GL_PERFQUERY_QUERY_NAME_LENGTH_MAX_INTEL = $94FD;
  GL_PERFQUERY_COUNTER_NAME_LENGTH_MAX_INTEL = $94FE;
  GL_PERFQUERY_COUNTER_DESC_LENGTH_MAX_INTEL = $94FF;
  GL_PERFQUERY_GPA_EXTENDED_COUNTERS_INTEL = $9500;
var
  GLAD_GL_KHR_blend_equation_advanced: boolean;
const
  GL_MULTIPLY_KHR = $9294;
  GL_SCREEN_KHR = $9295;
  GL_OVERLAY_KHR = $9296;
  GL_DARKEN_KHR = $9297;
  GL_LIGHTEN_KHR = $9298;
  GL_COLORDODGE_KHR = $9299;
  GL_COLORBURN_KHR = $929A;
  GL_HARDLIGHT_KHR = $929B;
  GL_SOFTLIGHT_KHR = $929C;
  GL_DIFFERENCE_KHR = $929E;
  GL_EXCLUSION_KHR = $92A0;
  GL_HSL_HUE_KHR = $92AD;
  GL_HSL_SATURATION_KHR = $92AE;
  GL_HSL_COLOR_KHR = $92AF;
  GL_HSL_LUMINOSITY_KHR = $92B0;
var
  GLAD_GL_KHR_blend_equation_advanced_coherent: boolean;
const
  GL_BLEND_ADVANCED_COHERENT_KHR = $9285;
var
  GLAD_GL_KHR_context_flush_control: boolean;
const
  GL_CONTEXT_RELEASE_BEHAVIOR = $82FB;
  GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH = $82FC;
  GL_CONTEXT_RELEASE_BEHAVIOR_KHR = $82FB;
  GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH_KHR = $82FC;
var
  GLAD_GL_KHR_debug: boolean;
const
  GL_DEBUG_OUTPUT_SYNCHRONOUS = $8242;
  GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH = $8243;
  GL_DEBUG_CALLBACK_FUNCTION = $8244;
  GL_DEBUG_CALLBACK_USER_PARAM = $8245;
  GL_DEBUG_SOURCE_API = $8246;
  GL_DEBUG_SOURCE_WINDOW_SYSTEM = $8247;
  GL_DEBUG_SOURCE_SHADER_COMPILER = $8248;
  GL_DEBUG_SOURCE_THIRD_PARTY = $8249;
  GL_DEBUG_SOURCE_APPLICATION = $824A;
  GL_DEBUG_SOURCE_OTHER = $824B;
  GL_DEBUG_TYPE_ERROR = $824C;
  GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR = $824D;
  GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR = $824E;
  GL_DEBUG_TYPE_PORTABILITY = $824F;
  GL_DEBUG_TYPE_PERFORMANCE = $8250;
  GL_DEBUG_TYPE_OTHER = $8251;
  GL_DEBUG_TYPE_MARKER = $8268;
  GL_DEBUG_TYPE_PUSH_GROUP = $8269;
  GL_DEBUG_TYPE_POP_GROUP = $826A;
  GL_DEBUG_SEVERITY_NOTIFICATION = $826B;
  GL_MAX_DEBUG_GROUP_STACK_DEPTH = $826C;
  GL_DEBUG_GROUP_STACK_DEPTH = $826D;
  GL_BUFFER = $82E0;
  GL_SHADER = $82E1;
  GL_PROGRAM = $82E2;
  GL_VERTEX_ARRAY = $8074;
  GL_QUERY = $82E3;
  GL_PROGRAM_PIPELINE = $82E4;
  GL_MAX_LABEL_LENGTH = $82E8;
  GL_MAX_DEBUG_MESSAGE_LENGTH = $9143;
  GL_MAX_DEBUG_LOGGED_MESSAGES = $9144;
  GL_DEBUG_LOGGED_MESSAGES = $9145;
  GL_DEBUG_SEVERITY_HIGH = $9146;
  GL_DEBUG_SEVERITY_MEDIUM = $9147;
  GL_DEBUG_SEVERITY_LOW = $9148;
  GL_DEBUG_OUTPUT = $92E0;
  GL_CONTEXT_FLAG_DEBUG_BIT = $00000002;
  GL_DEBUG_OUTPUT_SYNCHRONOUS_KHR = $8242;
  GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH_KHR = $8243;
  GL_DEBUG_CALLBACK_FUNCTION_KHR = $8244;
  GL_DEBUG_CALLBACK_USER_PARAM_KHR = $8245;
  GL_DEBUG_SOURCE_API_KHR = $8246;
  GL_DEBUG_SOURCE_WINDOW_SYSTEM_KHR = $8247;
  GL_DEBUG_SOURCE_SHADER_COMPILER_KHR = $8248;
  GL_DEBUG_SOURCE_THIRD_PARTY_KHR = $8249;
  GL_DEBUG_SOURCE_APPLICATION_KHR = $824A;
  GL_DEBUG_SOURCE_OTHER_KHR = $824B;
  GL_DEBUG_TYPE_ERROR_KHR = $824C;
  GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR_KHR = $824D;
  GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR_KHR = $824E;
  GL_DEBUG_TYPE_PORTABILITY_KHR = $824F;
  GL_DEBUG_TYPE_PERFORMANCE_KHR = $8250;
  GL_DEBUG_TYPE_OTHER_KHR = $8251;
  GL_DEBUG_TYPE_MARKER_KHR = $8268;
  GL_DEBUG_TYPE_PUSH_GROUP_KHR = $8269;
  GL_DEBUG_TYPE_POP_GROUP_KHR = $826A;
  GL_DEBUG_SEVERITY_NOTIFICATION_KHR = $826B;
  GL_MAX_DEBUG_GROUP_STACK_DEPTH_KHR = $826C;
  GL_DEBUG_GROUP_STACK_DEPTH_KHR = $826D;
  GL_BUFFER_KHR = $82E0;
  GL_SHADER_KHR = $82E1;
  GL_PROGRAM_KHR = $82E2;
  GL_VERTEX_ARRAY_KHR = $8074;
  GL_QUERY_KHR = $82E3;
  GL_PROGRAM_PIPELINE_KHR = $82E4;
  GL_SAMPLER_KHR = $82E6;
  GL_MAX_LABEL_LENGTH_KHR = $82E8;
  GL_MAX_DEBUG_MESSAGE_LENGTH_KHR = $9143;
  GL_MAX_DEBUG_LOGGED_MESSAGES_KHR = $9144;
  GL_DEBUG_LOGGED_MESSAGES_KHR = $9145;
  GL_DEBUG_SEVERITY_HIGH_KHR = $9146;
  GL_DEBUG_SEVERITY_MEDIUM_KHR = $9147;
  GL_DEBUG_SEVERITY_LOW_KHR = $9148;
  GL_DEBUG_OUTPUT_KHR = $92E0;
  GL_CONTEXT_FLAG_DEBUG_BIT_KHR = $00000002;
  GL_STACK_OVERFLOW_KHR = $0503;
  GL_STACK_UNDERFLOW_KHR = $0504;
  GL_DISPLAY_LIST = $82E7;
var
  GLAD_GL_KHR_no_error: boolean;
const
  GL_CONTEXT_FLAG_NO_ERROR_BIT_KHR = $00000008;
var
  GLAD_GL_KHR_parallel_shader_compile: boolean;
const
  GL_MAX_SHADER_COMPILER_THREADS_KHR = $91B0;
  GL_COMPLETION_STATUS_KHR = $91B1;
var
  GLAD_GL_KHR_robust_buffer_access_behavior: boolean;
var
  GLAD_GL_KHR_robustness: boolean;
const
  GL_CONTEXT_ROBUST_ACCESS = $90F3;
  GL_LOSE_CONTEXT_ON_RESET = $8252;
  GL_GUILTY_CONTEXT_RESET = $8253;
  GL_INNOCENT_CONTEXT_RESET = $8254;
  GL_UNKNOWN_CONTEXT_RESET = $8255;
  GL_RESET_NOTIFICATION_STRATEGY = $8256;
  GL_NO_RESET_NOTIFICATION = $8261;
  GL_CONTEXT_LOST = $0507;
  GL_CONTEXT_ROBUST_ACCESS_KHR = $90F3;
  GL_LOSE_CONTEXT_ON_RESET_KHR = $8252;
  GL_GUILTY_CONTEXT_RESET_KHR = $8253;
  GL_INNOCENT_CONTEXT_RESET_KHR = $8254;
  GL_UNKNOWN_CONTEXT_RESET_KHR = $8255;
  GL_RESET_NOTIFICATION_STRATEGY_KHR = $8256;
  GL_NO_RESET_NOTIFICATION_KHR = $8261;
  GL_CONTEXT_LOST_KHR = $0507;
var
  GLAD_GL_KHR_shader_subgroup: boolean;
const
  GL_SUBGROUP_SIZE_KHR = $9532;
  GL_SUBGROUP_SUPPORTED_STAGES_KHR = $9533;
  GL_SUBGROUP_SUPPORTED_FEATURES_KHR = $9534;
  GL_SUBGROUP_QUAD_ALL_STAGES_KHR = $9535;
  GL_SUBGROUP_FEATURE_BASIC_BIT_KHR = $00000001;
  GL_SUBGROUP_FEATURE_VOTE_BIT_KHR = $00000002;
  GL_SUBGROUP_FEATURE_ARITHMETIC_BIT_KHR = $00000004;
  GL_SUBGROUP_FEATURE_BALLOT_BIT_KHR = $00000008;
  GL_SUBGROUP_FEATURE_SHUFFLE_BIT_KHR = $00000010;
  GL_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT_KHR = $00000020;
  GL_SUBGROUP_FEATURE_CLUSTERED_BIT_KHR = $00000040;
  GL_SUBGROUP_FEATURE_QUAD_BIT_KHR = $00000080;
var
  GLAD_GL_KHR_texture_compression_astc_hdr: boolean;
const
  GL_COMPRESSED_RGBA_ASTC_4x4_KHR = $93B0;
  GL_COMPRESSED_RGBA_ASTC_5x4_KHR = $93B1;
  GL_COMPRESSED_RGBA_ASTC_5x5_KHR = $93B2;
  GL_COMPRESSED_RGBA_ASTC_6x5_KHR = $93B3;
  GL_COMPRESSED_RGBA_ASTC_6x6_KHR = $93B4;
  GL_COMPRESSED_RGBA_ASTC_8x5_KHR = $93B5;
  GL_COMPRESSED_RGBA_ASTC_8x6_KHR = $93B6;
  GL_COMPRESSED_RGBA_ASTC_8x8_KHR = $93B7;
  GL_COMPRESSED_RGBA_ASTC_10x5_KHR = $93B8;
  GL_COMPRESSED_RGBA_ASTC_10x6_KHR = $93B9;
  GL_COMPRESSED_RGBA_ASTC_10x8_KHR = $93BA;
  GL_COMPRESSED_RGBA_ASTC_10x10_KHR = $93BB;
  GL_COMPRESSED_RGBA_ASTC_12x10_KHR = $93BC;
  GL_COMPRESSED_RGBA_ASTC_12x12_KHR = $93BD;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = $93D0;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR = $93D1;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR = $93D2;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR = $93D3;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR = $93D4;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR = $93D5;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR = $93D6;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR = $93D7;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR = $93D8;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR = $93D9;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR = $93DA;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR = $93DB;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR = $93DC;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR = $93DD;
var
  GLAD_GL_KHR_texture_compression_astc_ldr: boolean;
var
  GLAD_GL_KHR_texture_compression_astc_sliced_3d: boolean;
var
  GLAD_GL_MESAX_texture_stack: boolean;
const
  GL_TEXTURE_1D_STACK_MESAX = $8759;
  GL_TEXTURE_2D_STACK_MESAX = $875A;
  GL_PROXY_TEXTURE_1D_STACK_MESAX = $875B;
  GL_PROXY_TEXTURE_2D_STACK_MESAX = $875C;
  GL_TEXTURE_1D_STACK_BINDING_MESAX = $875D;
  GL_TEXTURE_2D_STACK_BINDING_MESAX = $875E;
var
  GLAD_GL_MESA_framebuffer_flip_x: boolean;
const
  GL_FRAMEBUFFER_FLIP_X_MESA = $8BBC;
var
  GLAD_GL_MESA_framebuffer_flip_y: boolean;
const
  GL_FRAMEBUFFER_FLIP_Y_MESA = $8BBB;
var
  GLAD_GL_MESA_framebuffer_swap_xy: boolean;
const
  GL_FRAMEBUFFER_SWAP_XY_MESA = $8BBD;
var
  GLAD_GL_MESA_pack_invert: boolean;
const
  GL_PACK_INVERT_MESA = $8758;
var
  GLAD_GL_MESA_program_binary_formats: boolean;
const
  GL_PROGRAM_BINARY_FORMAT_MESA = $875F;
var
  GLAD_GL_MESA_resize_buffers: boolean;
var
  GLAD_GL_MESA_shader_integer_functions: boolean;
var
  GLAD_GL_MESA_tile_raster_order: boolean;
const
  GL_TILE_RASTER_ORDER_FIXED_MESA = $8BB8;
  GL_TILE_RASTER_ORDER_INCREASING_X_MESA = $8BB9;
  GL_TILE_RASTER_ORDER_INCREASING_Y_MESA = $8BBA;
var
  GLAD_GL_MESA_window_pos: boolean;
var
  GLAD_GL_MESA_ycbcr_texture: boolean;
const
  GL_UNSIGNED_SHORT_8_8_MESA = $85BA;
  GL_UNSIGNED_SHORT_8_8_REV_MESA = $85BB;
  GL_YCBCR_MESA = $8757;
var
  GLAD_GL_NVX_blend_equation_advanced_multi_draw_buffers: boolean;
var
  GLAD_GL_NVX_conditional_render: boolean;
var
  GLAD_GL_NVX_gpu_memory_info: boolean;
const
  GL_GPU_MEMORY_INFO_DEDICATED_VIDMEM_NVX = $9047;
  GL_GPU_MEMORY_INFO_TOTAL_AVAILABLE_MEMORY_NVX = $9048;
  GL_GPU_MEMORY_INFO_CURRENT_AVAILABLE_VIDMEM_NVX = $9049;
  GL_GPU_MEMORY_INFO_EVICTION_COUNT_NVX = $904A;
  GL_GPU_MEMORY_INFO_EVICTED_MEMORY_NVX = $904B;
var
  GLAD_GL_NVX_gpu_multicast2: boolean;
const
  GL_UPLOAD_GPU_MASK_NVX = $954A;
var
  GLAD_GL_NVX_linked_gpu_multicast: boolean;
const
  GL_LGPU_SEPARATE_STORAGE_BIT_NVX = $0800;
  GL_MAX_LGPU_GPUS_NVX = $92BA;
var
  GLAD_GL_NVX_progress_fence: boolean;
var
  GLAD_GL_NV_alpha_to_coverage_dither_control: boolean;
const
  GL_ALPHA_TO_COVERAGE_DITHER_DEFAULT_NV = $934D;
  GL_ALPHA_TO_COVERAGE_DITHER_ENABLE_NV = $934E;
  GL_ALPHA_TO_COVERAGE_DITHER_DISABLE_NV = $934F;
  GL_ALPHA_TO_COVERAGE_DITHER_MODE_NV = $92BF;
var
  GLAD_GL_NV_bindless_multi_draw_indirect: boolean;
var
  GLAD_GL_NV_bindless_multi_draw_indirect_count: boolean;
var
  GLAD_GL_NV_bindless_texture: boolean;
var
  GLAD_GL_NV_blend_equation_advanced: boolean;
const
  GL_BLEND_OVERLAP_NV = $9281;
  GL_BLEND_PREMULTIPLIED_SRC_NV = $9280;
  GL_BLUE_NV = $1905;
  GL_COLORBURN_NV = $929A;
  GL_COLORDODGE_NV = $9299;
  GL_CONJOINT_NV = $9284;
  GL_CONTRAST_NV = $92A1;
  GL_DARKEN_NV = $9297;
  GL_DIFFERENCE_NV = $929E;
  GL_DISJOINT_NV = $9283;
  GL_DST_ATOP_NV = $928F;
  GL_DST_IN_NV = $928B;
  GL_DST_NV = $9287;
  GL_DST_OUT_NV = $928D;
  GL_DST_OVER_NV = $9289;
  GL_EXCLUSION_NV = $92A0;
  GL_GREEN_NV = $1904;
  GL_HARDLIGHT_NV = $929B;
  GL_HARDMIX_NV = $92A9;
  GL_HSL_COLOR_NV = $92AF;
  GL_HSL_HUE_NV = $92AD;
  GL_HSL_LUMINOSITY_NV = $92B0;
  GL_HSL_SATURATION_NV = $92AE;
  GL_INVERT_OVG_NV = $92B4;
  GL_INVERT_RGB_NV = $92A3;
  GL_LIGHTEN_NV = $9298;
  GL_LINEARBURN_NV = $92A5;
  GL_LINEARDODGE_NV = $92A4;
  GL_LINEARLIGHT_NV = $92A7;
  GL_MINUS_CLAMPED_NV = $92B3;
  GL_MINUS_NV = $929F;
  GL_MULTIPLY_NV = $9294;
  GL_OVERLAY_NV = $9296;
  GL_PINLIGHT_NV = $92A8;
  GL_PLUS_CLAMPED_ALPHA_NV = $92B2;
  GL_PLUS_CLAMPED_NV = $92B1;
  GL_PLUS_DARKER_NV = $9292;
  GL_PLUS_NV = $9291;
  GL_RED_NV = $1903;
  GL_SCREEN_NV = $9295;
  GL_SOFTLIGHT_NV = $929C;
  GL_SRC_ATOP_NV = $928E;
  GL_SRC_IN_NV = $928A;
  GL_SRC_NV = $9286;
  GL_SRC_OUT_NV = $928C;
  GL_SRC_OVER_NV = $9288;
  GL_UNCORRELATED_NV = $9282;
  GL_VIVIDLIGHT_NV = $92A6;
  GL_XOR_NV = $1506;
var
  GLAD_GL_NV_blend_equation_advanced_coherent: boolean;
const
  GL_BLEND_ADVANCED_COHERENT_NV = $9285;
var
  GLAD_GL_NV_blend_minmax_factor: boolean;
var
  GLAD_GL_NV_blend_square: boolean;
var
  GLAD_GL_NV_clip_space_w_scaling: boolean;
const
  GL_VIEWPORT_POSITION_W_SCALE_NV = $937C;
  GL_VIEWPORT_POSITION_W_SCALE_X_COEFF_NV = $937D;
  GL_VIEWPORT_POSITION_W_SCALE_Y_COEFF_NV = $937E;
var
  GLAD_GL_NV_command_list: boolean;
const
  GL_TERMINATE_SEQUENCE_COMMAND_NV = $0000;
  GL_NOP_COMMAND_NV = $0001;
  GL_DRAW_ELEMENTS_COMMAND_NV = $0002;
  GL_DRAW_ARRAYS_COMMAND_NV = $0003;
  GL_DRAW_ELEMENTS_STRIP_COMMAND_NV = $0004;
  GL_DRAW_ARRAYS_STRIP_COMMAND_NV = $0005;
  GL_DRAW_ELEMENTS_INSTANCED_COMMAND_NV = $0006;
  GL_DRAW_ARRAYS_INSTANCED_COMMAND_NV = $0007;
  GL_ELEMENT_ADDRESS_COMMAND_NV = $0008;
  GL_ATTRIBUTE_ADDRESS_COMMAND_NV = $0009;
  GL_UNIFORM_ADDRESS_COMMAND_NV = $000A;
  GL_BLEND_COLOR_COMMAND_NV = $000B;
  GL_STENCIL_REF_COMMAND_NV = $000C;
  GL_LINE_WIDTH_COMMAND_NV = $000D;
  GL_POLYGON_OFFSET_COMMAND_NV = $000E;
  GL_ALPHA_REF_COMMAND_NV = $000F;
  GL_VIEWPORT_COMMAND_NV = $0010;
  GL_SCISSOR_COMMAND_NV = $0011;
  GL_FRONT_FACE_COMMAND_NV = $0012;
var
  GLAD_GL_NV_compute_program5: boolean;
const
  GL_COMPUTE_PROGRAM_NV = $90FB;
  GL_COMPUTE_PROGRAM_PARAMETER_BUFFER_NV = $90FC;
var
  GLAD_GL_NV_compute_shader_derivatives: boolean;
var
  GLAD_GL_NV_conditional_render: boolean;
const
  GL_QUERY_WAIT_NV = $8E13;
  GL_QUERY_NO_WAIT_NV = $8E14;
  GL_QUERY_BY_REGION_WAIT_NV = $8E15;
  GL_QUERY_BY_REGION_NO_WAIT_NV = $8E16;
var
  GLAD_GL_NV_conservative_raster: boolean;
const
  GL_CONSERVATIVE_RASTERIZATION_NV = $9346;
  GL_SUBPIXEL_PRECISION_BIAS_X_BITS_NV = $9347;
  GL_SUBPIXEL_PRECISION_BIAS_Y_BITS_NV = $9348;
  GL_MAX_SUBPIXEL_PRECISION_BIAS_BITS_NV = $9349;
var
  GLAD_GL_NV_conservative_raster_dilate: boolean;
const
  GL_CONSERVATIVE_RASTER_DILATE_NV = $9379;
  GL_CONSERVATIVE_RASTER_DILATE_RANGE_NV = $937A;
  GL_CONSERVATIVE_RASTER_DILATE_GRANULARITY_NV = $937B;
var
  GLAD_GL_NV_conservative_raster_pre_snap: boolean;
const
  GL_CONSERVATIVE_RASTER_MODE_PRE_SNAP_NV = $9550;
var
  GLAD_GL_NV_conservative_raster_pre_snap_triangles: boolean;
const
  GL_CONSERVATIVE_RASTER_MODE_NV = $954D;
  GL_CONSERVATIVE_RASTER_MODE_POST_SNAP_NV = $954E;
  GL_CONSERVATIVE_RASTER_MODE_PRE_SNAP_TRIANGLES_NV = $954F;
var
  GLAD_GL_NV_conservative_raster_underestimation: boolean;
var
  GLAD_GL_NV_copy_depth_to_color: boolean;
const
  GL_DEPTH_STENCIL_TO_RGBA_NV = $886E;
  GL_DEPTH_STENCIL_TO_BGRA_NV = $886F;
var
  GLAD_GL_NV_copy_image: boolean;
var
  GLAD_GL_NV_deep_texture3D: boolean;
const
  GL_MAX_DEEP_3D_TEXTURE_WIDTH_HEIGHT_NV = $90D0;
  GL_MAX_DEEP_3D_TEXTURE_DEPTH_NV = $90D1;
var
  GLAD_GL_NV_depth_buffer_float: boolean;
const
  GL_DEPTH_COMPONENT32F_NV = $8DAB;
  GL_DEPTH32F_STENCIL8_NV = $8DAC;
  GL_FLOAT_32_UNSIGNED_INT_24_8_REV_NV = $8DAD;
  GL_DEPTH_BUFFER_FLOAT_MODE_NV = $8DAF;
var
  GLAD_GL_NV_depth_clamp: boolean;
const
  GL_DEPTH_CLAMP_NV = $864F;
var
  GLAD_GL_NV_draw_texture: boolean;
var
  GLAD_GL_NV_draw_vulkan_image: boolean;
var
  GLAD_GL_NV_evaluators: boolean;
const
  GL_EVAL_2D_NV = $86C0;
  GL_EVAL_TRIANGULAR_2D_NV = $86C1;
  GL_MAP_TESSELLATION_NV = $86C2;
  GL_MAP_ATTRIB_U_ORDER_NV = $86C3;
  GL_MAP_ATTRIB_V_ORDER_NV = $86C4;
  GL_EVAL_FRACTIONAL_TESSELLATION_NV = $86C5;
  GL_EVAL_VERTEX_ATTRIB0_NV = $86C6;
  GL_EVAL_VERTEX_ATTRIB1_NV = $86C7;
  GL_EVAL_VERTEX_ATTRIB2_NV = $86C8;
  GL_EVAL_VERTEX_ATTRIB3_NV = $86C9;
  GL_EVAL_VERTEX_ATTRIB4_NV = $86CA;
  GL_EVAL_VERTEX_ATTRIB5_NV = $86CB;
  GL_EVAL_VERTEX_ATTRIB6_NV = $86CC;
  GL_EVAL_VERTEX_ATTRIB7_NV = $86CD;
  GL_EVAL_VERTEX_ATTRIB8_NV = $86CE;
  GL_EVAL_VERTEX_ATTRIB9_NV = $86CF;
  GL_EVAL_VERTEX_ATTRIB10_NV = $86D0;
  GL_EVAL_VERTEX_ATTRIB11_NV = $86D1;
  GL_EVAL_VERTEX_ATTRIB12_NV = $86D2;
  GL_EVAL_VERTEX_ATTRIB13_NV = $86D3;
  GL_EVAL_VERTEX_ATTRIB14_NV = $86D4;
  GL_EVAL_VERTEX_ATTRIB15_NV = $86D5;
  GL_MAX_MAP_TESSELLATION_NV = $86D6;
  GL_MAX_RATIONAL_EVAL_ORDER_NV = $86D7;
var
  GLAD_GL_NV_explicit_multisample: boolean;
const
  GL_SAMPLE_POSITION_NV = $8E50;
  GL_SAMPLE_MASK_NV = $8E51;
  GL_SAMPLE_MASK_VALUE_NV = $8E52;
  GL_TEXTURE_BINDING_RENDERBUFFER_NV = $8E53;
  GL_TEXTURE_RENDERBUFFER_DATA_STORE_BINDING_NV = $8E54;
  GL_TEXTURE_RENDERBUFFER_NV = $8E55;
  GL_SAMPLER_RENDERBUFFER_NV = $8E56;
  GL_INT_SAMPLER_RENDERBUFFER_NV = $8E57;
  GL_UNSIGNED_INT_SAMPLER_RENDERBUFFER_NV = $8E58;
  GL_MAX_SAMPLE_MASK_WORDS_NV = $8E59;
var
  GLAD_GL_NV_fence: boolean;
const
  GL_ALL_COMPLETED_NV = $84F2;
  GL_FENCE_STATUS_NV = $84F3;
  GL_FENCE_CONDITION_NV = $84F4;
var
  GLAD_GL_NV_fill_rectangle: boolean;
const
  GL_FILL_RECTANGLE_NV = $933C;
var
  GLAD_GL_NV_float_buffer: boolean;
const
  GL_FLOAT_R_NV = $8880;
  GL_FLOAT_RG_NV = $8881;
  GL_FLOAT_RGB_NV = $8882;
  GL_FLOAT_RGBA_NV = $8883;
  GL_FLOAT_R16_NV = $8884;
  GL_FLOAT_R32_NV = $8885;
  GL_FLOAT_RG16_NV = $8886;
  GL_FLOAT_RG32_NV = $8887;
  GL_FLOAT_RGB16_NV = $8888;
  GL_FLOAT_RGB32_NV = $8889;
  GL_FLOAT_RGBA16_NV = $888A;
  GL_FLOAT_RGBA32_NV = $888B;
  GL_TEXTURE_FLOAT_COMPONENTS_NV = $888C;
  GL_FLOAT_CLEAR_COLOR_VALUE_NV = $888D;
  GL_FLOAT_RGBA_MODE_NV = $888E;
var
  GLAD_GL_NV_fog_distance: boolean;
const
  GL_FOG_DISTANCE_MODE_NV = $855A;
  GL_EYE_RADIAL_NV = $855B;
  GL_EYE_PLANE_ABSOLUTE_NV = $855C;
var
  GLAD_GL_NV_fragment_coverage_to_color: boolean;
const
  GL_FRAGMENT_COVERAGE_TO_COLOR_NV = $92DD;
  GL_FRAGMENT_COVERAGE_COLOR_NV = $92DE;
var
  GLAD_GL_NV_fragment_program: boolean;
const
  GL_MAX_FRAGMENT_PROGRAM_LOCAL_PARAMETERS_NV = $8868;
  GL_FRAGMENT_PROGRAM_NV = $8870;
  GL_MAX_TEXTURE_COORDS_NV = $8871;
  GL_MAX_TEXTURE_IMAGE_UNITS_NV = $8872;
  GL_FRAGMENT_PROGRAM_BINDING_NV = $8873;
  GL_PROGRAM_ERROR_STRING_NV = $8874;
var
  GLAD_GL_NV_fragment_program2: boolean;
const
  GL_MAX_PROGRAM_EXEC_INSTRUCTIONS_NV = $88F4;
  GL_MAX_PROGRAM_CALL_DEPTH_NV = $88F5;
  GL_MAX_PROGRAM_IF_DEPTH_NV = $88F6;
  GL_MAX_PROGRAM_LOOP_DEPTH_NV = $88F7;
  GL_MAX_PROGRAM_LOOP_COUNT_NV = $88F8;
var
  GLAD_GL_NV_fragment_program4: boolean;
var
  GLAD_GL_NV_fragment_program_option: boolean;
var
  GLAD_GL_NV_fragment_shader_barycentric: boolean;
var
  GLAD_GL_NV_fragment_shader_interlock: boolean;
var
  GLAD_GL_NV_framebuffer_mixed_samples: boolean;
const
  GL_COVERAGE_MODULATION_TABLE_NV = $9331;
  GL_COLOR_SAMPLES_NV = $8E20;
  GL_DEPTH_SAMPLES_NV = $932D;
  GL_STENCIL_SAMPLES_NV = $932E;
  GL_MIXED_DEPTH_SAMPLES_SUPPORTED_NV = $932F;
  GL_MIXED_STENCIL_SAMPLES_SUPPORTED_NV = $9330;
  GL_COVERAGE_MODULATION_NV = $9332;
  GL_COVERAGE_MODULATION_TABLE_SIZE_NV = $9333;
var
  GLAD_GL_NV_framebuffer_multisample_coverage: boolean;
const
  GL_RENDERBUFFER_COVERAGE_SAMPLES_NV = $8CAB;
  GL_RENDERBUFFER_COLOR_SAMPLES_NV = $8E10;
  GL_MAX_MULTISAMPLE_COVERAGE_MODES_NV = $8E11;
  GL_MULTISAMPLE_COVERAGE_MODES_NV = $8E12;
var
  GLAD_GL_NV_geometry_program4: boolean;
const
  GL_GEOMETRY_PROGRAM_NV = $8C26;
  GL_MAX_PROGRAM_OUTPUT_VERTICES_NV = $8C27;
  GL_MAX_PROGRAM_TOTAL_OUTPUT_COMPONENTS_NV = $8C28;
var
  GLAD_GL_NV_geometry_shader4: boolean;
var
  GLAD_GL_NV_geometry_shader_passthrough: boolean;
var
  GLAD_GL_NV_gpu_multicast: boolean;
const
  GL_PER_GPU_STORAGE_BIT_NV = $0800;
  GL_MULTICAST_GPUS_NV = $92BA;
  GL_RENDER_GPU_MASK_NV = $9558;
  GL_PER_GPU_STORAGE_NV = $9548;
  GL_MULTICAST_PROGRAMMABLE_SAMPLE_LOCATION_NV = $9549;
var
  GLAD_GL_NV_gpu_program4: boolean;
const
  GL_MIN_PROGRAM_TEXEL_OFFSET_NV = $8904;
  GL_MAX_PROGRAM_TEXEL_OFFSET_NV = $8905;
  GL_PROGRAM_ATTRIB_COMPONENTS_NV = $8906;
  GL_PROGRAM_RESULT_COMPONENTS_NV = $8907;
  GL_MAX_PROGRAM_ATTRIB_COMPONENTS_NV = $8908;
  GL_MAX_PROGRAM_RESULT_COMPONENTS_NV = $8909;
  GL_MAX_PROGRAM_GENERIC_ATTRIBS_NV = $8DA5;
  GL_MAX_PROGRAM_GENERIC_RESULTS_NV = $8DA6;
var
  GLAD_GL_NV_gpu_program5: boolean;
const
  GL_MAX_GEOMETRY_PROGRAM_INVOCATIONS_NV = $8E5A;
  GL_MIN_FRAGMENT_INTERPOLATION_OFFSET_NV = $8E5B;
  GL_MAX_FRAGMENT_INTERPOLATION_OFFSET_NV = $8E5C;
  GL_FRAGMENT_PROGRAM_INTERPOLATION_OFFSET_BITS_NV = $8E5D;
  GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET_NV = $8E5E;
  GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET_NV = $8E5F;
  GL_MAX_PROGRAM_SUBROUTINE_PARAMETERS_NV = $8F44;
  GL_MAX_PROGRAM_SUBROUTINE_NUM_NV = $8F45;
var
  GLAD_GL_NV_gpu_program5_mem_extended: boolean;
var
  GLAD_GL_NV_gpu_shader5: boolean;
var
  GLAD_GL_NV_half_float: boolean;
const
  GL_HALF_FLOAT_NV = $140B;
var
  GLAD_GL_NV_internalformat_sample_query: boolean;
const
  GL_MULTISAMPLES_NV = $9371;
  GL_SUPERSAMPLE_SCALE_X_NV = $9372;
  GL_SUPERSAMPLE_SCALE_Y_NV = $9373;
  GL_CONFORMANT_NV = $9374;
var
  GLAD_GL_NV_light_max_exponent: boolean;
const
  GL_MAX_SHININESS_NV = $8504;
  GL_MAX_SPOT_EXPONENT_NV = $8505;
var
  GLAD_GL_NV_memory_attachment: boolean;
const
  GL_ATTACHED_MEMORY_OBJECT_NV = $95A4;
  GL_ATTACHED_MEMORY_OFFSET_NV = $95A5;
  GL_MEMORY_ATTACHABLE_ALIGNMENT_NV = $95A6;
  GL_MEMORY_ATTACHABLE_SIZE_NV = $95A7;
  GL_MEMORY_ATTACHABLE_NV = $95A8;
  GL_DETACHED_MEMORY_INCARNATION_NV = $95A9;
  GL_DETACHED_TEXTURES_NV = $95AA;
  GL_DETACHED_BUFFERS_NV = $95AB;
  GL_MAX_DETACHED_TEXTURES_NV = $95AC;
  GL_MAX_DETACHED_BUFFERS_NV = $95AD;
var
  GLAD_GL_NV_memory_object_sparse: boolean;
var
  GLAD_GL_NV_mesh_shader: boolean;
const
  GL_MESH_SHADER_NV = $9559;
  GL_TASK_SHADER_NV = $955A;
  GL_MAX_MESH_UNIFORM_BLOCKS_NV = $8E60;
  GL_MAX_MESH_TEXTURE_IMAGE_UNITS_NV = $8E61;
  GL_MAX_MESH_IMAGE_UNIFORMS_NV = $8E62;
  GL_MAX_MESH_UNIFORM_COMPONENTS_NV = $8E63;
  GL_MAX_MESH_ATOMIC_COUNTER_BUFFERS_NV = $8E64;
  GL_MAX_MESH_ATOMIC_COUNTERS_NV = $8E65;
  GL_MAX_MESH_SHADER_STORAGE_BLOCKS_NV = $8E66;
  GL_MAX_COMBINED_MESH_UNIFORM_COMPONENTS_NV = $8E67;
  GL_MAX_TASK_UNIFORM_BLOCKS_NV = $8E68;
  GL_MAX_TASK_TEXTURE_IMAGE_UNITS_NV = $8E69;
  GL_MAX_TASK_IMAGE_UNIFORMS_NV = $8E6A;
  GL_MAX_TASK_UNIFORM_COMPONENTS_NV = $8E6B;
  GL_MAX_TASK_ATOMIC_COUNTER_BUFFERS_NV = $8E6C;
  GL_MAX_TASK_ATOMIC_COUNTERS_NV = $8E6D;
  GL_MAX_TASK_SHADER_STORAGE_BLOCKS_NV = $8E6E;
  GL_MAX_COMBINED_TASK_UNIFORM_COMPONENTS_NV = $8E6F;
  GL_MAX_MESH_WORK_GROUP_INVOCATIONS_NV = $95A2;
  GL_MAX_TASK_WORK_GROUP_INVOCATIONS_NV = $95A3;
  GL_MAX_MESH_TOTAL_MEMORY_SIZE_NV = $9536;
  GL_MAX_TASK_TOTAL_MEMORY_SIZE_NV = $9537;
  GL_MAX_MESH_OUTPUT_VERTICES_NV = $9538;
  GL_MAX_MESH_OUTPUT_PRIMITIVES_NV = $9539;
  GL_MAX_TASK_OUTPUT_COUNT_NV = $953A;
  GL_MAX_DRAW_MESH_TASKS_COUNT_NV = $953D;
  GL_MAX_MESH_VIEWS_NV = $9557;
  GL_MESH_OUTPUT_PER_VERTEX_GRANULARITY_NV = $92DF;
  GL_MESH_OUTPUT_PER_PRIMITIVE_GRANULARITY_NV = $9543;
  GL_MAX_MESH_WORK_GROUP_SIZE_NV = $953B;
  GL_MAX_TASK_WORK_GROUP_SIZE_NV = $953C;
  GL_MESH_WORK_GROUP_SIZE_NV = $953E;
  GL_TASK_WORK_GROUP_SIZE_NV = $953F;
  GL_MESH_VERTICES_OUT_NV = $9579;
  GL_MESH_PRIMITIVES_OUT_NV = $957A;
  GL_MESH_OUTPUT_TYPE_NV = $957B;
  GL_UNIFORM_BLOCK_REFERENCED_BY_MESH_SHADER_NV = $959C;
  GL_UNIFORM_BLOCK_REFERENCED_BY_TASK_SHADER_NV = $959D;
  GL_REFERENCED_BY_MESH_SHADER_NV = $95A0;
  GL_REFERENCED_BY_TASK_SHADER_NV = $95A1;
  GL_MESH_SHADER_BIT_NV = $00000040;
  GL_TASK_SHADER_BIT_NV = $00000080;
  GL_MESH_SUBROUTINE_NV = $957C;
  GL_TASK_SUBROUTINE_NV = $957D;
  GL_MESH_SUBROUTINE_UNIFORM_NV = $957E;
  GL_TASK_SUBROUTINE_UNIFORM_NV = $957F;
  GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_MESH_SHADER_NV = $959E;
  GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TASK_SHADER_NV = $959F;
var
  GLAD_GL_NV_multisample_coverage: boolean;
var
  GLAD_GL_NV_multisample_filter_hint: boolean;
const
  GL_MULTISAMPLE_FILTER_HINT_NV = $8534;
var
  GLAD_GL_NV_occlusion_query: boolean;
const
  GL_PIXEL_COUNTER_BITS_NV = $8864;
  GL_CURRENT_OCCLUSION_QUERY_ID_NV = $8865;
  GL_PIXEL_COUNT_NV = $8866;
  GL_PIXEL_COUNT_AVAILABLE_NV = $8867;
var
  GLAD_GL_NV_packed_depth_stencil: boolean;
const
  GL_DEPTH_STENCIL_NV = $84F9;
  GL_UNSIGNED_INT_24_8_NV = $84FA;
var
  GLAD_GL_NV_parameter_buffer_object: boolean;
const
  GL_MAX_PROGRAM_PARAMETER_BUFFER_BINDINGS_NV = $8DA0;
  GL_MAX_PROGRAM_PARAMETER_BUFFER_SIZE_NV = $8DA1;
  GL_VERTEX_PROGRAM_PARAMETER_BUFFER_NV = $8DA2;
  GL_GEOMETRY_PROGRAM_PARAMETER_BUFFER_NV = $8DA3;
  GL_FRAGMENT_PROGRAM_PARAMETER_BUFFER_NV = $8DA4;
var
  GLAD_GL_NV_parameter_buffer_object2: boolean;
var
  GLAD_GL_NV_path_rendering: boolean;
const
  GL_PATH_FORMAT_SVG_NV = $9070;
  GL_PATH_FORMAT_PS_NV = $9071;
  GL_STANDARD_FONT_NAME_NV = $9072;
  GL_SYSTEM_FONT_NAME_NV = $9073;
  GL_FILE_NAME_NV = $9074;
  GL_PATH_STROKE_WIDTH_NV = $9075;
  GL_PATH_END_CAPS_NV = $9076;
  GL_PATH_INITIAL_END_CAP_NV = $9077;
  GL_PATH_TERMINAL_END_CAP_NV = $9078;
  GL_PATH_JOIN_STYLE_NV = $9079;
  GL_PATH_MITER_LIMIT_NV = $907A;
  GL_PATH_DASH_CAPS_NV = $907B;
  GL_PATH_INITIAL_DASH_CAP_NV = $907C;
  GL_PATH_TERMINAL_DASH_CAP_NV = $907D;
  GL_PATH_DASH_OFFSET_NV = $907E;
  GL_PATH_CLIENT_LENGTH_NV = $907F;
  GL_PATH_FILL_MODE_NV = $9080;
  GL_PATH_FILL_MASK_NV = $9081;
  GL_PATH_FILL_COVER_MODE_NV = $9082;
  GL_PATH_STROKE_COVER_MODE_NV = $9083;
  GL_PATH_STROKE_MASK_NV = $9084;
  GL_COUNT_UP_NV = $9088;
  GL_COUNT_DOWN_NV = $9089;
  GL_PATH_OBJECT_BOUNDING_BOX_NV = $908A;
  GL_CONVEX_HULL_NV = $908B;
  GL_BOUNDING_BOX_NV = $908D;
  GL_TRANSLATE_X_NV = $908E;
  GL_TRANSLATE_Y_NV = $908F;
  GL_TRANSLATE_2D_NV = $9090;
  GL_TRANSLATE_3D_NV = $9091;
  GL_AFFINE_2D_NV = $9092;
  GL_AFFINE_3D_NV = $9094;
  GL_TRANSPOSE_AFFINE_2D_NV = $9096;
  GL_TRANSPOSE_AFFINE_3D_NV = $9098;
  GL_UTF8_NV = $909A;
  GL_UTF16_NV = $909B;
  GL_BOUNDING_BOX_OF_BOUNDING_BOXES_NV = $909C;
  GL_PATH_COMMAND_COUNT_NV = $909D;
  GL_PATH_COORD_COUNT_NV = $909E;
  GL_PATH_DASH_ARRAY_COUNT_NV = $909F;
  GL_PATH_COMPUTED_LENGTH_NV = $90A0;
  GL_PATH_FILL_BOUNDING_BOX_NV = $90A1;
  GL_PATH_STROKE_BOUNDING_BOX_NV = $90A2;
  GL_SQUARE_NV = $90A3;
  GL_ROUND_NV = $90A4;
  GL_TRIANGULAR_NV = $90A5;
  GL_BEVEL_NV = $90A6;
  GL_MITER_REVERT_NV = $90A7;
  GL_MITER_TRUNCATE_NV = $90A8;
  GL_SKIP_MISSING_GLYPH_NV = $90A9;
  GL_USE_MISSING_GLYPH_NV = $90AA;
  GL_PATH_ERROR_POSITION_NV = $90AB;
  GL_ACCUM_ADJACENT_PAIRS_NV = $90AD;
  GL_ADJACENT_PAIRS_NV = $90AE;
  GL_FIRST_TO_REST_NV = $90AF;
  GL_PATH_GEN_MODE_NV = $90B0;
  GL_PATH_GEN_COEFF_NV = $90B1;
  GL_PATH_GEN_COMPONENTS_NV = $90B3;
  GL_PATH_STENCIL_FUNC_NV = $90B7;
  GL_PATH_STENCIL_REF_NV = $90B8;
  GL_PATH_STENCIL_VALUE_MASK_NV = $90B9;
  GL_PATH_STENCIL_DEPTH_OFFSET_FACTOR_NV = $90BD;
  GL_PATH_STENCIL_DEPTH_OFFSET_UNITS_NV = $90BE;
  GL_PATH_COVER_DEPTH_FUNC_NV = $90BF;
  GL_PATH_DASH_OFFSET_RESET_NV = $90B4;
  GL_MOVE_TO_RESETS_NV = $90B5;
  GL_MOVE_TO_CONTINUES_NV = $90B6;
  GL_CLOSE_PATH_NV = $00;
  GL_MOVE_TO_NV = $02;
  GL_RELATIVE_MOVE_TO_NV = $03;
  GL_LINE_TO_NV = $04;
  GL_RELATIVE_LINE_TO_NV = $05;
  GL_HORIZONTAL_LINE_TO_NV = $06;
  GL_RELATIVE_HORIZONTAL_LINE_TO_NV = $07;
  GL_VERTICAL_LINE_TO_NV = $08;
  GL_RELATIVE_VERTICAL_LINE_TO_NV = $09;
  GL_QUADRATIC_CURVE_TO_NV = $0A;
  GL_RELATIVE_QUADRATIC_CURVE_TO_NV = $0B;
  GL_CUBIC_CURVE_TO_NV = $0C;
  GL_RELATIVE_CUBIC_CURVE_TO_NV = $0D;
  GL_SMOOTH_QUADRATIC_CURVE_TO_NV = $0E;
  GL_RELATIVE_SMOOTH_QUADRATIC_CURVE_TO_NV = $0F;
  GL_SMOOTH_CUBIC_CURVE_TO_NV = $10;
  GL_RELATIVE_SMOOTH_CUBIC_CURVE_TO_NV = $11;
  GL_SMALL_CCW_ARC_TO_NV = $12;
  GL_RELATIVE_SMALL_CCW_ARC_TO_NV = $13;
  GL_SMALL_CW_ARC_TO_NV = $14;
  GL_RELATIVE_SMALL_CW_ARC_TO_NV = $15;
  GL_LARGE_CCW_ARC_TO_NV = $16;
  GL_RELATIVE_LARGE_CCW_ARC_TO_NV = $17;
  GL_LARGE_CW_ARC_TO_NV = $18;
  GL_RELATIVE_LARGE_CW_ARC_TO_NV = $19;
  GL_RESTART_PATH_NV = $F0;
  GL_DUP_FIRST_CUBIC_CURVE_TO_NV = $F2;
  GL_DUP_LAST_CUBIC_CURVE_TO_NV = $F4;
  GL_RECT_NV = $F6;
  GL_CIRCULAR_CCW_ARC_TO_NV = $F8;
  GL_CIRCULAR_CW_ARC_TO_NV = $FA;
  GL_CIRCULAR_TANGENT_ARC_TO_NV = $FC;
  GL_ARC_TO_NV = $FE;
  GL_RELATIVE_ARC_TO_NV = $FF;
  GL_BOLD_BIT_NV = $01;
  GL_ITALIC_BIT_NV = $02;
  GL_GLYPH_WIDTH_BIT_NV = $01;
  GL_GLYPH_HEIGHT_BIT_NV = $02;
  GL_GLYPH_HORIZONTAL_BEARING_X_BIT_NV = $04;
  GL_GLYPH_HORIZONTAL_BEARING_Y_BIT_NV = $08;
  GL_GLYPH_HORIZONTAL_BEARING_ADVANCE_BIT_NV = $10;
  GL_GLYPH_VERTICAL_BEARING_X_BIT_NV = $20;
  GL_GLYPH_VERTICAL_BEARING_Y_BIT_NV = $40;
  GL_GLYPH_VERTICAL_BEARING_ADVANCE_BIT_NV = $80;
  GL_GLYPH_HAS_KERNING_BIT_NV = $100;
  GL_FONT_X_MIN_BOUNDS_BIT_NV = $00010000;
  GL_FONT_Y_MIN_BOUNDS_BIT_NV = $00020000;
  GL_FONT_X_MAX_BOUNDS_BIT_NV = $00040000;
  GL_FONT_Y_MAX_BOUNDS_BIT_NV = $00080000;
  GL_FONT_UNITS_PER_EM_BIT_NV = $00100000;
  GL_FONT_ASCENDER_BIT_NV = $00200000;
  GL_FONT_DESCENDER_BIT_NV = $00400000;
  GL_FONT_HEIGHT_BIT_NV = $00800000;
  GL_FONT_MAX_ADVANCE_WIDTH_BIT_NV = $01000000;
  GL_FONT_MAX_ADVANCE_HEIGHT_BIT_NV = $02000000;
  GL_FONT_UNDERLINE_POSITION_BIT_NV = $04000000;
  GL_FONT_UNDERLINE_THICKNESS_BIT_NV = $08000000;
  GL_FONT_HAS_KERNING_BIT_NV = $10000000;
  GL_ROUNDED_RECT_NV = $E8;
  GL_RELATIVE_ROUNDED_RECT_NV = $E9;
  GL_ROUNDED_RECT2_NV = $EA;
  GL_RELATIVE_ROUNDED_RECT2_NV = $EB;
  GL_ROUNDED_RECT4_NV = $EC;
  GL_RELATIVE_ROUNDED_RECT4_NV = $ED;
  GL_ROUNDED_RECT8_NV = $EE;
  GL_RELATIVE_ROUNDED_RECT8_NV = $EF;
  GL_RELATIVE_RECT_NV = $F7;
  GL_FONT_GLYPHS_AVAILABLE_NV = $9368;
  GL_FONT_TARGET_UNAVAILABLE_NV = $9369;
  GL_FONT_UNAVAILABLE_NV = $936A;
  GL_FONT_UNINTELLIGIBLE_NV = $936B;
  GL_CONIC_CURVE_TO_NV = $1A;
  GL_RELATIVE_CONIC_CURVE_TO_NV = $1B;
  GL_FONT_NUM_GLYPH_INDICES_BIT_NV = $20000000;
  GL_STANDARD_FONT_FORMAT_NV = $936C;
  GL_2_BYTES_NV = $1407;
  GL_3_BYTES_NV = $1408;
  GL_4_BYTES_NV = $1409;
  GL_EYE_LINEAR_NV = $2400;
  GL_OBJECT_LINEAR_NV = $2401;
  GL_CONSTANT_NV = $8576;
  GL_PATH_FOG_GEN_MODE_NV = $90AC;
  GL_PRIMARY_COLOR = $8577;
  GL_PRIMARY_COLOR_NV = $852C;
  GL_SECONDARY_COLOR_NV = $852D;
  GL_PATH_GEN_COLOR_FORMAT_NV = $90B2;
  GL_PATH_PROJECTION_NV = $1701;
  GL_PATH_MODELVIEW_NV = $1700;
  GL_PATH_MODELVIEW_STACK_DEPTH_NV = $0BA3;
  GL_PATH_MODELVIEW_MATRIX_NV = $0BA6;
  GL_PATH_MAX_MODELVIEW_STACK_DEPTH_NV = $0D36;
  GL_PATH_TRANSPOSE_MODELVIEW_MATRIX_NV = $84E3;
  GL_PATH_PROJECTION_STACK_DEPTH_NV = $0BA4;
  GL_PATH_PROJECTION_MATRIX_NV = $0BA7;
  GL_PATH_MAX_PROJECTION_STACK_DEPTH_NV = $0D38;
  GL_PATH_TRANSPOSE_PROJECTION_MATRIX_NV = $84E4;
  GL_FRAGMENT_INPUT_NV = $936D;
var
  GLAD_GL_NV_path_rendering_shared_edge: boolean;
const
  GL_SHARED_EDGE_NV = $C0;
var
  GLAD_GL_NV_pixel_data_range: boolean;
const
  GL_WRITE_PIXEL_DATA_RANGE_NV = $8878;
  GL_READ_PIXEL_DATA_RANGE_NV = $8879;
  GL_WRITE_PIXEL_DATA_RANGE_LENGTH_NV = $887A;
  GL_READ_PIXEL_DATA_RANGE_LENGTH_NV = $887B;
  GL_WRITE_PIXEL_DATA_RANGE_POINTER_NV = $887C;
  GL_READ_PIXEL_DATA_RANGE_POINTER_NV = $887D;
var
  GLAD_GL_NV_point_sprite: boolean;
const
  GL_POINT_SPRITE_NV = $8861;
  GL_COORD_REPLACE_NV = $8862;
  GL_POINT_SPRITE_R_MODE_NV = $8863;
var
  GLAD_GL_NV_present_video: boolean;
const
  GL_FRAME_NV = $8E26;
  GL_FIELDS_NV = $8E27;
  GL_CURRENT_TIME_NV = $8E28;
  GL_NUM_FILL_STREAMS_NV = $8E29;
  GL_PRESENT_TIME_NV = $8E2A;
  GL_PRESENT_DURATION_NV = $8E2B;
var
  GLAD_GL_NV_primitive_restart: boolean;
const
  GL_PRIMITIVE_RESTART_NV = $8558;
  GL_PRIMITIVE_RESTART_INDEX_NV = $8559;
var
  GLAD_GL_NV_primitive_shading_rate: boolean;
const
  GL_SHADING_RATE_IMAGE_PER_PRIMITIVE_NV = $95B1;
  GL_SHADING_RATE_IMAGE_PALETTE_COUNT_NV = $95B2;
var
  GLAD_GL_NV_query_resource: boolean;
const
  GL_QUERY_RESOURCE_TYPE_VIDMEM_ALLOC_NV = $9540;
  GL_QUERY_RESOURCE_MEMTYPE_VIDMEM_NV = $9542;
  GL_QUERY_RESOURCE_SYS_RESERVED_NV = $9544;
  GL_QUERY_RESOURCE_TEXTURE_NV = $9545;
  GL_QUERY_RESOURCE_RENDERBUFFER_NV = $9546;
  GL_QUERY_RESOURCE_BUFFEROBJECT_NV = $9547;
var
  GLAD_GL_NV_query_resource_tag: boolean;
var
  GLAD_GL_NV_register_combiners: boolean;
const
  GL_REGISTER_COMBINERS_NV = $8522;
  GL_VARIABLE_A_NV = $8523;
  GL_VARIABLE_B_NV = $8524;
  GL_VARIABLE_C_NV = $8525;
  GL_VARIABLE_D_NV = $8526;
  GL_VARIABLE_E_NV = $8527;
  GL_VARIABLE_F_NV = $8528;
  GL_VARIABLE_G_NV = $8529;
  GL_CONSTANT_COLOR0_NV = $852A;
  GL_CONSTANT_COLOR1_NV = $852B;
  GL_SPARE0_NV = $852E;
  GL_SPARE1_NV = $852F;
  GL_DISCARD_NV = $8530;
  GL_E_TIMES_F_NV = $8531;
  GL_SPARE0_PLUS_SECONDARY_COLOR_NV = $8532;
  GL_UNSIGNED_IDENTITY_NV = $8536;
  GL_UNSIGNED_INVERT_NV = $8537;
  GL_EXPAND_NORMAL_NV = $8538;
  GL_EXPAND_NEGATE_NV = $8539;
  GL_HALF_BIAS_NORMAL_NV = $853A;
  GL_HALF_BIAS_NEGATE_NV = $853B;
  GL_SIGNED_IDENTITY_NV = $853C;
  GL_SIGNED_NEGATE_NV = $853D;
  GL_SCALE_BY_TWO_NV = $853E;
  GL_SCALE_BY_FOUR_NV = $853F;
  GL_SCALE_BY_ONE_HALF_NV = $8540;
  GL_BIAS_BY_NEGATIVE_ONE_HALF_NV = $8541;
  GL_COMBINER_INPUT_NV = $8542;
  GL_COMBINER_MAPPING_NV = $8543;
  GL_COMBINER_COMPONENT_USAGE_NV = $8544;
  GL_COMBINER_AB_DOT_PRODUCT_NV = $8545;
  GL_COMBINER_CD_DOT_PRODUCT_NV = $8546;
  GL_COMBINER_MUX_SUM_NV = $8547;
  GL_COMBINER_SCALE_NV = $8548;
  GL_COMBINER_BIAS_NV = $8549;
  GL_COMBINER_AB_OUTPUT_NV = $854A;
  GL_COMBINER_CD_OUTPUT_NV = $854B;
  GL_COMBINER_SUM_OUTPUT_NV = $854C;
  GL_MAX_GENERAL_COMBINERS_NV = $854D;
  GL_NUM_GENERAL_COMBINERS_NV = $854E;
  GL_COLOR_SUM_CLAMP_NV = $854F;
  GL_COMBINER0_NV = $8550;
  GL_COMBINER1_NV = $8551;
  GL_COMBINER2_NV = $8552;
  GL_COMBINER3_NV = $8553;
  GL_COMBINER4_NV = $8554;
  GL_COMBINER5_NV = $8555;
  GL_COMBINER6_NV = $8556;
  GL_COMBINER7_NV = $8557;
var
  GLAD_GL_NV_register_combiners2: boolean;
const
  GL_PER_STAGE_CONSTANTS_NV = $8535;
var
  GLAD_GL_NV_representative_fragment_test: boolean;
const
  GL_REPRESENTATIVE_FRAGMENT_TEST_NV = $937F;
var
  GLAD_GL_NV_robustness_video_memory_purge: boolean;
const
  GL_PURGED_CONTEXT_RESET_NV = $92BB;
var
  GLAD_GL_NV_sample_locations: boolean;
const
  GL_SAMPLE_LOCATION_SUBPIXEL_BITS_NV = $933D;
  GL_SAMPLE_LOCATION_PIXEL_GRID_WIDTH_NV = $933E;
  GL_SAMPLE_LOCATION_PIXEL_GRID_HEIGHT_NV = $933F;
  GL_PROGRAMMABLE_SAMPLE_LOCATION_TABLE_SIZE_NV = $9340;
  GL_SAMPLE_LOCATION_NV = $8E50;
  GL_PROGRAMMABLE_SAMPLE_LOCATION_NV = $9341;
  GL_FRAMEBUFFER_PROGRAMMABLE_SAMPLE_LOCATIONS_NV = $9342;
  GL_FRAMEBUFFER_SAMPLE_LOCATION_PIXEL_GRID_NV = $9343;
var
  GLAD_GL_NV_sample_mask_override_coverage: boolean;
var
  GLAD_GL_NV_scissor_exclusive: boolean;
const
  GL_SCISSOR_TEST_EXCLUSIVE_NV = $9555;
  GL_SCISSOR_BOX_EXCLUSIVE_NV = $9556;
var
  GLAD_GL_NV_shader_atomic_counters: boolean;
var
  GLAD_GL_NV_shader_atomic_float: boolean;
var
  GLAD_GL_NV_shader_atomic_float64: boolean;
var
  GLAD_GL_NV_shader_atomic_fp16_vector: boolean;
var
  GLAD_GL_NV_shader_atomic_int64: boolean;
var
  GLAD_GL_NV_shader_buffer_load: boolean;
const
  GL_BUFFER_GPU_ADDRESS_NV = $8F1D;
  GL_GPU_ADDRESS_NV = $8F34;
  GL_MAX_SHADER_BUFFER_ADDRESS_NV = $8F35;
var
  GLAD_GL_NV_shader_buffer_store: boolean;
const
  GL_SHADER_GLOBAL_ACCESS_BARRIER_BIT_NV = $00000010;
  GL_READ_WRITE = $88BA;
  GL_WRITE_ONLY = $88B9;
var
  GLAD_GL_NV_shader_storage_buffer_object: boolean;
var
  GLAD_GL_NV_shader_subgroup_partitioned: boolean;
const
  GL_SUBGROUP_FEATURE_PARTITIONED_BIT_NV = $00000100;
var
  GLAD_GL_NV_shader_texture_footprint: boolean;
var
  GLAD_GL_NV_shader_thread_group: boolean;
const
  GL_WARP_SIZE_NV = $9339;
  GL_WARPS_PER_SM_NV = $933A;
  GL_SM_COUNT_NV = $933B;
var
  GLAD_GL_NV_shader_thread_shuffle: boolean;
var
  GLAD_GL_NV_shading_rate_image: boolean;
const
  GL_SHADING_RATE_IMAGE_NV = $9563;
  GL_SHADING_RATE_NO_INVOCATIONS_NV = $9564;
  GL_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV = $9565;
  GL_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV = $9566;
  GL_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV = $9567;
  GL_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV = $9568;
  GL_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV = $9569;
  GL_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV = $956A;
  GL_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV = $956B;
  GL_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV = $956C;
  GL_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV = $956D;
  GL_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV = $956E;
  GL_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV = $956F;
  GL_SHADING_RATE_IMAGE_BINDING_NV = $955B;
  GL_SHADING_RATE_IMAGE_TEXEL_WIDTH_NV = $955C;
  GL_SHADING_RATE_IMAGE_TEXEL_HEIGHT_NV = $955D;
  GL_SHADING_RATE_IMAGE_PALETTE_SIZE_NV = $955E;
  GL_MAX_COARSE_FRAGMENT_SAMPLES_NV = $955F;
  GL_SHADING_RATE_SAMPLE_ORDER_DEFAULT_NV = $95AE;
  GL_SHADING_RATE_SAMPLE_ORDER_PIXEL_MAJOR_NV = $95AF;
  GL_SHADING_RATE_SAMPLE_ORDER_SAMPLE_MAJOR_NV = $95B0;
var
  GLAD_GL_NV_stereo_view_rendering: boolean;
var
  GLAD_GL_NV_tessellation_program5: boolean;
const
  GL_MAX_PROGRAM_PATCH_ATTRIBS_NV = $86D8;
  GL_TESS_CONTROL_PROGRAM_NV = $891E;
  GL_TESS_EVALUATION_PROGRAM_NV = $891F;
  GL_TESS_CONTROL_PROGRAM_PARAMETER_BUFFER_NV = $8C74;
  GL_TESS_EVALUATION_PROGRAM_PARAMETER_BUFFER_NV = $8C75;
var
  GLAD_GL_NV_texgen_emboss: boolean;
const
  GL_EMBOSS_LIGHT_NV = $855D;
  GL_EMBOSS_CONSTANT_NV = $855E;
  GL_EMBOSS_MAP_NV = $855F;
var
  GLAD_GL_NV_texgen_reflection: boolean;
const
  GL_NORMAL_MAP_NV = $8511;
  GL_REFLECTION_MAP_NV = $8512;
var
  GLAD_GL_NV_texture_barrier: boolean;
var
  GLAD_GL_NV_texture_compression_vtc: boolean;
var
  GLAD_GL_NV_texture_env_combine4: boolean;
const
  GL_COMBINE4_NV = $8503;
  GL_SOURCE3_RGB_NV = $8583;
  GL_SOURCE3_ALPHA_NV = $858B;
  GL_OPERAND3_RGB_NV = $8593;
  GL_OPERAND3_ALPHA_NV = $859B;
var
  GLAD_GL_NV_texture_expand_normal: boolean;
const
  GL_TEXTURE_UNSIGNED_REMAP_MODE_NV = $888F;
var
  GLAD_GL_NV_texture_multisample: boolean;
const
  GL_TEXTURE_COVERAGE_SAMPLES_NV = $9045;
  GL_TEXTURE_COLOR_SAMPLES_NV = $9046;
var
  GLAD_GL_NV_texture_rectangle: boolean;
const
  GL_TEXTURE_RECTANGLE_NV = $84F5;
  GL_TEXTURE_BINDING_RECTANGLE_NV = $84F6;
  GL_PROXY_TEXTURE_RECTANGLE_NV = $84F7;
  GL_MAX_RECTANGLE_TEXTURE_SIZE_NV = $84F8;
var
  GLAD_GL_NV_texture_rectangle_compressed: boolean;
var
  GLAD_GL_NV_texture_shader: boolean;
const
  GL_OFFSET_TEXTURE_RECTANGLE_NV = $864C;
  GL_OFFSET_TEXTURE_RECTANGLE_SCALE_NV = $864D;
  GL_DOT_PRODUCT_TEXTURE_RECTANGLE_NV = $864E;
  GL_RGBA_UNSIGNED_DOT_PRODUCT_MAPPING_NV = $86D9;
  GL_UNSIGNED_INT_S8_S8_8_8_NV = $86DA;
  GL_UNSIGNED_INT_8_8_S8_S8_REV_NV = $86DB;
  GL_DSDT_MAG_INTENSITY_NV = $86DC;
  GL_SHADER_CONSISTENT_NV = $86DD;
  GL_TEXTURE_SHADER_NV = $86DE;
  GL_SHADER_OPERATION_NV = $86DF;
  GL_CULL_MODES_NV = $86E0;
  GL_OFFSET_TEXTURE_MATRIX_NV = $86E1;
  GL_OFFSET_TEXTURE_SCALE_NV = $86E2;
  GL_OFFSET_TEXTURE_BIAS_NV = $86E3;
  GL_OFFSET_TEXTURE_2D_MATRIX_NV = $86E1;
  GL_OFFSET_TEXTURE_2D_SCALE_NV = $86E2;
  GL_OFFSET_TEXTURE_2D_BIAS_NV = $86E3;
  GL_PREVIOUS_TEXTURE_INPUT_NV = $86E4;
  GL_CONST_EYE_NV = $86E5;
  GL_PASS_THROUGH_NV = $86E6;
  GL_CULL_FRAGMENT_NV = $86E7;
  GL_OFFSET_TEXTURE_2D_NV = $86E8;
  GL_DEPENDENT_AR_TEXTURE_2D_NV = $86E9;
  GL_DEPENDENT_GB_TEXTURE_2D_NV = $86EA;
  GL_DOT_PRODUCT_NV = $86EC;
  GL_DOT_PRODUCT_DEPTH_REPLACE_NV = $86ED;
  GL_DOT_PRODUCT_TEXTURE_2D_NV = $86EE;
  GL_DOT_PRODUCT_TEXTURE_CUBE_MAP_NV = $86F0;
  GL_DOT_PRODUCT_DIFFUSE_CUBE_MAP_NV = $86F1;
  GL_DOT_PRODUCT_REFLECT_CUBE_MAP_NV = $86F2;
  GL_DOT_PRODUCT_CONST_EYE_REFLECT_CUBE_MAP_NV = $86F3;
  GL_HILO_NV = $86F4;
  GL_DSDT_NV = $86F5;
  GL_DSDT_MAG_NV = $86F6;
  GL_DSDT_MAG_VIB_NV = $86F7;
  GL_HILO16_NV = $86F8;
  GL_SIGNED_HILO_NV = $86F9;
  GL_SIGNED_HILO16_NV = $86FA;
  GL_SIGNED_RGBA_NV = $86FB;
  GL_SIGNED_RGBA8_NV = $86FC;
  GL_SIGNED_RGB_NV = $86FE;
  GL_SIGNED_RGB8_NV = $86FF;
  GL_SIGNED_LUMINANCE_NV = $8701;
  GL_SIGNED_LUMINANCE8_NV = $8702;
  GL_SIGNED_LUMINANCE_ALPHA_NV = $8703;
  GL_SIGNED_LUMINANCE8_ALPHA8_NV = $8704;
  GL_SIGNED_ALPHA_NV = $8705;
  GL_SIGNED_ALPHA8_NV = $8706;
  GL_SIGNED_INTENSITY_NV = $8707;
  GL_SIGNED_INTENSITY8_NV = $8708;
  GL_DSDT8_NV = $8709;
  GL_DSDT8_MAG8_NV = $870A;
  GL_DSDT8_MAG8_INTENSITY8_NV = $870B;
  GL_SIGNED_RGB_UNSIGNED_ALPHA_NV = $870C;
  GL_SIGNED_RGB8_UNSIGNED_ALPHA8_NV = $870D;
  GL_HI_SCALE_NV = $870E;
  GL_LO_SCALE_NV = $870F;
  GL_DS_SCALE_NV = $8710;
  GL_DT_SCALE_NV = $8711;
  GL_MAGNITUDE_SCALE_NV = $8712;
  GL_VIBRANCE_SCALE_NV = $8713;
  GL_HI_BIAS_NV = $8714;
  GL_LO_BIAS_NV = $8715;
  GL_DS_BIAS_NV = $8716;
  GL_DT_BIAS_NV = $8717;
  GL_MAGNITUDE_BIAS_NV = $8718;
  GL_VIBRANCE_BIAS_NV = $8719;
  GL_TEXTURE_BORDER_VALUES_NV = $871A;
  GL_TEXTURE_HI_SIZE_NV = $871B;
  GL_TEXTURE_LO_SIZE_NV = $871C;
  GL_TEXTURE_DS_SIZE_NV = $871D;
  GL_TEXTURE_DT_SIZE_NV = $871E;
  GL_TEXTURE_MAG_SIZE_NV = $871F;
var
  GLAD_GL_NV_texture_shader2: boolean;
const
  GL_DOT_PRODUCT_TEXTURE_3D_NV = $86EF;
var
  GLAD_GL_NV_texture_shader3: boolean;
const
  GL_OFFSET_PROJECTIVE_TEXTURE_2D_NV = $8850;
  GL_OFFSET_PROJECTIVE_TEXTURE_2D_SCALE_NV = $8851;
  GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_NV = $8852;
  GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_SCALE_NV = $8853;
  GL_OFFSET_HILO_TEXTURE_2D_NV = $8854;
  GL_OFFSET_HILO_TEXTURE_RECTANGLE_NV = $8855;
  GL_OFFSET_HILO_PROJECTIVE_TEXTURE_2D_NV = $8856;
  GL_OFFSET_HILO_PROJECTIVE_TEXTURE_RECTANGLE_NV = $8857;
  GL_DEPENDENT_HILO_TEXTURE_2D_NV = $8858;
  GL_DEPENDENT_RGB_TEXTURE_3D_NV = $8859;
  GL_DEPENDENT_RGB_TEXTURE_CUBE_MAP_NV = $885A;
  GL_DOT_PRODUCT_PASS_THROUGH_NV = $885B;
  GL_DOT_PRODUCT_TEXTURE_1D_NV = $885C;
  GL_DOT_PRODUCT_AFFINE_DEPTH_REPLACE_NV = $885D;
  GL_HILO8_NV = $885E;
  GL_SIGNED_HILO8_NV = $885F;
  GL_FORCE_BLUE_TO_ONE_NV = $8860;
var
  GLAD_GL_NV_timeline_semaphore: boolean;
const
  GL_TIMELINE_SEMAPHORE_VALUE_NV = $9595;
  GL_SEMAPHORE_TYPE_NV = $95B3;
  GL_SEMAPHORE_TYPE_BINARY_NV = $95B4;
  GL_SEMAPHORE_TYPE_TIMELINE_NV = $95B5;
  GL_MAX_TIMELINE_SEMAPHORE_VALUE_DIFFERENCE_NV = $95B6;
var
  GLAD_GL_NV_transform_feedback: boolean;
const
  GL_BACK_PRIMARY_COLOR_NV = $8C77;
  GL_BACK_SECONDARY_COLOR_NV = $8C78;
  GL_TEXTURE_COORD_NV = $8C79;
  GL_CLIP_DISTANCE_NV = $8C7A;
  GL_VERTEX_ID_NV = $8C7B;
  GL_PRIMITIVE_ID_NV = $8C7C;
  GL_GENERIC_ATTRIB_NV = $8C7D;
  GL_TRANSFORM_FEEDBACK_ATTRIBS_NV = $8C7E;
  GL_TRANSFORM_FEEDBACK_BUFFER_MODE_NV = $8C7F;
  GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS_NV = $8C80;
  GL_ACTIVE_VARYINGS_NV = $8C81;
  GL_ACTIVE_VARYING_MAX_LENGTH_NV = $8C82;
  GL_TRANSFORM_FEEDBACK_VARYINGS_NV = $8C83;
  GL_TRANSFORM_FEEDBACK_BUFFER_START_NV = $8C84;
  GL_TRANSFORM_FEEDBACK_BUFFER_SIZE_NV = $8C85;
  GL_TRANSFORM_FEEDBACK_RECORD_NV = $8C86;
  GL_PRIMITIVES_GENERATED_NV = $8C87;
  GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN_NV = $8C88;
  GL_RASTERIZER_DISCARD_NV = $8C89;
  GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS_NV = $8C8A;
  GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS_NV = $8C8B;
  GL_INTERLEAVED_ATTRIBS_NV = $8C8C;
  GL_SEPARATE_ATTRIBS_NV = $8C8D;
  GL_TRANSFORM_FEEDBACK_BUFFER_NV = $8C8E;
  GL_TRANSFORM_FEEDBACK_BUFFER_BINDING_NV = $8C8F;
  GL_LAYER_NV = $8DAA;
  GL_NEXT_BUFFER_NV = -2;
  GL_SKIP_COMPONENTS4_NV = -3;
  GL_SKIP_COMPONENTS3_NV = -4;
  GL_SKIP_COMPONENTS2_NV = -5;
  GL_SKIP_COMPONENTS1_NV = -6;
var
  GLAD_GL_NV_transform_feedback2: boolean;
const
  GL_TRANSFORM_FEEDBACK_NV = $8E22;
  GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED_NV = $8E23;
  GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE_NV = $8E24;
  GL_TRANSFORM_FEEDBACK_BINDING_NV = $8E25;
var
  GLAD_GL_NV_uniform_buffer_std430_layout: boolean;
var
  GLAD_GL_NV_uniform_buffer_unified_memory: boolean;
const
  GL_UNIFORM_BUFFER_UNIFIED_NV = $936E;
  GL_UNIFORM_BUFFER_ADDRESS_NV = $936F;
  GL_UNIFORM_BUFFER_LENGTH_NV = $9370;
var
  GLAD_GL_NV_vdpau_interop: boolean;
const
  GL_SURFACE_STATE_NV = $86EB;
  GL_SURFACE_REGISTERED_NV = $86FD;
  GL_SURFACE_MAPPED_NV = $8700;
  GL_WRITE_DISCARD_NV = $88BE;
var
  GLAD_GL_NV_vdpau_interop2: boolean;
var
  GLAD_GL_NV_vertex_array_range: boolean;
const
  GL_VERTEX_ARRAY_RANGE_NV = $851D;
  GL_VERTEX_ARRAY_RANGE_LENGTH_NV = $851E;
  GL_VERTEX_ARRAY_RANGE_VALID_NV = $851F;
  GL_MAX_VERTEX_ARRAY_RANGE_ELEMENT_NV = $8520;
  GL_VERTEX_ARRAY_RANGE_POINTER_NV = $8521;
var
  GLAD_GL_NV_vertex_array_range2: boolean;
const
  GL_VERTEX_ARRAY_RANGE_WITHOUT_FLUSH_NV = $8533;
var
  GLAD_GL_NV_vertex_attrib_integer_64bit: boolean;
var
  GLAD_GL_NV_vertex_buffer_unified_memory: boolean;
const
  GL_VERTEX_ATTRIB_ARRAY_UNIFIED_NV = $8F1E;
  GL_ELEMENT_ARRAY_UNIFIED_NV = $8F1F;
  GL_VERTEX_ATTRIB_ARRAY_ADDRESS_NV = $8F20;
  GL_VERTEX_ARRAY_ADDRESS_NV = $8F21;
  GL_NORMAL_ARRAY_ADDRESS_NV = $8F22;
  GL_COLOR_ARRAY_ADDRESS_NV = $8F23;
  GL_INDEX_ARRAY_ADDRESS_NV = $8F24;
  GL_TEXTURE_COORD_ARRAY_ADDRESS_NV = $8F25;
  GL_EDGE_FLAG_ARRAY_ADDRESS_NV = $8F26;
  GL_SECONDARY_COLOR_ARRAY_ADDRESS_NV = $8F27;
  GL_FOG_COORD_ARRAY_ADDRESS_NV = $8F28;
  GL_ELEMENT_ARRAY_ADDRESS_NV = $8F29;
  GL_VERTEX_ATTRIB_ARRAY_LENGTH_NV = $8F2A;
  GL_VERTEX_ARRAY_LENGTH_NV = $8F2B;
  GL_NORMAL_ARRAY_LENGTH_NV = $8F2C;
  GL_COLOR_ARRAY_LENGTH_NV = $8F2D;
  GL_INDEX_ARRAY_LENGTH_NV = $8F2E;
  GL_TEXTURE_COORD_ARRAY_LENGTH_NV = $8F2F;
  GL_EDGE_FLAG_ARRAY_LENGTH_NV = $8F30;
  GL_SECONDARY_COLOR_ARRAY_LENGTH_NV = $8F31;
  GL_FOG_COORD_ARRAY_LENGTH_NV = $8F32;
  GL_ELEMENT_ARRAY_LENGTH_NV = $8F33;
  GL_DRAW_INDIRECT_UNIFIED_NV = $8F40;
  GL_DRAW_INDIRECT_ADDRESS_NV = $8F41;
  GL_DRAW_INDIRECT_LENGTH_NV = $8F42;
var
  GLAD_GL_NV_vertex_program: boolean;
const
  GL_VERTEX_PROGRAM_NV = $8620;
  GL_VERTEX_STATE_PROGRAM_NV = $8621;
  GL_ATTRIB_ARRAY_SIZE_NV = $8623;
  GL_ATTRIB_ARRAY_STRIDE_NV = $8624;
  GL_ATTRIB_ARRAY_TYPE_NV = $8625;
  GL_CURRENT_ATTRIB_NV = $8626;
  GL_PROGRAM_LENGTH_NV = $8627;
  GL_PROGRAM_STRING_NV = $8628;
  GL_MODELVIEW_PROJECTION_NV = $8629;
  GL_IDENTITY_NV = $862A;
  GL_INVERSE_NV = $862B;
  GL_TRANSPOSE_NV = $862C;
  GL_INVERSE_TRANSPOSE_NV = $862D;
  GL_MAX_TRACK_MATRIX_STACK_DEPTH_NV = $862E;
  GL_MAX_TRACK_MATRICES_NV = $862F;
  GL_MATRIX0_NV = $8630;
  GL_MATRIX1_NV = $8631;
  GL_MATRIX2_NV = $8632;
  GL_MATRIX3_NV = $8633;
  GL_MATRIX4_NV = $8634;
  GL_MATRIX5_NV = $8635;
  GL_MATRIX6_NV = $8636;
  GL_MATRIX7_NV = $8637;
  GL_CURRENT_MATRIX_STACK_DEPTH_NV = $8640;
  GL_CURRENT_MATRIX_NV = $8641;
  GL_VERTEX_PROGRAM_POINT_SIZE_NV = $8642;
  GL_VERTEX_PROGRAM_TWO_SIDE_NV = $8643;
  GL_PROGRAM_PARAMETER_NV = $8644;
  GL_ATTRIB_ARRAY_POINTER_NV = $8645;
  GL_PROGRAM_TARGET_NV = $8646;
  GL_PROGRAM_RESIDENT_NV = $8647;
  GL_TRACK_MATRIX_NV = $8648;
  GL_TRACK_MATRIX_TRANSFORM_NV = $8649;
  GL_VERTEX_PROGRAM_BINDING_NV = $864A;
  GL_PROGRAM_ERROR_POSITION_NV = $864B;
  GL_VERTEX_ATTRIB_ARRAY0_NV = $8650;
  GL_VERTEX_ATTRIB_ARRAY1_NV = $8651;
  GL_VERTEX_ATTRIB_ARRAY2_NV = $8652;
  GL_VERTEX_ATTRIB_ARRAY3_NV = $8653;
  GL_VERTEX_ATTRIB_ARRAY4_NV = $8654;
  GL_VERTEX_ATTRIB_ARRAY5_NV = $8655;
  GL_VERTEX_ATTRIB_ARRAY6_NV = $8656;
  GL_VERTEX_ATTRIB_ARRAY7_NV = $8657;
  GL_VERTEX_ATTRIB_ARRAY8_NV = $8658;
  GL_VERTEX_ATTRIB_ARRAY9_NV = $8659;
  GL_VERTEX_ATTRIB_ARRAY10_NV = $865A;
  GL_VERTEX_ATTRIB_ARRAY11_NV = $865B;
  GL_VERTEX_ATTRIB_ARRAY12_NV = $865C;
  GL_VERTEX_ATTRIB_ARRAY13_NV = $865D;
  GL_VERTEX_ATTRIB_ARRAY14_NV = $865E;
  GL_VERTEX_ATTRIB_ARRAY15_NV = $865F;
  GL_MAP1_VERTEX_ATTRIB0_4_NV = $8660;
  GL_MAP1_VERTEX_ATTRIB1_4_NV = $8661;
  GL_MAP1_VERTEX_ATTRIB2_4_NV = $8662;
  GL_MAP1_VERTEX_ATTRIB3_4_NV = $8663;
  GL_MAP1_VERTEX_ATTRIB4_4_NV = $8664;
  GL_MAP1_VERTEX_ATTRIB5_4_NV = $8665;
  GL_MAP1_VERTEX_ATTRIB6_4_NV = $8666;
  GL_MAP1_VERTEX_ATTRIB7_4_NV = $8667;
  GL_MAP1_VERTEX_ATTRIB8_4_NV = $8668;
  GL_MAP1_VERTEX_ATTRIB9_4_NV = $8669;
  GL_MAP1_VERTEX_ATTRIB10_4_NV = $866A;
  GL_MAP1_VERTEX_ATTRIB11_4_NV = $866B;
  GL_MAP1_VERTEX_ATTRIB12_4_NV = $866C;
  GL_MAP1_VERTEX_ATTRIB13_4_NV = $866D;
  GL_MAP1_VERTEX_ATTRIB14_4_NV = $866E;
  GL_MAP1_VERTEX_ATTRIB15_4_NV = $866F;
  GL_MAP2_VERTEX_ATTRIB0_4_NV = $8670;
  GL_MAP2_VERTEX_ATTRIB1_4_NV = $8671;
  GL_MAP2_VERTEX_ATTRIB2_4_NV = $8672;
  GL_MAP2_VERTEX_ATTRIB3_4_NV = $8673;
  GL_MAP2_VERTEX_ATTRIB4_4_NV = $8674;
  GL_MAP2_VERTEX_ATTRIB5_4_NV = $8675;
  GL_MAP2_VERTEX_ATTRIB6_4_NV = $8676;
  GL_MAP2_VERTEX_ATTRIB7_4_NV = $8677;
  GL_MAP2_VERTEX_ATTRIB8_4_NV = $8678;
  GL_MAP2_VERTEX_ATTRIB9_4_NV = $8679;
  GL_MAP2_VERTEX_ATTRIB10_4_NV = $867A;
  GL_MAP2_VERTEX_ATTRIB11_4_NV = $867B;
  GL_MAP2_VERTEX_ATTRIB12_4_NV = $867C;
  GL_MAP2_VERTEX_ATTRIB13_4_NV = $867D;
  GL_MAP2_VERTEX_ATTRIB14_4_NV = $867E;
  GL_MAP2_VERTEX_ATTRIB15_4_NV = $867F;
var
  GLAD_GL_NV_vertex_program1_1: boolean;
var
  GLAD_GL_NV_vertex_program2: boolean;
var
  GLAD_GL_NV_vertex_program2_option: boolean;
var
  GLAD_GL_NV_vertex_program3: boolean;
var
  GLAD_GL_NV_vertex_program4: boolean;
const
  GL_VERTEX_ATTRIB_ARRAY_INTEGER_NV = $88FD;
var
  GLAD_GL_NV_video_capture: boolean;
const
  GL_VIDEO_BUFFER_NV = $9020;
  GL_VIDEO_BUFFER_BINDING_NV = $9021;
  GL_FIELD_UPPER_NV = $9022;
  GL_FIELD_LOWER_NV = $9023;
  GL_NUM_VIDEO_CAPTURE_STREAMS_NV = $9024;
  GL_NEXT_VIDEO_CAPTURE_BUFFER_STATUS_NV = $9025;
  GL_VIDEO_CAPTURE_TO_422_SUPPORTED_NV = $9026;
  GL_LAST_VIDEO_CAPTURE_STATUS_NV = $9027;
  GL_VIDEO_BUFFER_PITCH_NV = $9028;
  GL_VIDEO_COLOR_CONVERSION_MATRIX_NV = $9029;
  GL_VIDEO_COLOR_CONVERSION_MAX_NV = $902A;
  GL_VIDEO_COLOR_CONVERSION_MIN_NV = $902B;
  GL_VIDEO_COLOR_CONVERSION_OFFSET_NV = $902C;
  GL_VIDEO_BUFFER_INTERNAL_FORMAT_NV = $902D;
  GL_PARTIAL_SUCCESS_NV = $902E;
  GL_SUCCESS_NV = $902F;
  GL_FAILURE_NV = $9030;
  GL_YCBYCR8_422_NV = $9031;
  GL_YCBAYCR8A_4224_NV = $9032;
  GL_Z6Y10Z6CB10Z6Y10Z6CR10_422_NV = $9033;
  GL_Z6Y10Z6CB10Z6A10Z6Y10Z6CR10Z6A10_4224_NV = $9034;
  GL_Z4Y12Z4CB12Z4Y12Z4CR12_422_NV = $9035;
  GL_Z4Y12Z4CB12Z4A12Z4Y12Z4CR12Z4A12_4224_NV = $9036;
  GL_Z4Y12Z4CB12Z4CR12_444_NV = $9037;
  GL_VIDEO_CAPTURE_FRAME_WIDTH_NV = $9038;
  GL_VIDEO_CAPTURE_FRAME_HEIGHT_NV = $9039;
  GL_VIDEO_CAPTURE_FIELD_UPPER_HEIGHT_NV = $903A;
  GL_VIDEO_CAPTURE_FIELD_LOWER_HEIGHT_NV = $903B;
  GL_VIDEO_CAPTURE_SURFACE_ORIGIN_NV = $903C;
var
  GLAD_GL_NV_viewport_array2: boolean;
var
  GLAD_GL_NV_viewport_swizzle: boolean;
const
  GL_VIEWPORT_SWIZZLE_POSITIVE_X_NV = $9350;
  GL_VIEWPORT_SWIZZLE_NEGATIVE_X_NV = $9351;
  GL_VIEWPORT_SWIZZLE_POSITIVE_Y_NV = $9352;
  GL_VIEWPORT_SWIZZLE_NEGATIVE_Y_NV = $9353;
  GL_VIEWPORT_SWIZZLE_POSITIVE_Z_NV = $9354;
  GL_VIEWPORT_SWIZZLE_NEGATIVE_Z_NV = $9355;
  GL_VIEWPORT_SWIZZLE_POSITIVE_W_NV = $9356;
  GL_VIEWPORT_SWIZZLE_NEGATIVE_W_NV = $9357;
  GL_VIEWPORT_SWIZZLE_X_NV = $9358;
  GL_VIEWPORT_SWIZZLE_Y_NV = $9359;
  GL_VIEWPORT_SWIZZLE_Z_NV = $935A;
  GL_VIEWPORT_SWIZZLE_W_NV = $935B;
var
  GLAD_GL_OES_byte_coordinates: boolean;
var
  GLAD_GL_OES_compressed_paletted_texture: boolean;
const
  GL_PALETTE4_RGB8_OES = $8B90;
  GL_PALETTE4_RGBA8_OES = $8B91;
  GL_PALETTE4_R5_G6_B5_OES = $8B92;
  GL_PALETTE4_RGBA4_OES = $8B93;
  GL_PALETTE4_RGB5_A1_OES = $8B94;
  GL_PALETTE8_RGB8_OES = $8B95;
  GL_PALETTE8_RGBA8_OES = $8B96;
  GL_PALETTE8_R5_G6_B5_OES = $8B97;
  GL_PALETTE8_RGBA4_OES = $8B98;
  GL_PALETTE8_RGB5_A1_OES = $8B99;
var
  GLAD_GL_OES_fixed_point: boolean;
const
  GL_FIXED_OES = $140C;
var
  GLAD_GL_OES_query_matrix: boolean;
var
  GLAD_GL_OES_read_format: boolean;
const
  GL_IMPLEMENTATION_COLOR_READ_TYPE_OES = $8B9A;
  GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES = $8B9B;
var
  GLAD_GL_OES_single_precision: boolean;
var
  GLAD_GL_OML_interlace: boolean;
const
  GL_INTERLACE_OML = $8980;
  GL_INTERLACE_READ_OML = $8981;
var
  GLAD_GL_OML_resample: boolean;
const
  GL_PACK_RESAMPLE_OML = $8984;
  GL_UNPACK_RESAMPLE_OML = $8985;
  GL_RESAMPLE_REPLICATE_OML = $8986;
  GL_RESAMPLE_ZERO_FILL_OML = $8987;
  GL_RESAMPLE_AVERAGE_OML = $8988;
  GL_RESAMPLE_DECIMATE_OML = $8989;
var
  GLAD_GL_OML_subsample: boolean;
const
  GL_FORMAT_SUBSAMPLE_24_24_OML = $8982;
  GL_FORMAT_SUBSAMPLE_244_244_OML = $8983;
var
  GLAD_GL_OVR_multiview: boolean;
const
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_NUM_VIEWS_OVR = $9630;
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_BASE_VIEW_INDEX_OVR = $9632;
  GL_MAX_VIEWS_OVR = $9631;
  GL_FRAMEBUFFER_INCOMPLETE_VIEW_TARGETS_OVR = $9633;
var
  GLAD_GL_OVR_multiview2: boolean;
var
  GLAD_GL_PGI_misc_hints: boolean;
const
  GL_PREFER_DOUBLEBUFFER_HINT_PGI = $1A1F8;
  GL_CONSERVE_MEMORY_HINT_PGI = $1A1FD;
  GL_RECLAIM_MEMORY_HINT_PGI = $1A1FE;
  GL_NATIVE_GRAPHICS_HANDLE_PGI = $1A202;
  GL_NATIVE_GRAPHICS_BEGIN_HINT_PGI = $1A203;
  GL_NATIVE_GRAPHICS_END_HINT_PGI = $1A204;
  GL_ALWAYS_FAST_HINT_PGI = $1A20C;
  GL_ALWAYS_SOFT_HINT_PGI = $1A20D;
  GL_ALLOW_DRAW_OBJ_HINT_PGI = $1A20E;
  GL_ALLOW_DRAW_WIN_HINT_PGI = $1A20F;
  GL_ALLOW_DRAW_FRG_HINT_PGI = $1A210;
  GL_ALLOW_DRAW_MEM_HINT_PGI = $1A211;
  GL_STRICT_DEPTHFUNC_HINT_PGI = $1A216;
  GL_STRICT_LIGHTING_HINT_PGI = $1A217;
  GL_STRICT_SCISSOR_HINT_PGI = $1A218;
  GL_FULL_STIPPLE_HINT_PGI = $1A219;
  GL_CLIP_NEAR_HINT_PGI = $1A220;
  GL_CLIP_FAR_HINT_PGI = $1A221;
  GL_WIDE_LINE_HINT_PGI = $1A222;
  GL_BACK_NORMALS_HINT_PGI = $1A223;
var
  GLAD_GL_PGI_vertex_hints: boolean;
const
  GL_VERTEX_DATA_HINT_PGI = $1A22A;
  GL_VERTEX_CONSISTENT_HINT_PGI = $1A22B;
  GL_MATERIAL_SIDE_HINT_PGI = $1A22C;
  GL_MAX_VERTEX_HINT_PGI = $1A22D;
  GL_COLOR3_BIT_PGI = $00010000;
  GL_COLOR4_BIT_PGI = $00020000;
  GL_EDGEFLAG_BIT_PGI = $00040000;
  GL_INDEX_BIT_PGI = $00080000;
  GL_MAT_AMBIENT_BIT_PGI = $00100000;
  GL_MAT_AMBIENT_AND_DIFFUSE_BIT_PGI = $00200000;
  GL_MAT_DIFFUSE_BIT_PGI = $00400000;
  GL_MAT_EMISSION_BIT_PGI = $00800000;
  GL_MAT_COLOR_INDEXES_BIT_PGI = $01000000;
  GL_MAT_SHININESS_BIT_PGI = $02000000;
  GL_MAT_SPECULAR_BIT_PGI = $04000000;
  GL_NORMAL_BIT_PGI = $08000000;
  GL_TEXCOORD1_BIT_PGI = $10000000;
  GL_TEXCOORD2_BIT_PGI = $20000000;
  GL_TEXCOORD3_BIT_PGI = $40000000;
  GL_TEXCOORD4_BIT_PGI = $80000000;
  GL_VERTEX23_BIT_PGI = $00000004;
  GL_VERTEX4_BIT_PGI = $00000008;
var
  GLAD_GL_REND_screen_coordinates: boolean;
const
  GL_SCREEN_COORDINATES_REND = $8490;
  GL_INVERTED_SCREEN_W_REND = $8491;
var
  GLAD_GL_S3_s3tc: boolean;
const
  GL_RGB_S3TC = $83A0;
  GL_RGB4_S3TC = $83A1;
  GL_RGBA_S3TC = $83A2;
  GL_RGBA4_S3TC = $83A3;
  GL_RGBA_DXT5_S3TC = $83A4;
  GL_RGBA4_DXT5_S3TC = $83A5;
var
  GLAD_GL_SGIS_detail_texture: boolean;
const
  GL_DETAIL_TEXTURE_2D_SGIS = $8095;
  GL_DETAIL_TEXTURE_2D_BINDING_SGIS = $8096;
  GL_LINEAR_DETAIL_SGIS = $8097;
  GL_LINEAR_DETAIL_ALPHA_SGIS = $8098;
  GL_LINEAR_DETAIL_COLOR_SGIS = $8099;
  GL_DETAIL_TEXTURE_LEVEL_SGIS = $809A;
  GL_DETAIL_TEXTURE_MODE_SGIS = $809B;
  GL_DETAIL_TEXTURE_FUNC_POINTS_SGIS = $809C;
var
  GLAD_GL_SGIS_fog_function: boolean;
const
  GL_FOG_FUNC_SGIS = $812A;
  GL_FOG_FUNC_POINTS_SGIS = $812B;
  GL_MAX_FOG_FUNC_POINTS_SGIS = $812C;
var
  GLAD_GL_SGIS_generate_mipmap: boolean;
const
  GL_GENERATE_MIPMAP_SGIS = $8191;
  GL_GENERATE_MIPMAP_HINT_SGIS = $8192;
var
  GLAD_GL_SGIS_multisample: boolean;
const
  GL_MULTISAMPLE_SGIS = $809D;
  GL_SAMPLE_ALPHA_TO_MASK_SGIS = $809E;
  GL_SAMPLE_ALPHA_TO_ONE_SGIS = $809F;
  GL_SAMPLE_MASK_SGIS = $80A0;
  GL_1PASS_SGIS = $80A1;
  GL_2PASS_0_SGIS = $80A2;
  GL_2PASS_1_SGIS = $80A3;
  GL_4PASS_0_SGIS = $80A4;
  GL_4PASS_1_SGIS = $80A5;
  GL_4PASS_2_SGIS = $80A6;
  GL_4PASS_3_SGIS = $80A7;
  GL_SAMPLE_BUFFERS_SGIS = $80A8;
  GL_SAMPLES_SGIS = $80A9;
  GL_SAMPLE_MASK_VALUE_SGIS = $80AA;
  GL_SAMPLE_MASK_INVERT_SGIS = $80AB;
  GL_SAMPLE_PATTERN_SGIS = $80AC;
var
  GLAD_GL_SGIS_pixel_texture: boolean;
const
  GL_PIXEL_TEXTURE_SGIS = $8353;
  GL_PIXEL_FRAGMENT_RGB_SOURCE_SGIS = $8354;
  GL_PIXEL_FRAGMENT_ALPHA_SOURCE_SGIS = $8355;
  GL_PIXEL_GROUP_COLOR_SGIS = $8356;
var
  GLAD_GL_SGIS_point_line_texgen: boolean;
const
  GL_EYE_DISTANCE_TO_POINT_SGIS = $81F0;
  GL_OBJECT_DISTANCE_TO_POINT_SGIS = $81F1;
  GL_EYE_DISTANCE_TO_LINE_SGIS = $81F2;
  GL_OBJECT_DISTANCE_TO_LINE_SGIS = $81F3;
  GL_EYE_POINT_SGIS = $81F4;
  GL_OBJECT_POINT_SGIS = $81F5;
  GL_EYE_LINE_SGIS = $81F6;
  GL_OBJECT_LINE_SGIS = $81F7;
var
  GLAD_GL_SGIS_point_parameters: boolean;
const
  GL_POINT_SIZE_MIN_SGIS = $8126;
  GL_POINT_SIZE_MAX_SGIS = $8127;
  GL_POINT_FADE_THRESHOLD_SIZE_SGIS = $8128;
  GL_DISTANCE_ATTENUATION_SGIS = $8129;
var
  GLAD_GL_SGIS_sharpen_texture: boolean;
const
  GL_LINEAR_SHARPEN_SGIS = $80AD;
  GL_LINEAR_SHARPEN_ALPHA_SGIS = $80AE;
  GL_LINEAR_SHARPEN_COLOR_SGIS = $80AF;
  GL_SHARPEN_TEXTURE_FUNC_POINTS_SGIS = $80B0;
var
  GLAD_GL_SGIS_texture4D: boolean;
const
  GL_PACK_SKIP_VOLUMES_SGIS = $8130;
  GL_PACK_IMAGE_DEPTH_SGIS = $8131;
  GL_UNPACK_SKIP_VOLUMES_SGIS = $8132;
  GL_UNPACK_IMAGE_DEPTH_SGIS = $8133;
  GL_TEXTURE_4D_SGIS = $8134;
  GL_PROXY_TEXTURE_4D_SGIS = $8135;
  GL_TEXTURE_4DSIZE_SGIS = $8136;
  GL_TEXTURE_WRAP_Q_SGIS = $8137;
  GL_MAX_4D_TEXTURE_SIZE_SGIS = $8138;
  GL_TEXTURE_4D_BINDING_SGIS = $814F;
var
  GLAD_GL_SGIS_texture_border_clamp: boolean;
const
  GL_CLAMP_TO_BORDER_SGIS = $812D;
var
  GLAD_GL_SGIS_texture_color_mask: boolean;
const
  GL_TEXTURE_COLOR_WRITEMASK_SGIS = $81EF;
var
  GLAD_GL_SGIS_texture_edge_clamp: boolean;
const
  GL_CLAMP_TO_EDGE_SGIS = $812F;
var
  GLAD_GL_SGIS_texture_filter4: boolean;
const
  GL_FILTER4_SGIS = $8146;
  GL_TEXTURE_FILTER4_SIZE_SGIS = $8147;
var
  GLAD_GL_SGIS_texture_lod: boolean;
const
  GL_TEXTURE_MIN_LOD_SGIS = $813A;
  GL_TEXTURE_MAX_LOD_SGIS = $813B;
  GL_TEXTURE_BASE_LEVEL_SGIS = $813C;
  GL_TEXTURE_MAX_LEVEL_SGIS = $813D;
var
  GLAD_GL_SGIS_texture_select: boolean;
const
  GL_DUAL_ALPHA4_SGIS = $8110;
  GL_DUAL_ALPHA8_SGIS = $8111;
  GL_DUAL_ALPHA12_SGIS = $8112;
  GL_DUAL_ALPHA16_SGIS = $8113;
  GL_DUAL_LUMINANCE4_SGIS = $8114;
  GL_DUAL_LUMINANCE8_SGIS = $8115;
  GL_DUAL_LUMINANCE12_SGIS = $8116;
  GL_DUAL_LUMINANCE16_SGIS = $8117;
  GL_DUAL_INTENSITY4_SGIS = $8118;
  GL_DUAL_INTENSITY8_SGIS = $8119;
  GL_DUAL_INTENSITY12_SGIS = $811A;
  GL_DUAL_INTENSITY16_SGIS = $811B;
  GL_DUAL_LUMINANCE_ALPHA4_SGIS = $811C;
  GL_DUAL_LUMINANCE_ALPHA8_SGIS = $811D;
  GL_QUAD_ALPHA4_SGIS = $811E;
  GL_QUAD_ALPHA8_SGIS = $811F;
  GL_QUAD_LUMINANCE4_SGIS = $8120;
  GL_QUAD_LUMINANCE8_SGIS = $8121;
  GL_QUAD_INTENSITY4_SGIS = $8122;
  GL_QUAD_INTENSITY8_SGIS = $8123;
  GL_DUAL_TEXTURE_SELECT_SGIS = $8124;
  GL_QUAD_TEXTURE_SELECT_SGIS = $8125;
var
  GLAD_GL_SGIX_async: boolean;
const
  GL_ASYNC_MARKER_SGIX = $8329;
var
  GLAD_GL_SGIX_async_histogram: boolean;
const
  GL_ASYNC_HISTOGRAM_SGIX = $832C;
  GL_MAX_ASYNC_HISTOGRAM_SGIX = $832D;
var
  GLAD_GL_SGIX_async_pixel: boolean;
const
  GL_ASYNC_TEX_IMAGE_SGIX = $835C;
  GL_ASYNC_DRAW_PIXELS_SGIX = $835D;
  GL_ASYNC_READ_PIXELS_SGIX = $835E;
  GL_MAX_ASYNC_TEX_IMAGE_SGIX = $835F;
  GL_MAX_ASYNC_DRAW_PIXELS_SGIX = $8360;
  GL_MAX_ASYNC_READ_PIXELS_SGIX = $8361;
var
  GLAD_GL_SGIX_blend_alpha_minmax: boolean;
const
  GL_ALPHA_MIN_SGIX = $8320;
  GL_ALPHA_MAX_SGIX = $8321;
var
  GLAD_GL_SGIX_calligraphic_fragment: boolean;
const
  GL_CALLIGRAPHIC_FRAGMENT_SGIX = $8183;
var
  GLAD_GL_SGIX_clipmap: boolean;
const
  GL_LINEAR_CLIPMAP_LINEAR_SGIX = $8170;
  GL_TEXTURE_CLIPMAP_CENTER_SGIX = $8171;
  GL_TEXTURE_CLIPMAP_FRAME_SGIX = $8172;
  GL_TEXTURE_CLIPMAP_OFFSET_SGIX = $8173;
  GL_TEXTURE_CLIPMAP_VIRTUAL_DEPTH_SGIX = $8174;
  GL_TEXTURE_CLIPMAP_LOD_OFFSET_SGIX = $8175;
  GL_TEXTURE_CLIPMAP_DEPTH_SGIX = $8176;
  GL_MAX_CLIPMAP_DEPTH_SGIX = $8177;
  GL_MAX_CLIPMAP_VIRTUAL_DEPTH_SGIX = $8178;
  GL_NEAREST_CLIPMAP_NEAREST_SGIX = $844D;
  GL_NEAREST_CLIPMAP_LINEAR_SGIX = $844E;
  GL_LINEAR_CLIPMAP_NEAREST_SGIX = $844F;
var
  GLAD_GL_SGIX_convolution_accuracy: boolean;
const
  GL_CONVOLUTION_HINT_SGIX = $8316;
var
  GLAD_GL_SGIX_depth_pass_instrument: boolean;
var
  GLAD_GL_SGIX_depth_texture: boolean;
const
  GL_DEPTH_COMPONENT16_SGIX = $81A5;
  GL_DEPTH_COMPONENT24_SGIX = $81A6;
  GL_DEPTH_COMPONENT32_SGIX = $81A7;
var
  GLAD_GL_SGIX_flush_raster: boolean;
var
  GLAD_GL_SGIX_fog_offset: boolean;
const
  GL_FOG_OFFSET_SGIX = $8198;
  GL_FOG_OFFSET_VALUE_SGIX = $8199;
var
  GLAD_GL_SGIX_fragment_lighting: boolean;
const
  GL_FRAGMENT_LIGHTING_SGIX = $8400;
  GL_FRAGMENT_COLOR_MATERIAL_SGIX = $8401;
  GL_FRAGMENT_COLOR_MATERIAL_FACE_SGIX = $8402;
  GL_FRAGMENT_COLOR_MATERIAL_PARAMETER_SGIX = $8403;
  GL_MAX_FRAGMENT_LIGHTS_SGIX = $8404;
  GL_MAX_ACTIVE_LIGHTS_SGIX = $8405;
  GL_CURRENT_RASTER_NORMAL_SGIX = $8406;
  GL_LIGHT_ENV_MODE_SGIX = $8407;
  GL_FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER_SGIX = $8408;
  GL_FRAGMENT_LIGHT_MODEL_TWO_SIDE_SGIX = $8409;
  GL_FRAGMENT_LIGHT_MODEL_AMBIENT_SGIX = $840A;
  GL_FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION_SGIX = $840B;
  GL_FRAGMENT_LIGHT0_SGIX = $840C;
  GL_FRAGMENT_LIGHT1_SGIX = $840D;
  GL_FRAGMENT_LIGHT2_SGIX = $840E;
  GL_FRAGMENT_LIGHT3_SGIX = $840F;
  GL_FRAGMENT_LIGHT4_SGIX = $8410;
  GL_FRAGMENT_LIGHT5_SGIX = $8411;
  GL_FRAGMENT_LIGHT6_SGIX = $8412;
  GL_FRAGMENT_LIGHT7_SGIX = $8413;
var
  GLAD_GL_SGIX_framezoom: boolean;
const
  GL_FRAMEZOOM_SGIX = $818B;
  GL_FRAMEZOOM_FACTOR_SGIX = $818C;
  GL_MAX_FRAMEZOOM_FACTOR_SGIX = $818D;
var
  GLAD_GL_SGIX_igloo_interface: boolean;
var
  GLAD_GL_SGIX_instruments: boolean;
const
  GL_INSTRUMENT_BUFFER_POINTER_SGIX = $8180;
  GL_INSTRUMENT_MEASUREMENTS_SGIX = $8181;
var
  GLAD_GL_SGIX_interlace: boolean;
const
  GL_INTERLACE_SGIX = $8094;
var
  GLAD_GL_SGIX_ir_instrument1: boolean;
const
  GL_IR_INSTRUMENT1_SGIX = $817F;
var
  GLAD_GL_SGIX_list_priority: boolean;
const
  GL_LIST_PRIORITY_SGIX = $8182;
var
  GLAD_GL_SGIX_pixel_texture: boolean;
const
  GL_PIXEL_TEX_GEN_SGIX = $8139;
  GL_PIXEL_TEX_GEN_MODE_SGIX = $832B;
var
  GLAD_GL_SGIX_pixel_tiles: boolean;
const
  GL_PIXEL_TILE_BEST_ALIGNMENT_SGIX = $813E;
  GL_PIXEL_TILE_CACHE_INCREMENT_SGIX = $813F;
  GL_PIXEL_TILE_WIDTH_SGIX = $8140;
  GL_PIXEL_TILE_HEIGHT_SGIX = $8141;
  GL_PIXEL_TILE_GRID_WIDTH_SGIX = $8142;
  GL_PIXEL_TILE_GRID_HEIGHT_SGIX = $8143;
  GL_PIXEL_TILE_GRID_DEPTH_SGIX = $8144;
  GL_PIXEL_TILE_CACHE_SIZE_SGIX = $8145;
var
  GLAD_GL_SGIX_polynomial_ffd: boolean;
const
  GL_TEXTURE_DEFORMATION_BIT_SGIX = $00000001;
  GL_GEOMETRY_DEFORMATION_BIT_SGIX = $00000002;
  GL_GEOMETRY_DEFORMATION_SGIX = $8194;
  GL_TEXTURE_DEFORMATION_SGIX = $8195;
  GL_DEFORMATIONS_MASK_SGIX = $8196;
  GL_MAX_DEFORMATION_ORDER_SGIX = $8197;
var
  GLAD_GL_SGIX_reference_plane: boolean;
const
  GL_REFERENCE_PLANE_SGIX = $817D;
  GL_REFERENCE_PLANE_EQUATION_SGIX = $817E;
var
  GLAD_GL_SGIX_resample: boolean;
const
  GL_PACK_RESAMPLE_SGIX = $842E;
  GL_UNPACK_RESAMPLE_SGIX = $842F;
  GL_RESAMPLE_REPLICATE_SGIX = $8433;
  GL_RESAMPLE_ZERO_FILL_SGIX = $8434;
  GL_RESAMPLE_DECIMATE_SGIX = $8430;
var
  GLAD_GL_SGIX_scalebias_hint: boolean;
const
  GL_SCALEBIAS_HINT_SGIX = $8322;
var
  GLAD_GL_SGIX_shadow: boolean;
const
  GL_TEXTURE_COMPARE_SGIX = $819A;
  GL_TEXTURE_COMPARE_OPERATOR_SGIX = $819B;
  GL_TEXTURE_LEQUAL_R_SGIX = $819C;
  GL_TEXTURE_GEQUAL_R_SGIX = $819D;
var
  GLAD_GL_SGIX_shadow_ambient: boolean;
const
  GL_SHADOW_AMBIENT_SGIX = $80BF;
var
  GLAD_GL_SGIX_sprite: boolean;
const
  GL_SPRITE_SGIX = $8148;
  GL_SPRITE_MODE_SGIX = $8149;
  GL_SPRITE_AXIS_SGIX = $814A;
  GL_SPRITE_TRANSLATION_SGIX = $814B;
  GL_SPRITE_AXIAL_SGIX = $814C;
  GL_SPRITE_OBJECT_ALIGNED_SGIX = $814D;
  GL_SPRITE_EYE_ALIGNED_SGIX = $814E;
var
  GLAD_GL_SGIX_subsample: boolean;
const
  GL_PACK_SUBSAMPLE_RATE_SGIX = $85A0;
  GL_UNPACK_SUBSAMPLE_RATE_SGIX = $85A1;
  GL_PIXEL_SUBSAMPLE_4444_SGIX = $85A2;
  GL_PIXEL_SUBSAMPLE_2424_SGIX = $85A3;
  GL_PIXEL_SUBSAMPLE_4242_SGIX = $85A4;
var
  GLAD_GL_SGIX_tag_sample_buffer: boolean;
var
  GLAD_GL_SGIX_texture_add_env: boolean;
const
  GL_TEXTURE_ENV_BIAS_SGIX = $80BE;
var
  GLAD_GL_SGIX_texture_coordinate_clamp: boolean;
const
  GL_TEXTURE_MAX_CLAMP_S_SGIX = $8369;
  GL_TEXTURE_MAX_CLAMP_T_SGIX = $836A;
  GL_TEXTURE_MAX_CLAMP_R_SGIX = $836B;
var
  GLAD_GL_SGIX_texture_lod_bias: boolean;
const
  GL_TEXTURE_LOD_BIAS_S_SGIX = $818E;
  GL_TEXTURE_LOD_BIAS_T_SGIX = $818F;
  GL_TEXTURE_LOD_BIAS_R_SGIX = $8190;
var
  GLAD_GL_SGIX_texture_multi_buffer: boolean;
const
  GL_TEXTURE_MULTI_BUFFER_HINT_SGIX = $812E;
var
  GLAD_GL_SGIX_texture_scale_bias: boolean;
const
  GL_POST_TEXTURE_FILTER_BIAS_SGIX = $8179;
  GL_POST_TEXTURE_FILTER_SCALE_SGIX = $817A;
  GL_POST_TEXTURE_FILTER_BIAS_RANGE_SGIX = $817B;
  GL_POST_TEXTURE_FILTER_SCALE_RANGE_SGIX = $817C;
var
  GLAD_GL_SGIX_vertex_preclip: boolean;
const
  GL_VERTEX_PRECLIP_SGIX = $83EE;
  GL_VERTEX_PRECLIP_HINT_SGIX = $83EF;
var
  GLAD_GL_SGIX_ycrcb: boolean;
const
  GL_YCRCB_422_SGIX = $81BB;
  GL_YCRCB_444_SGIX = $81BC;
var
  GLAD_GL_SGIX_ycrcb_subsample: boolean;
var
  GLAD_GL_SGIX_ycrcba: boolean;
const
  GL_YCRCB_SGIX = $8318;
  GL_YCRCBA_SGIX = $8319;
var
  GLAD_GL_SGI_color_matrix: boolean;
const
  GL_COLOR_MATRIX_SGI = $80B1;
  GL_COLOR_MATRIX_STACK_DEPTH_SGI = $80B2;
  GL_MAX_COLOR_MATRIX_STACK_DEPTH_SGI = $80B3;
  GL_POST_COLOR_MATRIX_RED_SCALE_SGI = $80B4;
  GL_POST_COLOR_MATRIX_GREEN_SCALE_SGI = $80B5;
  GL_POST_COLOR_MATRIX_BLUE_SCALE_SGI = $80B6;
  GL_POST_COLOR_MATRIX_ALPHA_SCALE_SGI = $80B7;
  GL_POST_COLOR_MATRIX_RED_BIAS_SGI = $80B8;
  GL_POST_COLOR_MATRIX_GREEN_BIAS_SGI = $80B9;
  GL_POST_COLOR_MATRIX_BLUE_BIAS_SGI = $80BA;
  GL_POST_COLOR_MATRIX_ALPHA_BIAS_SGI = $80BB;
var
  GLAD_GL_SGI_color_table: boolean;
const
  GL_COLOR_TABLE_SGI = $80D0;
  GL_POST_CONVOLUTION_COLOR_TABLE_SGI = $80D1;
  GL_POST_COLOR_MATRIX_COLOR_TABLE_SGI = $80D2;
  GL_PROXY_COLOR_TABLE_SGI = $80D3;
  GL_PROXY_POST_CONVOLUTION_COLOR_TABLE_SGI = $80D4;
  GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE_SGI = $80D5;
  GL_COLOR_TABLE_SCALE_SGI = $80D6;
  GL_COLOR_TABLE_BIAS_SGI = $80D7;
  GL_COLOR_TABLE_FORMAT_SGI = $80D8;
  GL_COLOR_TABLE_WIDTH_SGI = $80D9;
  GL_COLOR_TABLE_RED_SIZE_SGI = $80DA;
  GL_COLOR_TABLE_GREEN_SIZE_SGI = $80DB;
  GL_COLOR_TABLE_BLUE_SIZE_SGI = $80DC;
  GL_COLOR_TABLE_ALPHA_SIZE_SGI = $80DD;
  GL_COLOR_TABLE_LUMINANCE_SIZE_SGI = $80DE;
  GL_COLOR_TABLE_INTENSITY_SIZE_SGI = $80DF;
var
  GLAD_GL_SGI_texture_color_table: boolean;
const
  GL_TEXTURE_COLOR_TABLE_SGI = $80BC;
  GL_PROXY_TEXTURE_COLOR_TABLE_SGI = $80BD;
var
  GLAD_GL_SUNX_constant_data: boolean;
const
  GL_UNPACK_CONSTANT_DATA_SUNX = $81D5;
  GL_TEXTURE_CONSTANT_DATA_SUNX = $81D6;
var
  GLAD_GL_SUN_convolution_border_modes: boolean;
const
  GL_WRAP_BORDER_SUN = $81D4;
var
  GLAD_GL_SUN_global_alpha: boolean;
const
  GL_GLOBAL_ALPHA_SUN = $81D9;
  GL_GLOBAL_ALPHA_FACTOR_SUN = $81DA;
var
  GLAD_GL_SUN_mesh_array: boolean;
const
  GL_QUAD_MESH_SUN = $8614;
  GL_TRIANGLE_MESH_SUN = $8615;
var
  GLAD_GL_SUN_slice_accum: boolean;
const
  GL_SLICE_ACCUM_SUN = $85CC;
var
  GLAD_GL_SUN_triangle_list: boolean;
const
  GL_RESTART_SUN = $0001;
  GL_REPLACE_MIDDLE_SUN = $0002;
  GL_REPLACE_OLDEST_SUN = $0003;
  GL_TRIANGLE_LIST_SUN = $81D7;
  GL_REPLACEMENT_CODE_SUN = $81D8;
  GL_REPLACEMENT_CODE_ARRAY_SUN = $85C0;
  GL_REPLACEMENT_CODE_ARRAY_TYPE_SUN = $85C1;
  GL_REPLACEMENT_CODE_ARRAY_STRIDE_SUN = $85C2;
  GL_REPLACEMENT_CODE_ARRAY_POINTER_SUN = $85C3;
  GL_R1UI_V3F_SUN = $85C4;
  GL_R1UI_C4UB_V3F_SUN = $85C5;
  GL_R1UI_C3F_V3F_SUN = $85C6;
  GL_R1UI_N3F_V3F_SUN = $85C7;
  GL_R1UI_C4F_N3F_V3F_SUN = $85C8;
  GL_R1UI_T2F_V3F_SUN = $85C9;
  GL_R1UI_T2F_N3F_V3F_SUN = $85CA;
  GL_R1UI_T2F_C4F_N3F_V3F_SUN = $85CB;
var
  GLAD_GL_SUN_vertex: boolean;
var
  GLAD_GL_WIN_phong_shading: boolean;
const
  GL_PHONG_WIN = $80EA;
  GL_PHONG_HINT_WIN = $80EB;
var
  GLAD_GL_WIN_specular_fog: boolean;
const
  GL_FOG_SPECULAR_TEXTURE_WIN = $80EC;

var
  glTbufferMask3DFX: procedure (mask: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDebugMessageEnableAMD: procedure (category: GLenum; severity: GLenum; count: GLsizei; ids: PGLuint; enabled: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDebugMessageInsertAMD: procedure (category: GLenum; severity: GLenum; id: GLuint; length: GLsizei; buf: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDebugMessageCallbackAMD: procedure (callback: GLDEBUGPROCAMD; userParam: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetDebugMessageLogAMD: function (count: GLuint; bufSize: GLsizei; categories: PGLenum; severities: PGLenum; ids: PGLuint; lengths: PGLsizei; message: PGLchar): GLuint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlendFuncIndexedAMD: procedure (buf: GLuint; src: GLenum; dst: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlendFuncSeparateIndexedAMD: procedure (buf: GLuint; srcRGB: GLenum; dstRGB: GLenum; srcAlpha: GLenum; dstAlpha: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlendEquationIndexedAMD: procedure (buf: GLuint; mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlendEquationSeparateIndexedAMD: procedure (buf: GLuint; modeRGB: GLenum; modeAlpha: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRenderbufferStorageMultisampleAdvancedAMD: procedure (target: GLenum; samples: GLsizei; storageSamples: GLsizei; internalformat: GLenum; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedRenderbufferStorageMultisampleAdvancedAMD: procedure (renderbuffer: GLuint; samples: GLsizei; storageSamples: GLsizei; internalformat: GLenum; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFramebufferSamplePositionsfvAMD: procedure (target: GLenum; numsamples: GLuint; pixelindex: GLuint; values: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedFramebufferSamplePositionsfvAMD: procedure (framebuffer: GLuint; numsamples: GLuint; pixelindex: GLuint; values: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetFramebufferParameterfvAMD: procedure (target: GLenum; pname: GLenum; numsamples: GLuint; pixelindex: GLuint; size: GLsizei; values: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetNamedFramebufferParameterfvAMD: procedure (framebuffer: GLuint; pname: GLenum; numsamples: GLuint; pixelindex: GLuint; size: GLsizei; values: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform1i64NV: procedure (location: GLint; x: GLint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform2i64NV: procedure (location: GLint; x: GLint64EXT; y: GLint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform3i64NV: procedure (location: GLint; x: GLint64EXT; y: GLint64EXT; z: GLint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform4i64NV: procedure (location: GLint; x: GLint64EXT; y: GLint64EXT; z: GLint64EXT; w: GLint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform1i64vNV: procedure (location: GLint; count: GLsizei; value: PGLint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform2i64vNV: procedure (location: GLint; count: GLsizei; value: PGLint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform3i64vNV: procedure (location: GLint; count: GLsizei; value: PGLint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform4i64vNV: procedure (location: GLint; count: GLsizei; value: PGLint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform1ui64NV: procedure (location: GLint; x: GLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform2ui64NV: procedure (location: GLint; x: GLuint64EXT; y: GLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform3ui64NV: procedure (location: GLint; x: GLuint64EXT; y: GLuint64EXT; z: GLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform4ui64NV: procedure (location: GLint; x: GLuint64EXT; y: GLuint64EXT; z: GLuint64EXT; w: GLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform1ui64vNV: procedure (location: GLint; count: GLsizei; value: PGLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform2ui64vNV: procedure (location: GLint; count: GLsizei; value: PGLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform3ui64vNV: procedure (location: GLint; count: GLsizei; value: PGLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform4ui64vNV: procedure (location: GLint; count: GLsizei; value: PGLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetUniformi64vNV: procedure (program_: GLuint; location: GLint; params: PGLint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetUniformui64vNV: procedure (program_: GLuint; location: GLint; params: PGLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform1i64NV: procedure (program_: GLuint; location: GLint; x: GLint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform2i64NV: procedure (program_: GLuint; location: GLint; x: GLint64EXT; y: GLint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform3i64NV: procedure (program_: GLuint; location: GLint; x: GLint64EXT; y: GLint64EXT; z: GLint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform4i64NV: procedure (program_: GLuint; location: GLint; x: GLint64EXT; y: GLint64EXT; z: GLint64EXT; w: GLint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform1i64vNV: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform2i64vNV: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform3i64vNV: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform4i64vNV: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform1ui64NV: procedure (program_: GLuint; location: GLint; x: GLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform2ui64NV: procedure (program_: GLuint; location: GLint; x: GLuint64EXT; y: GLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform3ui64NV: procedure (program_: GLuint; location: GLint; x: GLuint64EXT; y: GLuint64EXT; z: GLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform4ui64NV: procedure (program_: GLuint; location: GLint; x: GLuint64EXT; y: GLuint64EXT; z: GLuint64EXT; w: GLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform1ui64vNV: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform2ui64vNV: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform3ui64vNV: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform4ui64vNV: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribParameteriAMD: procedure (index: GLuint; pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiDrawArraysIndirectAMD: procedure (mode: GLenum; indirect: Pointer; primcount: GLsizei; stride: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiDrawElementsIndirectAMD: procedure (mode: GLenum; type_: GLenum; indirect: Pointer; primcount: GLsizei; stride: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenNamesAMD: procedure (identifier: GLenum; num: GLuint; names: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteNamesAMD: procedure (identifier: GLenum; num: GLuint; names: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsNameAMD: function (identifier: GLenum; name: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glQueryObjectParameteruiAMD: procedure (target: GLenum; id: GLuint; pname: GLenum; param: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPerfMonitorGroupsAMD: procedure (numGroups: PGLint; groupsSize: GLsizei; groups: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPerfMonitorCountersAMD: procedure (group: GLuint; numCounters: PGLint; maxActiveCounters: PGLint; counterSize: GLsizei; counters: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPerfMonitorGroupStringAMD: procedure (group: GLuint; bufSize: GLsizei; length: PGLsizei; groupString: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPerfMonitorCounterStringAMD: procedure (group: GLuint; counter: GLuint; bufSize: GLsizei; length: PGLsizei; counterString: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPerfMonitorCounterInfoAMD: procedure (group: GLuint; counter: GLuint; pname: GLenum; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenPerfMonitorsAMD: procedure (n: GLsizei; monitors: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeletePerfMonitorsAMD: procedure (n: GLsizei; monitors: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSelectPerfMonitorCountersAMD: procedure (monitor: GLuint; enable: GLboolean; group: GLuint; numCounters: GLint; counterList: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBeginPerfMonitorAMD: procedure (monitor: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEndPerfMonitorAMD: procedure (monitor: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPerfMonitorCounterDataAMD: procedure (monitor: GLuint; pname: GLenum; dataSize: GLsizei; data: PGLuint; bytesWritten: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSetMultisamplefvAMD: procedure (pname: GLenum; index: GLuint; val: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexStorageSparseAMD: procedure (target: GLenum; internalFormat: GLenum; width: GLsizei; height: GLsizei; depth: GLsizei; layers: GLsizei; flags: GLbitfield); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureStorageSparseAMD: procedure (texture: GLuint; target: GLenum; internalFormat: GLenum; width: GLsizei; height: GLsizei; depth: GLsizei; layers: GLsizei; flags: GLbitfield); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glStencilOpValueAMD: procedure (face: GLenum; value: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTessellationFactorAMD: procedure (factor: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTessellationModeAMD: procedure (mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glElementPointerAPPLE: procedure (type_: GLenum; pointer: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawElementArrayAPPLE: procedure (mode: GLenum; first: GLint; count: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawRangeElementArrayAPPLE: procedure (mode: GLenum; start: GLuint; end_: GLuint; first: GLint; count: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiDrawElementArrayAPPLE: procedure (mode: GLenum; first: PGLint; count: PGLsizei; primcount: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiDrawRangeElementArrayAPPLE: procedure (mode: GLenum; start: GLuint; end_: GLuint; first: PGLint; count: PGLsizei; primcount: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenFencesAPPLE: procedure (n: GLsizei; fences: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteFencesAPPLE: procedure (n: GLsizei; fences: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSetFenceAPPLE: procedure (fence: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsFenceAPPLE: function (fence: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTestFenceAPPLE: function (fence: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFinishFenceAPPLE: procedure (fence: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTestObjectAPPLE: function (object_: GLenum; name: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFinishObjectAPPLE: procedure (object_: GLenum; name: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBufferParameteriAPPLE: procedure (target: GLenum; pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFlushMappedBufferRangeAPPLE: procedure (target: GLenum; offset: GLintptr; size: GLsizeiptr); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glObjectPurgeableAPPLE: function (objectType: GLenum; name: GLuint; option: GLenum): GLenum; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glObjectUnpurgeableAPPLE: function (objectType: GLenum; name: GLuint; option: GLenum): GLenum; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetObjectParameterivAPPLE: procedure (objectType: GLenum; name: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureRangeAPPLE: procedure (target: GLenum; length: GLsizei; pointer: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTexParameterPointervAPPLE: procedure (target: GLenum; pname: GLenum; params: PPointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindVertexArrayAPPLE: procedure (array_: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteVertexArraysAPPLE: procedure (n: GLsizei; arrays: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenVertexArraysAPPLE: procedure (n: GLsizei; arrays: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsVertexArrayAPPLE: function (array_: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexArrayRangeAPPLE: procedure (length: GLsizei; pointer: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFlushVertexArrayRangeAPPLE: procedure (length: GLsizei; pointer: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexArrayParameteriAPPLE: procedure (pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEnableVertexAttribAPPLE: procedure (index: GLuint; pname: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDisableVertexAttribAPPLE: procedure (index: GLuint; pname: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsVertexAttribEnabledAPPLE: function (index: GLuint; pname: GLenum): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMapVertexAttrib1dAPPLE: procedure (index: GLuint; size: GLuint; u1: GLdouble; u2: GLdouble; stride: GLint; order: GLint; points: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMapVertexAttrib1fAPPLE: procedure (index: GLuint; size: GLuint; u1: GLfloat; u2: GLfloat; stride: GLint; order: GLint; points: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMapVertexAttrib2dAPPLE: procedure (index: GLuint; size: GLuint; u1: GLdouble; u2: GLdouble; ustride: GLint; uorder: GLint; v1: GLdouble; v2: GLdouble; vstride: GLint; vorder: GLint; points: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMapVertexAttrib2fAPPLE: procedure (index: GLuint; size: GLuint; u1: GLfloat; u2: GLfloat; ustride: GLint; uorder: GLint; v1: GLfloat; v2: GLfloat; vstride: GLint; vorder: GLint; points: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glReleaseShaderCompiler: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glShaderBinary: procedure (count: GLsizei; shaders: PGLuint; binaryFormat: GLenum; binary: Pointer; length: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetShaderPrecisionFormat: procedure (shadertype: GLenum; precisiontype: GLenum; range: PGLint; precision: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDepthRangef: procedure (n: GLfloat; f: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClearDepthf: procedure (d: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMemoryBarrierByRegion: procedure (barriers: GLbitfield); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPrimitiveBoundingBoxARB: procedure (minX: GLfloat; minY: GLfloat; minZ: GLfloat; minW: GLfloat; maxX: GLfloat; maxY: GLfloat; maxZ: GLfloat; maxW: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawArraysInstancedBaseInstance: procedure (mode: GLenum; first: GLint; count: GLsizei; instancecount: GLsizei; baseinstance: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawElementsInstancedBaseInstance: procedure (mode: GLenum; count: GLsizei; type_: GLenum; indices: Pointer; instancecount: GLsizei; baseinstance: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawElementsInstancedBaseVertexBaseInstance: procedure (mode: GLenum; count: GLsizei; type_: GLenum; indices: Pointer; instancecount: GLsizei; basevertex: GLint; baseinstance: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTextureHandleARB: function (texture: GLuint): GLuint64; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTextureSamplerHandleARB: function (texture: GLuint; sampler: GLuint): GLuint64; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMakeTextureHandleResidentARB: procedure (handle: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMakeTextureHandleNonResidentARB: procedure (handle: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetImageHandleARB: function (texture: GLuint; level: GLint; layered: GLboolean; layer: GLint; format: GLenum): GLuint64; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMakeImageHandleResidentARB: procedure (handle: GLuint64; access: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMakeImageHandleNonResidentARB: procedure (handle: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformHandleui64ARB: procedure (location: GLint; value: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformHandleui64vARB: procedure (location: GLint; count: GLsizei; value: PGLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformHandleui64ARB: procedure (program_: GLuint; location: GLint; value: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformHandleui64vARB: procedure (program_: GLuint; location: GLint; count: GLsizei; values: PGLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsTextureHandleResidentARB: function (handle: GLuint64): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsImageHandleResidentARB: function (handle: GLuint64): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribL1ui64ARB: procedure (index: GLuint; x: GLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribL1ui64vARB: procedure (index: GLuint; v: PGLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVertexAttribLui64vARB: procedure (index: GLuint; pname: GLenum; params: PGLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindFragDataLocationIndexed: procedure (program_: GLuint; colorNumber: GLuint; index: GLuint; name: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetFragDataIndex: function (program_: GLuint; name: PGLchar): GLint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBufferStorage: procedure (target: GLenum; size: GLsizeiptr; data: Pointer; flags: GLbitfield); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCreateSyncFromCLeventARB: function (context: _cl_context; event: _cl_event; flags: GLbitfield): GLsync; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClearBufferData: procedure (target: GLenum; internalformat: GLenum; format: GLenum; type_: GLenum; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClearBufferSubData: procedure (target: GLenum; internalformat: GLenum; offset: GLintptr; size: GLsizeiptr; format: GLenum; type_: GLenum; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClearTexImage: procedure (texture: GLuint; level: GLint; format: GLenum; type_: GLenum; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClearTexSubImage: procedure (texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; width: GLsizei; height: GLsizei; depth: GLsizei; format: GLenum; type_: GLenum; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClipControl: procedure (origin: GLenum; depth: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClampColorARB: procedure (target: GLenum; clamp: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDispatchCompute: procedure (num_groups_x: GLuint; num_groups_y: GLuint; num_groups_z: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDispatchComputeIndirect: procedure (indirect: GLintptr); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDispatchComputeGroupSizeARB: procedure (num_groups_x: GLuint; num_groups_y: GLuint; num_groups_z: GLuint; group_size_x: GLuint; group_size_y: GLuint; group_size_z: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyBufferSubData: procedure (readTarget: GLenum; writeTarget: GLenum; readOffset: GLintptr; writeOffset: GLintptr; size: GLsizeiptr); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyImageSubData: procedure (srcName: GLuint; srcTarget: GLenum; srcLevel: GLint; srcX: GLint; srcY: GLint; srcZ: GLint; dstName: GLuint; dstTarget: GLenum; dstLevel: GLint; dstX: GLint; dstY: GLint; dstZ: GLint; srcWidth: GLsizei; srcHeight: GLsizei; srcDepth: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDebugMessageControlARB: procedure (source: GLenum; type_: GLenum; severity: GLenum; count: GLsizei; ids: PGLuint; enabled: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDebugMessageInsertARB: procedure (source: GLenum; type_: GLenum; id: GLuint; severity: GLenum; length: GLsizei; buf: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDebugMessageCallbackARB: procedure (callback: GLDEBUGPROCARB; userParam: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetDebugMessageLogARB: function (count: GLuint; bufSize: GLsizei; sources: PGLenum; types: PGLenum; ids: PGLuint; severities: PGLenum; lengths: PGLsizei; messageLog: PGLchar): GLuint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCreateTransformFeedbacks: procedure (n: GLsizei; ids: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTransformFeedbackBufferBase: procedure (xfb: GLuint; index: GLuint; buffer: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTransformFeedbackBufferRange: procedure (xfb: GLuint; index: GLuint; buffer: GLuint; offset: GLintptr; size: GLsizeiptr); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTransformFeedbackiv: procedure (xfb: GLuint; pname: GLenum; param: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTransformFeedbacki_v: procedure (xfb: GLuint; pname: GLenum; index: GLuint; param: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTransformFeedbacki64_v: procedure (xfb: GLuint; pname: GLenum; index: GLuint; param: PGLint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCreateBuffers: procedure (n: GLsizei; buffers: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedBufferStorage: procedure (buffer: GLuint; size: GLsizeiptr; data: Pointer; flags: GLbitfield); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedBufferData: procedure (buffer: GLuint; size: GLsizeiptr; data: Pointer; usage: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedBufferSubData: procedure (buffer: GLuint; offset: GLintptr; size: GLsizeiptr; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyNamedBufferSubData: procedure (readBuffer: GLuint; writeBuffer: GLuint; readOffset: GLintptr; writeOffset: GLintptr; size: GLsizeiptr); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClearNamedBufferData: procedure (buffer: GLuint; internalformat: GLenum; format: GLenum; type_: GLenum; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClearNamedBufferSubData: procedure (buffer: GLuint; internalformat: GLenum; offset: GLintptr; size: GLsizeiptr; format: GLenum; type_: GLenum; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMapNamedBuffer: function (buffer: GLuint; access: GLenum): Pointer; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMapNamedBufferRange: function (buffer: GLuint; offset: GLintptr; length: GLsizeiptr; access: GLbitfield): Pointer; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUnmapNamedBuffer: function (buffer: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFlushMappedNamedBufferRange: procedure (buffer: GLuint; offset: GLintptr; length: GLsizeiptr); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetNamedBufferParameteriv: procedure (buffer: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetNamedBufferParameteri64v: procedure (buffer: GLuint; pname: GLenum; params: PGLint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetNamedBufferPointerv: procedure (buffer: GLuint; pname: GLenum; params: PPointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetNamedBufferSubData: procedure (buffer: GLuint; offset: GLintptr; size: GLsizeiptr; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCreateFramebuffers: procedure (n: GLsizei; framebuffers: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedFramebufferRenderbuffer: procedure (framebuffer: GLuint; attachment: GLenum; renderbuffertarget: GLenum; renderbuffer: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedFramebufferParameteri: procedure (framebuffer: GLuint; pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedFramebufferTexture: procedure (framebuffer: GLuint; attachment: GLenum; texture: GLuint; level: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedFramebufferTextureLayer: procedure (framebuffer: GLuint; attachment: GLenum; texture: GLuint; level: GLint; layer: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedFramebufferDrawBuffer: procedure (framebuffer: GLuint; buf: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedFramebufferDrawBuffers: procedure (framebuffer: GLuint; n: GLsizei; bufs: PGLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedFramebufferReadBuffer: procedure (framebuffer: GLuint; src: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glInvalidateNamedFramebufferData: procedure (framebuffer: GLuint; numAttachments: GLsizei; attachments: PGLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glInvalidateNamedFramebufferSubData: procedure (framebuffer: GLuint; numAttachments: GLsizei; attachments: PGLenum; x: GLint; y: GLint; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClearNamedFramebufferiv: procedure (framebuffer: GLuint; buffer: GLenum; drawbuffer: GLint; value: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClearNamedFramebufferuiv: procedure (framebuffer: GLuint; buffer: GLenum; drawbuffer: GLint; value: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClearNamedFramebufferfv: procedure (framebuffer: GLuint; buffer: GLenum; drawbuffer: GLint; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClearNamedFramebufferfi: procedure (framebuffer: GLuint; buffer: GLenum; drawbuffer: GLint; depth: GLfloat; stencil: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlitNamedFramebuffer: procedure (readFramebuffer: GLuint; drawFramebuffer: GLuint; srcX0: GLint; srcY0: GLint; srcX1: GLint; srcY1: GLint; dstX0: GLint; dstY0: GLint; dstX1: GLint; dstY1: GLint; mask: GLbitfield; filter: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCheckNamedFramebufferStatus: function (framebuffer: GLuint; target: GLenum): GLenum; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetNamedFramebufferParameteriv: procedure (framebuffer: GLuint; pname: GLenum; param: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetNamedFramebufferAttachmentParameteriv: procedure (framebuffer: GLuint; attachment: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCreateRenderbuffers: procedure (n: GLsizei; renderbuffers: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedRenderbufferStorage: procedure (renderbuffer: GLuint; internalformat: GLenum; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedRenderbufferStorageMultisample: procedure (renderbuffer: GLuint; samples: GLsizei; internalformat: GLenum; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetNamedRenderbufferParameteriv: procedure (renderbuffer: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCreateTextures: procedure (target: GLenum; n: GLsizei; textures: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureBuffer: procedure (texture: GLuint; internalformat: GLenum; buffer: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureBufferRange: procedure (texture: GLuint; internalformat: GLenum; buffer: GLuint; offset: GLintptr; size: GLsizeiptr); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureStorage1D: procedure (texture: GLuint; levels: GLsizei; internalformat: GLenum; width: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureStorage2D: procedure (texture: GLuint; levels: GLsizei; internalformat: GLenum; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureStorage3D: procedure (texture: GLuint; levels: GLsizei; internalformat: GLenum; width: GLsizei; height: GLsizei; depth: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureStorage2DMultisample: procedure (texture: GLuint; samples: GLsizei; internalformat: GLenum; width: GLsizei; height: GLsizei; fixedsamplelocations: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureStorage3DMultisample: procedure (texture: GLuint; samples: GLsizei; internalformat: GLenum; width: GLsizei; height: GLsizei; depth: GLsizei; fixedsamplelocations: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureSubImage1D: procedure (texture: GLuint; level: GLint; xoffset: GLint; width: GLsizei; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureSubImage2D: procedure (texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; width: GLsizei; height: GLsizei; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureSubImage3D: procedure (texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; width: GLsizei; height: GLsizei; depth: GLsizei; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCompressedTextureSubImage1D: procedure (texture: GLuint; level: GLint; xoffset: GLint; width: GLsizei; format: GLenum; imageSize: GLsizei; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCompressedTextureSubImage2D: procedure (texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; width: GLsizei; height: GLsizei; format: GLenum; imageSize: GLsizei; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCompressedTextureSubImage3D: procedure (texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; width: GLsizei; height: GLsizei; depth: GLsizei; format: GLenum; imageSize: GLsizei; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyTextureSubImage1D: procedure (texture: GLuint; level: GLint; xoffset: GLint; x: GLint; y: GLint; width: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyTextureSubImage2D: procedure (texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; x: GLint; y: GLint; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyTextureSubImage3D: procedure (texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; x: GLint; y: GLint; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureParameterf: procedure (texture: GLuint; pname: GLenum; param: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureParameterfv: procedure (texture: GLuint; pname: GLenum; param: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureParameteri: procedure (texture: GLuint; pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureParameterIiv: procedure (texture: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureParameterIuiv: procedure (texture: GLuint; pname: GLenum; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureParameteriv: procedure (texture: GLuint; pname: GLenum; param: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenerateTextureMipmap: procedure (texture: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindTextureUnit: procedure (unit_: GLuint; texture: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTextureImage: procedure (texture: GLuint; level: GLint; format: GLenum; type_: GLenum; bufSize: GLsizei; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetCompressedTextureImage: procedure (texture: GLuint; level: GLint; bufSize: GLsizei; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTextureLevelParameterfv: procedure (texture: GLuint; level: GLint; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTextureLevelParameteriv: procedure (texture: GLuint; level: GLint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTextureParameterfv: procedure (texture: GLuint; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTextureParameterIiv: procedure (texture: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTextureParameterIuiv: procedure (texture: GLuint; pname: GLenum; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTextureParameteriv: procedure (texture: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCreateVertexArrays: procedure (n: GLsizei; arrays: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDisableVertexArrayAttrib: procedure (vaobj: GLuint; index: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEnableVertexArrayAttrib: procedure (vaobj: GLuint; index: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexArrayElementBuffer: procedure (vaobj: GLuint; buffer: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexArrayVertexBuffer: procedure (vaobj: GLuint; bindingindex: GLuint; buffer: GLuint; offset: GLintptr; stride: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexArrayVertexBuffers: procedure (vaobj: GLuint; first: GLuint; count: GLsizei; buffers: PGLuint; offsets: PGLintptr; strides: PGLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexArrayAttribBinding: procedure (vaobj: GLuint; attribindex: GLuint; bindingindex: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexArrayAttribFormat: procedure (vaobj: GLuint; attribindex: GLuint; size: GLint; type_: GLenum; normalized: GLboolean; relativeoffset: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexArrayAttribIFormat: procedure (vaobj: GLuint; attribindex: GLuint; size: GLint; type_: GLenum; relativeoffset: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexArrayAttribLFormat: procedure (vaobj: GLuint; attribindex: GLuint; size: GLint; type_: GLenum; relativeoffset: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexArrayBindingDivisor: procedure (vaobj: GLuint; bindingindex: GLuint; divisor: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVertexArrayiv: procedure (vaobj: GLuint; pname: GLenum; param: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVertexArrayIndexediv: procedure (vaobj: GLuint; index: GLuint; pname: GLenum; param: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVertexArrayIndexed64iv: procedure (vaobj: GLuint; index: GLuint; pname: GLenum; param: PGLint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCreateSamplers: procedure (n: GLsizei; samplers: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCreateProgramPipelines: procedure (n: GLsizei; pipelines: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCreateQueries: procedure (target: GLenum; n: GLsizei; ids: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetQueryBufferObjecti64v: procedure (id: GLuint; buffer: GLuint; pname: GLenum; offset: GLintptr); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetQueryBufferObjectiv: procedure (id: GLuint; buffer: GLuint; pname: GLenum; offset: GLintptr); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetQueryBufferObjectui64v: procedure (id: GLuint; buffer: GLuint; pname: GLenum; offset: GLintptr); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetQueryBufferObjectuiv: procedure (id: GLuint; buffer: GLuint; pname: GLenum; offset: GLintptr); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawBuffersARB: procedure (n: GLsizei; bufs: PGLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlendEquationiARB: procedure (buf: GLuint; mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlendEquationSeparateiARB: procedure (buf: GLuint; modeRGB: GLenum; modeAlpha: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlendFunciARB: procedure (buf: GLuint; src: GLenum; dst: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlendFuncSeparateiARB: procedure (buf: GLuint; srcRGB: GLenum; dstRGB: GLenum; srcAlpha: GLenum; dstAlpha: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawElementsBaseVertex: procedure (mode: GLenum; count: GLsizei; type_: GLenum; indices: Pointer; basevertex: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawRangeElementsBaseVertex: procedure (mode: GLenum; start: GLuint; end_: GLuint; count: GLsizei; type_: GLenum; indices: Pointer; basevertex: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawElementsInstancedBaseVertex: procedure (mode: GLenum; count: GLsizei; type_: GLenum; indices: Pointer; instancecount: GLsizei; basevertex: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiDrawElementsBaseVertex: procedure (mode: GLenum; count: PGLsizei; type_: GLenum; indices: PPointer; drawcount: GLsizei; basevertex: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawArraysIndirect: procedure (mode: GLenum; indirect: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawElementsIndirect: procedure (mode: GLenum; type_: GLenum; indirect: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawArraysInstancedARB: procedure (mode: GLenum; first: GLint; count: GLsizei; primcount: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawElementsInstancedARB: procedure (mode: GLenum; count: GLsizei; type_: GLenum; indices: Pointer; primcount: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramStringARB: procedure (target: GLenum; format: GLenum; len: GLsizei; string_: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindProgramARB: procedure (target: GLenum; program_: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteProgramsARB: procedure (n: GLsizei; programs: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenProgramsARB: procedure (n: GLsizei; programs: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramEnvParameter4dARB: procedure (target: GLenum; index: GLuint; x: GLdouble; y: GLdouble; z: GLdouble; w: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramEnvParameter4dvARB: procedure (target: GLenum; index: GLuint; params: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramEnvParameter4fARB: procedure (target: GLenum; index: GLuint; x: GLfloat; y: GLfloat; z: GLfloat; w: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramEnvParameter4fvARB: procedure (target: GLenum; index: GLuint; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramLocalParameter4dARB: procedure (target: GLenum; index: GLuint; x: GLdouble; y: GLdouble; z: GLdouble; w: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramLocalParameter4dvARB: procedure (target: GLenum; index: GLuint; params: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramLocalParameter4fARB: procedure (target: GLenum; index: GLuint; x: GLfloat; y: GLfloat; z: GLfloat; w: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramLocalParameter4fvARB: procedure (target: GLenum; index: GLuint; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetProgramEnvParameterdvARB: procedure (target: GLenum; index: GLuint; params: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetProgramEnvParameterfvARB: procedure (target: GLenum; index: GLuint; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetProgramLocalParameterdvARB: procedure (target: GLenum; index: GLuint; params: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetProgramLocalParameterfvARB: procedure (target: GLenum; index: GLuint; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetProgramivARB: procedure (target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetProgramStringARB: procedure (target: GLenum; pname: GLenum; string_: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsProgramARB: function (program_: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFramebufferParameteri: procedure (target: GLenum; pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetFramebufferParameteriv: procedure (target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsRenderbuffer: function (renderbuffer: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindRenderbuffer: procedure (target: GLenum; renderbuffer: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteRenderbuffers: procedure (n: GLsizei; renderbuffers: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenRenderbuffers: procedure (n: GLsizei; renderbuffers: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRenderbufferStorage: procedure (target: GLenum; internalformat: GLenum; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetRenderbufferParameteriv: procedure (target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsFramebuffer: function (framebuffer: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindFramebuffer: procedure (target: GLenum; framebuffer: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteFramebuffers: procedure (n: GLsizei; framebuffers: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenFramebuffers: procedure (n: GLsizei; framebuffers: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCheckFramebufferStatus: function (target: GLenum): GLenum; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFramebufferTexture1D: procedure (target: GLenum; attachment: GLenum; textarget: GLenum; texture: GLuint; level: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFramebufferTexture2D: procedure (target: GLenum; attachment: GLenum; textarget: GLenum; texture: GLuint; level: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFramebufferTexture3D: procedure (target: GLenum; attachment: GLenum; textarget: GLenum; texture: GLuint; level: GLint; zoffset: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFramebufferRenderbuffer: procedure (target: GLenum; attachment: GLenum; renderbuffertarget: GLenum; renderbuffer: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetFramebufferAttachmentParameteriv: procedure (target: GLenum; attachment: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenerateMipmap: procedure (target: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlitFramebuffer: procedure (srcX0: GLint; srcY0: GLint; srcX1: GLint; srcY1: GLint; dstX0: GLint; dstY0: GLint; dstX1: GLint; dstY1: GLint; mask: GLbitfield; filter: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRenderbufferStorageMultisample: procedure (target: GLenum; samples: GLsizei; internalformat: GLenum; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFramebufferTextureLayer: procedure (target: GLenum; attachment: GLenum; texture: GLuint; level: GLint; layer: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramParameteriARB: procedure (program_: GLuint; pname: GLenum; value: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFramebufferTextureARB: procedure (target: GLenum; attachment: GLenum; texture: GLuint; level: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFramebufferTextureLayerARB: procedure (target: GLenum; attachment: GLenum; texture: GLuint; level: GLint; layer: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFramebufferTextureFaceARB: procedure (target: GLenum; attachment: GLenum; texture: GLuint; level: GLint; face: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetProgramBinary: procedure (program_: GLuint; bufSize: GLsizei; length: PGLsizei; binaryFormat: PGLenum; binary: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramBinary: procedure (program_: GLuint; binaryFormat: GLenum; binary: Pointer; length: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramParameteri: procedure (program_: GLuint; pname: GLenum; value: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTextureSubImage: procedure (texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; width: GLsizei; height: GLsizei; depth: GLsizei; format: GLenum; type_: GLenum; bufSize: GLsizei; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetCompressedTextureSubImage: procedure (texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; width: GLsizei; height: GLsizei; depth: GLsizei; bufSize: GLsizei; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSpecializeShaderARB: procedure (shader: GLuint; pEntryPoint: PGLchar; numSpecializationConstants: GLuint; pConstantIndex: PGLuint; pConstantValue: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform1d: procedure (location: GLint; x: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform2d: procedure (location: GLint; x: GLdouble; y: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform3d: procedure (location: GLint; x: GLdouble; y: GLdouble; z: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform4d: procedure (location: GLint; x: GLdouble; y: GLdouble; z: GLdouble; w: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform1dv: procedure (location: GLint; count: GLsizei; value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform2dv: procedure (location: GLint; count: GLsizei; value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform3dv: procedure (location: GLint; count: GLsizei; value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform4dv: procedure (location: GLint; count: GLsizei; value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformMatrix2dv: procedure (location: GLint; count: GLsizei; transpose: GLboolean; value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformMatrix3dv: procedure (location: GLint; count: GLsizei; transpose: GLboolean; value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformMatrix4dv: procedure (location: GLint; count: GLsizei; transpose: GLboolean; value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformMatrix2x3dv: procedure (location: GLint; count: GLsizei; transpose: GLboolean; value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformMatrix2x4dv: procedure (location: GLint; count: GLsizei; transpose: GLboolean; value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformMatrix3x2dv: procedure (location: GLint; count: GLsizei; transpose: GLboolean; value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformMatrix3x4dv: procedure (location: GLint; count: GLsizei; transpose: GLboolean; value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformMatrix4x2dv: procedure (location: GLint; count: GLsizei; transpose: GLboolean; value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformMatrix4x3dv: procedure (location: GLint; count: GLsizei; transpose: GLboolean; value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetUniformdv: procedure (program_: GLuint; location: GLint; params: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform1i64ARB: procedure (location: GLint; x: GLint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform2i64ARB: procedure (location: GLint; x: GLint64; y: GLint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform3i64ARB: procedure (location: GLint; x: GLint64; y: GLint64; z: GLint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform4i64ARB: procedure (location: GLint; x: GLint64; y: GLint64; z: GLint64; w: GLint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform1i64vARB: procedure (location: GLint; count: GLsizei; value: PGLint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform2i64vARB: procedure (location: GLint; count: GLsizei; value: PGLint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform3i64vARB: procedure (location: GLint; count: GLsizei; value: PGLint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform4i64vARB: procedure (location: GLint; count: GLsizei; value: PGLint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform1ui64ARB: procedure (location: GLint; x: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform2ui64ARB: procedure (location: GLint; x: GLuint64; y: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform3ui64ARB: procedure (location: GLint; x: GLuint64; y: GLuint64; z: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform4ui64ARB: procedure (location: GLint; x: GLuint64; y: GLuint64; z: GLuint64; w: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform1ui64vARB: procedure (location: GLint; count: GLsizei; value: PGLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform2ui64vARB: procedure (location: GLint; count: GLsizei; value: PGLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform3ui64vARB: procedure (location: GLint; count: GLsizei; value: PGLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform4ui64vARB: procedure (location: GLint; count: GLsizei; value: PGLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetUniformi64vARB: procedure (program_: GLuint; location: GLint; params: PGLint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetUniformui64vARB: procedure (program_: GLuint; location: GLint; params: PGLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetnUniformi64vARB: procedure (program_: GLuint; location: GLint; bufSize: GLsizei; params: PGLint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetnUniformui64vARB: procedure (program_: GLuint; location: GLint; bufSize: GLsizei; params: PGLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform1i64ARB: procedure (program_: GLuint; location: GLint; x: GLint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform2i64ARB: procedure (program_: GLuint; location: GLint; x: GLint64; y: GLint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform3i64ARB: procedure (program_: GLuint; location: GLint; x: GLint64; y: GLint64; z: GLint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform4i64ARB: procedure (program_: GLuint; location: GLint; x: GLint64; y: GLint64; z: GLint64; w: GLint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform1i64vARB: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform2i64vARB: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform3i64vARB: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform4i64vARB: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform1ui64ARB: procedure (program_: GLuint; location: GLint; x: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform2ui64ARB: procedure (program_: GLuint; location: GLint; x: GLuint64; y: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform3ui64ARB: procedure (program_: GLuint; location: GLint; x: GLuint64; y: GLuint64; z: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform4ui64ARB: procedure (program_: GLuint; location: GLint; x: GLuint64; y: GLuint64; z: GLuint64; w: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform1ui64vARB: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform2ui64vARB: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform3ui64vARB: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform4ui64vARB: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlendColor: procedure (red: GLfloat; green: GLfloat; blue: GLfloat; alpha: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlendEquation: procedure (mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColorTable: procedure (target: GLenum; internalformat: GLenum; width: GLsizei; format: GLenum; type_: GLenum; table: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColorTableParameterfv: procedure (target: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColorTableParameteriv: procedure (target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyColorTable: procedure (target: GLenum; internalformat: GLenum; x: GLint; y: GLint; width: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetColorTable: procedure (target: GLenum; format: GLenum; type_: GLenum; table: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetColorTableParameterfv: procedure (target: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetColorTableParameteriv: procedure (target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColorSubTable: procedure (target: GLenum; start: GLsizei; count: GLsizei; format: GLenum; type_: GLenum; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyColorSubTable: procedure (target: GLenum; start: GLsizei; x: GLint; y: GLint; width: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glConvolutionFilter1D: procedure (target: GLenum; internalformat: GLenum; width: GLsizei; format: GLenum; type_: GLenum; image: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glConvolutionFilter2D: procedure (target: GLenum; internalformat: GLenum; width: GLsizei; height: GLsizei; format: GLenum; type_: GLenum; image: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glConvolutionParameterf: procedure (target: GLenum; pname: GLenum; params: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glConvolutionParameterfv: procedure (target: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glConvolutionParameteri: procedure (target: GLenum; pname: GLenum; params: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glConvolutionParameteriv: procedure (target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyConvolutionFilter1D: procedure (target: GLenum; internalformat: GLenum; x: GLint; y: GLint; width: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyConvolutionFilter2D: procedure (target: GLenum; internalformat: GLenum; x: GLint; y: GLint; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetConvolutionFilter: procedure (target: GLenum; format: GLenum; type_: GLenum; image: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetConvolutionParameterfv: procedure (target: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetConvolutionParameteriv: procedure (target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetSeparableFilter: procedure (target: GLenum; format: GLenum; type_: GLenum; row: Pointer; column: Pointer; span: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSeparableFilter2D: procedure (target: GLenum; internalformat: GLenum; width: GLsizei; height: GLsizei; format: GLenum; type_: GLenum; row: Pointer; column: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetHistogram: procedure (target: GLenum; reset: GLboolean; format: GLenum; type_: GLenum; values: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetHistogramParameterfv: procedure (target: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetHistogramParameteriv: procedure (target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetMinmax: procedure (target: GLenum; reset: GLboolean; format: GLenum; type_: GLenum; values: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetMinmaxParameterfv: procedure (target: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetMinmaxParameteriv: procedure (target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glHistogram: procedure (target: GLenum; width: GLsizei; internalformat: GLenum; sink: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMinmax: procedure (target: GLenum; internalformat: GLenum; sink: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glResetHistogram: procedure (target: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glResetMinmax: procedure (target: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiDrawArraysIndirectCountARB: procedure (mode: GLenum; indirect: Pointer; drawcount: GLintptr; maxdrawcount: GLsizei; stride: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiDrawElementsIndirectCountARB: procedure (mode: GLenum; type_: GLenum; indirect: Pointer; drawcount: GLintptr; maxdrawcount: GLsizei; stride: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribDivisorARB: procedure (index: GLuint; divisor: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetInternalformativ: procedure (target: GLenum; internalformat: GLenum; pname: GLenum; count: GLsizei; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetInternalformati64v: procedure (target: GLenum; internalformat: GLenum; pname: GLenum; count: GLsizei; params: PGLint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glInvalidateTexSubImage: procedure (texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; width: GLsizei; height: GLsizei; depth: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glInvalidateTexImage: procedure (texture: GLuint; level: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glInvalidateBufferSubData: procedure (buffer: GLuint; offset: GLintptr; length: GLsizeiptr); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glInvalidateBufferData: procedure (buffer: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glInvalidateFramebuffer: procedure (target: GLenum; numAttachments: GLsizei; attachments: PGLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glInvalidateSubFramebuffer: procedure (target: GLenum; numAttachments: GLsizei; attachments: PGLenum; x: GLint; y: GLint; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMapBufferRange: function (target: GLenum; offset: GLintptr; length: GLsizeiptr; access: GLbitfield): Pointer; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFlushMappedBufferRange: procedure (target: GLenum; offset: GLintptr; length: GLsizeiptr); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCurrentPaletteMatrixARB: procedure (index: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixIndexubvARB: procedure (size: GLint; indices: PGLubyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixIndexusvARB: procedure (size: GLint; indices: PGLushort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixIndexuivARB: procedure (size: GLint; indices: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixIndexPointerARB: procedure (size: GLint; type_: GLenum; stride: GLsizei; pointer: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindBuffersBase: procedure (target: GLenum; first: GLuint; count: GLsizei; buffers: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindBuffersRange: procedure (target: GLenum; first: GLuint; count: GLsizei; buffers: PGLuint; offsets: PGLintptr; sizes: PGLsizeiptr); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindTextures: procedure (first: GLuint; count: GLsizei; textures: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindSamplers: procedure (first: GLuint; count: GLsizei; samplers: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindImageTextures: procedure (first: GLuint; count: GLsizei; textures: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindVertexBuffers: procedure (first: GLuint; count: GLsizei; buffers: PGLuint; offsets: PGLintptr; strides: PGLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiDrawArraysIndirect: procedure (mode: GLenum; indirect: Pointer; drawcount: GLsizei; stride: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiDrawElementsIndirect: procedure (mode: GLenum; type_: GLenum; indirect: Pointer; drawcount: GLsizei; stride: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSampleCoverageARB: procedure (value: GLfloat; invert: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glActiveTextureARB: procedure (texture: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClientActiveTextureARB: procedure (texture: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord1dARB: procedure (target: GLenum; s: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord1dvARB: procedure (target: GLenum; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord1fARB: procedure (target: GLenum; s: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord1fvARB: procedure (target: GLenum; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord1iARB: procedure (target: GLenum; s: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord1ivARB: procedure (target: GLenum; v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord1sARB: procedure (target: GLenum; s: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord1svARB: procedure (target: GLenum; v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord2dARB: procedure (target: GLenum; s: GLdouble; t: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord2dvARB: procedure (target: GLenum; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord2fARB: procedure (target: GLenum; s: GLfloat; t: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord2fvARB: procedure (target: GLenum; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord2iARB: procedure (target: GLenum; s: GLint; t: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord2ivARB: procedure (target: GLenum; v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord2sARB: procedure (target: GLenum; s: GLshort; t: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord2svARB: procedure (target: GLenum; v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord3dARB: procedure (target: GLenum; s: GLdouble; t: GLdouble; r: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord3dvARB: procedure (target: GLenum; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord3fARB: procedure (target: GLenum; s: GLfloat; t: GLfloat; r: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord3fvARB: procedure (target: GLenum; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord3iARB: procedure (target: GLenum; s: GLint; t: GLint; r: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord3ivARB: procedure (target: GLenum; v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord3sARB: procedure (target: GLenum; s: GLshort; t: GLshort; r: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord3svARB: procedure (target: GLenum; v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord4dARB: procedure (target: GLenum; s: GLdouble; t: GLdouble; r: GLdouble; q: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord4dvARB: procedure (target: GLenum; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord4fARB: procedure (target: GLenum; s: GLfloat; t: GLfloat; r: GLfloat; q: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord4fvARB: procedure (target: GLenum; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord4iARB: procedure (target: GLenum; s: GLint; t: GLint; r: GLint; q: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord4ivARB: procedure (target: GLenum; v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord4sARB: procedure (target: GLenum; s: GLshort; t: GLshort; r: GLshort; q: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord4svARB: procedure (target: GLenum; v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenQueriesARB: procedure (n: GLsizei; ids: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteQueriesARB: procedure (n: GLsizei; ids: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsQueryARB: function (id: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBeginQueryARB: procedure (target: GLenum; id: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEndQueryARB: procedure (target: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetQueryivARB: procedure (target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetQueryObjectivARB: procedure (id: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetQueryObjectuivARB: procedure (id: GLuint; pname: GLenum; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMaxShaderCompilerThreadsARB: procedure (count: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPointParameterfARB: procedure (pname: GLenum; param: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPointParameterfvARB: procedure (pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPolygonOffsetClamp: procedure (factor: GLfloat; units: GLfloat; clamp: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetProgramInterfaceiv: procedure (program_: GLuint; programInterface: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetProgramResourceIndex: function (program_: GLuint; programInterface: GLenum; name: PGLchar): GLuint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetProgramResourceName: procedure (program_: GLuint; programInterface: GLenum; index: GLuint; bufSize: GLsizei; length: PGLsizei; name: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetProgramResourceiv: procedure (program_: GLuint; programInterface: GLenum; index: GLuint; propCount: GLsizei; props: PGLenum; count: GLsizei; length: PGLsizei; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetProgramResourceLocation: function (program_: GLuint; programInterface: GLenum; name: PGLchar): GLint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetProgramResourceLocationIndex: function (program_: GLuint; programInterface: GLenum; name: PGLchar): GLint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProvokingVertex: procedure (mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetGraphicsResetStatusARB: function (): GLenum; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetnTexImageARB: procedure (target: GLenum; level: GLint; format: GLenum; type_: GLenum; bufSize: GLsizei; img: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glReadnPixelsARB: procedure (x: GLint; y: GLint; width: GLsizei; height: GLsizei; format: GLenum; type_: GLenum; bufSize: GLsizei; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetnCompressedTexImageARB: procedure (target: GLenum; lod: GLint; bufSize: GLsizei; img: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetnUniformfvARB: procedure (program_: GLuint; location: GLint; bufSize: GLsizei; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetnUniformivARB: procedure (program_: GLuint; location: GLint; bufSize: GLsizei; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetnUniformuivARB: procedure (program_: GLuint; location: GLint; bufSize: GLsizei; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetnUniformdvARB: procedure (program_: GLuint; location: GLint; bufSize: GLsizei; params: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetnMapdvARB: procedure (target: GLenum; query: GLenum; bufSize: GLsizei; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetnMapfvARB: procedure (target: GLenum; query: GLenum; bufSize: GLsizei; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetnMapivARB: procedure (target: GLenum; query: GLenum; bufSize: GLsizei; v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetnPixelMapfvARB: procedure (map: GLenum; bufSize: GLsizei; values: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetnPixelMapuivARB: procedure (map: GLenum; bufSize: GLsizei; values: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetnPixelMapusvARB: procedure (map: GLenum; bufSize: GLsizei; values: PGLushort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetnPolygonStippleARB: procedure (bufSize: GLsizei; pattern: PGLubyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetnColorTableARB: procedure (target: GLenum; format: GLenum; type_: GLenum; bufSize: GLsizei; table: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetnConvolutionFilterARB: procedure (target: GLenum; format: GLenum; type_: GLenum; bufSize: GLsizei; image: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetnSeparableFilterARB: procedure (target: GLenum; format: GLenum; type_: GLenum; rowBufSize: GLsizei; row: Pointer; columnBufSize: GLsizei; column: Pointer; span: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetnHistogramARB: procedure (target: GLenum; reset: GLboolean; format: GLenum; type_: GLenum; bufSize: GLsizei; values: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetnMinmaxARB: procedure (target: GLenum; reset: GLboolean; format: GLenum; type_: GLenum; bufSize: GLsizei; values: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFramebufferSampleLocationsfvARB: procedure (target: GLenum; start: GLuint; count: GLsizei; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedFramebufferSampleLocationsfvARB: procedure (framebuffer: GLuint; start: GLuint; count: GLsizei; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEvaluateDepthValuesARB: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMinSampleShadingARB: procedure (value: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenSamplers: procedure (count: GLsizei; samplers: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteSamplers: procedure (count: GLsizei; samplers: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsSampler: function (sampler: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindSampler: procedure (unit_: GLuint; sampler: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSamplerParameteri: procedure (sampler: GLuint; pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSamplerParameteriv: procedure (sampler: GLuint; pname: GLenum; param: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSamplerParameterf: procedure (sampler: GLuint; pname: GLenum; param: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSamplerParameterfv: procedure (sampler: GLuint; pname: GLenum; param: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSamplerParameterIiv: procedure (sampler: GLuint; pname: GLenum; param: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSamplerParameterIuiv: procedure (sampler: GLuint; pname: GLenum; param: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetSamplerParameteriv: procedure (sampler: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetSamplerParameterIiv: procedure (sampler: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetSamplerParameterfv: procedure (sampler: GLuint; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetSamplerParameterIuiv: procedure (sampler: GLuint; pname: GLenum; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUseProgramStages: procedure (pipeline: GLuint; stages: GLbitfield; program_: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glActiveShaderProgram: procedure (pipeline: GLuint; program_: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCreateShaderProgramv: function (type_: GLenum; count: GLsizei; strings: PPGLchar): GLuint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindProgramPipeline: procedure (pipeline: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteProgramPipelines: procedure (n: GLsizei; pipelines: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenProgramPipelines: procedure (n: GLsizei; pipelines: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsProgramPipeline: function (pipeline: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetProgramPipelineiv: procedure (pipeline: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform1i: procedure (program_: GLuint; location: GLint; v0: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform1iv: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform1f: procedure (program_: GLuint; location: GLint; v0: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform1fv: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform1d: procedure (program_: GLuint; location: GLint; v0: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform1dv: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform1ui: procedure (program_: GLuint; location: GLint; v0: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform1uiv: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform2i: procedure (program_: GLuint; location: GLint; v0: GLint; v1: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform2iv: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform2f: procedure (program_: GLuint; location: GLint; v0: GLfloat; v1: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform2fv: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform2d: procedure (program_: GLuint; location: GLint; v0: GLdouble; v1: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform2dv: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform2ui: procedure (program_: GLuint; location: GLint; v0: GLuint; v1: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform2uiv: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform3i: procedure (program_: GLuint; location: GLint; v0: GLint; v1: GLint; v2: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform3iv: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform3f: procedure (program_: GLuint; location: GLint; v0: GLfloat; v1: GLfloat; v2: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform3fv: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform3d: procedure (program_: GLuint; location: GLint; v0: GLdouble; v1: GLdouble; v2: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform3dv: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform3ui: procedure (program_: GLuint; location: GLint; v0: GLuint; v1: GLuint; v2: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform3uiv: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform4i: procedure (program_: GLuint; location: GLint; v0: GLint; v1: GLint; v2: GLint; v3: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform4iv: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform4f: procedure (program_: GLuint; location: GLint; v0: GLfloat; v1: GLfloat; v2: GLfloat; v3: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform4fv: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform4d: procedure (program_: GLuint; location: GLint; v0: GLdouble; v1: GLdouble; v2: GLdouble; v3: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform4dv: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform4ui: procedure (program_: GLuint; location: GLint; v0: GLuint; v1: GLuint; v2: GLuint; v3: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform4uiv: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformMatrix2fv: procedure (program_: GLuint; location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformMatrix3fv: procedure (program_: GLuint; location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformMatrix4fv: procedure (program_: GLuint; location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformMatrix2dv: procedure (program_: GLuint; location: GLint; count: GLsizei; transpose: GLboolean; value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformMatrix3dv: procedure (program_: GLuint; location: GLint; count: GLsizei; transpose: GLboolean; value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformMatrix4dv: procedure (program_: GLuint; location: GLint; count: GLsizei; transpose: GLboolean; value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformMatrix2x3fv: procedure (program_: GLuint; location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformMatrix3x2fv: procedure (program_: GLuint; location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformMatrix2x4fv: procedure (program_: GLuint; location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformMatrix4x2fv: procedure (program_: GLuint; location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformMatrix3x4fv: procedure (program_: GLuint; location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformMatrix4x3fv: procedure (program_: GLuint; location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformMatrix2x3dv: procedure (program_: GLuint; location: GLint; count: GLsizei; transpose: GLboolean; value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformMatrix3x2dv: procedure (program_: GLuint; location: GLint; count: GLsizei; transpose: GLboolean; value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformMatrix2x4dv: procedure (program_: GLuint; location: GLint; count: GLsizei; transpose: GLboolean; value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformMatrix4x2dv: procedure (program_: GLuint; location: GLint; count: GLsizei; transpose: GLboolean; value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformMatrix3x4dv: procedure (program_: GLuint; location: GLint; count: GLsizei; transpose: GLboolean; value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformMatrix4x3dv: procedure (program_: GLuint; location: GLint; count: GLsizei; transpose: GLboolean; value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glValidateProgramPipeline: procedure (pipeline: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetProgramPipelineInfoLog: procedure (pipeline: GLuint; bufSize: GLsizei; length: PGLsizei; infoLog: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetActiveAtomicCounterBufferiv: procedure (program_: GLuint; bufferIndex: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindImageTexture: procedure (unit_: GLuint; texture: GLuint; level: GLint; layered: GLboolean; layer: GLint; access: GLenum; format: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMemoryBarrier: procedure (barriers: GLbitfield); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteObjectARB: procedure (obj: GLhandleARB); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetHandleARB: function (pname: GLenum): GLhandleARB; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDetachObjectARB: procedure (containerObj: GLhandleARB; attachedObj: GLhandleARB); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCreateShaderObjectARB: function (shaderType: GLenum): GLhandleARB; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glShaderSourceARB: procedure (shaderObj: GLhandleARB; count: GLsizei; string_: PPGLcharARB; length: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCompileShaderARB: procedure (shaderObj: GLhandleARB); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCreateProgramObjectARB: function (): GLhandleARB; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glAttachObjectARB: procedure (containerObj: GLhandleARB; obj: GLhandleARB); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glLinkProgramARB: procedure (programObj: GLhandleARB); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUseProgramObjectARB: procedure (programObj: GLhandleARB); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glValidateProgramARB: procedure (programObj: GLhandleARB); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform1fARB: procedure (location: GLint; v0: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform2fARB: procedure (location: GLint; v0: GLfloat; v1: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform3fARB: procedure (location: GLint; v0: GLfloat; v1: GLfloat; v2: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform4fARB: procedure (location: GLint; v0: GLfloat; v1: GLfloat; v2: GLfloat; v3: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform1iARB: procedure (location: GLint; v0: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform2iARB: procedure (location: GLint; v0: GLint; v1: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform3iARB: procedure (location: GLint; v0: GLint; v1: GLint; v2: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform4iARB: procedure (location: GLint; v0: GLint; v1: GLint; v2: GLint; v3: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform1fvARB: procedure (location: GLint; count: GLsizei; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform2fvARB: procedure (location: GLint; count: GLsizei; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform3fvARB: procedure (location: GLint; count: GLsizei; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform4fvARB: procedure (location: GLint; count: GLsizei; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform1ivARB: procedure (location: GLint; count: GLsizei; value: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform2ivARB: procedure (location: GLint; count: GLsizei; value: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform3ivARB: procedure (location: GLint; count: GLsizei; value: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform4ivARB: procedure (location: GLint; count: GLsizei; value: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformMatrix2fvARB: procedure (location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformMatrix3fvARB: procedure (location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformMatrix4fvARB: procedure (location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetObjectParameterfvARB: procedure (obj: GLhandleARB; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetObjectParameterivARB: procedure (obj: GLhandleARB; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetInfoLogARB: procedure (obj: GLhandleARB; maxLength: GLsizei; length: PGLsizei; infoLog: PGLcharARB); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetAttachedObjectsARB: procedure (containerObj: GLhandleARB; maxCount: GLsizei; count: PGLsizei; obj: PGLhandleARB); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetUniformLocationARB: function (programObj: GLhandleARB; name: PGLcharARB): GLint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetActiveUniformARB: procedure (programObj: GLhandleARB; index: GLuint; maxLength: GLsizei; length: PGLsizei; size: PGLint; type_: PGLenum; name: PGLcharARB); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetUniformfvARB: procedure (programObj: GLhandleARB; location: GLint; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetUniformivARB: procedure (programObj: GLhandleARB; location: GLint; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetShaderSourceARB: procedure (obj: GLhandleARB; maxLength: GLsizei; length: PGLsizei; source: PGLcharARB); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glShaderStorageBlockBinding: procedure (program_: GLuint; storageBlockIndex: GLuint; storageBlockBinding: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetSubroutineUniformLocation: function (program_: GLuint; shadertype: GLenum; name: PGLchar): GLint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetSubroutineIndex: function (program_: GLuint; shadertype: GLenum; name: PGLchar): GLuint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetActiveSubroutineUniformiv: procedure (program_: GLuint; shadertype: GLenum; index: GLuint; pname: GLenum; values: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetActiveSubroutineUniformName: procedure (program_: GLuint; shadertype: GLenum; index: GLuint; bufSize: GLsizei; length: PGLsizei; name: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetActiveSubroutineName: procedure (program_: GLuint; shadertype: GLenum; index: GLuint; bufSize: GLsizei; length: PGLsizei; name: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformSubroutinesuiv: procedure (shadertype: GLenum; count: GLsizei; indices: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetUniformSubroutineuiv: procedure (shadertype: GLenum; location: GLint; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetProgramStageiv: procedure (program_: GLuint; shadertype: GLenum; pname: GLenum; values: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedStringARB: procedure (type_: GLenum; namelen: GLint; name: PGLchar; stringlen: GLint; string_: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteNamedStringARB: procedure (namelen: GLint; name: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCompileShaderIncludeARB: procedure (shader: GLuint; count: GLsizei; path: PPGLchar; length: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsNamedStringARB: function (namelen: GLint; name: PGLchar): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetNamedStringARB: procedure (namelen: GLint; name: PGLchar; bufSize: GLsizei; stringlen: PGLint; string_: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetNamedStringivARB: procedure (namelen: GLint; name: PGLchar; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBufferPageCommitmentARB: procedure (target: GLenum; offset: GLintptr; size: GLsizeiptr; commit: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedBufferPageCommitmentEXT: procedure (buffer: GLuint; offset: GLintptr; size: GLsizeiptr; commit: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedBufferPageCommitmentARB: procedure (buffer: GLuint; offset: GLintptr; size: GLsizeiptr; commit: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexPageCommitmentARB: procedure (target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; width: GLsizei; height: GLsizei; depth: GLsizei; commit: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFenceSync: function (condition: GLenum; flags: GLbitfield): GLsync; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsSync: function (sync: GLsync): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteSync: procedure (sync: GLsync); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClientWaitSync: function (sync: GLsync; flags: GLbitfield; timeout: GLuint64): GLenum; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWaitSync: procedure (sync: GLsync; flags: GLbitfield; timeout: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetInteger64v: procedure (pname: GLenum; data: PGLint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetSynciv: procedure (sync: GLsync; pname: GLenum; count: GLsizei; length: PGLsizei; values: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPatchParameteri: procedure (pname: GLenum; value: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPatchParameterfv: procedure (pname: GLenum; values: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureBarrier: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexBufferARB: procedure (target: GLenum; internalformat: GLenum; buffer: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexBufferRange: procedure (target: GLenum; internalformat: GLenum; buffer: GLuint; offset: GLintptr; size: GLsizeiptr); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCompressedTexImage3DARB: procedure (target: GLenum; level: GLint; internalformat: GLenum; width: GLsizei; height: GLsizei; depth: GLsizei; border: GLint; imageSize: GLsizei; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCompressedTexImage2DARB: procedure (target: GLenum; level: GLint; internalformat: GLenum; width: GLsizei; height: GLsizei; border: GLint; imageSize: GLsizei; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCompressedTexImage1DARB: procedure (target: GLenum; level: GLint; internalformat: GLenum; width: GLsizei; border: GLint; imageSize: GLsizei; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCompressedTexSubImage3DARB: procedure (target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; width: GLsizei; height: GLsizei; depth: GLsizei; format: GLenum; imageSize: GLsizei; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCompressedTexSubImage2DARB: procedure (target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; width: GLsizei; height: GLsizei; format: GLenum; imageSize: GLsizei; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCompressedTexSubImage1DARB: procedure (target: GLenum; level: GLint; xoffset: GLint; width: GLsizei; format: GLenum; imageSize: GLsizei; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetCompressedTexImageARB: procedure (target: GLenum; level: GLint; img: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexImage2DMultisample: procedure (target: GLenum; samples: GLsizei; internalformat: GLenum; width: GLsizei; height: GLsizei; fixedsamplelocations: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexImage3DMultisample: procedure (target: GLenum; samples: GLsizei; internalformat: GLenum; width: GLsizei; height: GLsizei; depth: GLsizei; fixedsamplelocations: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetMultisamplefv: procedure (pname: GLenum; index: GLuint; val: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSampleMaski: procedure (maskNumber: GLuint; mask: GLbitfield); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexStorage1D: procedure (target: GLenum; levels: GLsizei; internalformat: GLenum; width: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexStorage2D: procedure (target: GLenum; levels: GLsizei; internalformat: GLenum; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexStorage3D: procedure (target: GLenum; levels: GLsizei; internalformat: GLenum; width: GLsizei; height: GLsizei; depth: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexStorage2DMultisample: procedure (target: GLenum; samples: GLsizei; internalformat: GLenum; width: GLsizei; height: GLsizei; fixedsamplelocations: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexStorage3DMultisample: procedure (target: GLenum; samples: GLsizei; internalformat: GLenum; width: GLsizei; height: GLsizei; depth: GLsizei; fixedsamplelocations: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureView: procedure (texture: GLuint; target: GLenum; origtexture: GLuint; internalformat: GLenum; minlevel: GLuint; numlevels: GLuint; minlayer: GLuint; numlayers: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glQueryCounter: procedure (id: GLuint; target: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetQueryObjecti64v: procedure (id: GLuint; pname: GLenum; params: PGLint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetQueryObjectui64v: procedure (id: GLuint; pname: GLenum; params: PGLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindTransformFeedback: procedure (target: GLenum; id: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteTransformFeedbacks: procedure (n: GLsizei; ids: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenTransformFeedbacks: procedure (n: GLsizei; ids: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsTransformFeedback: function (id: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPauseTransformFeedback: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glResumeTransformFeedback: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawTransformFeedback: procedure (mode: GLenum; id: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawTransformFeedbackStream: procedure (mode: GLenum; id: GLuint; stream: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBeginQueryIndexed: procedure (target: GLenum; index: GLuint; id: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEndQueryIndexed: procedure (target: GLenum; index: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetQueryIndexediv: procedure (target: GLenum; index: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawTransformFeedbackInstanced: procedure (mode: GLenum; id: GLuint; instancecount: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawTransformFeedbackStreamInstanced: procedure (mode: GLenum; id: GLuint; stream: GLuint; instancecount: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glLoadTransposeMatrixfARB: procedure (m: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glLoadTransposeMatrixdARB: procedure (m: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultTransposeMatrixfARB: procedure (m: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultTransposeMatrixdARB: procedure (m: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetUniformIndices: procedure (program_: GLuint; uniformCount: GLsizei; uniformNames: PPGLchar; uniformIndices: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetActiveUniformsiv: procedure (program_: GLuint; uniformCount: GLsizei; uniformIndices: PGLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetActiveUniformName: procedure (program_: GLuint; uniformIndex: GLuint; bufSize: GLsizei; length: PGLsizei; uniformName: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetUniformBlockIndex: function (program_: GLuint; uniformBlockName: PGLchar): GLuint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetActiveUniformBlockiv: procedure (program_: GLuint; uniformBlockIndex: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetActiveUniformBlockName: procedure (program_: GLuint; uniformBlockIndex: GLuint; bufSize: GLsizei; length: PGLsizei; uniformBlockName: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformBlockBinding: procedure (program_: GLuint; uniformBlockIndex: GLuint; uniformBlockBinding: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindBufferRange: procedure (target: GLenum; index: GLuint; buffer: GLuint; offset: GLintptr; size: GLsizeiptr); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindBufferBase: procedure (target: GLenum; index: GLuint; buffer: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetIntegeri_v: procedure (target: GLenum; index: GLuint; data: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindVertexArray: procedure (array_: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteVertexArrays: procedure (n: GLsizei; arrays: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenVertexArrays: procedure (n: GLsizei; arrays: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsVertexArray: function (array_: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribL1d: procedure (index: GLuint; x: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribL2d: procedure (index: GLuint; x: GLdouble; y: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribL3d: procedure (index: GLuint; x: GLdouble; y: GLdouble; z: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribL4d: procedure (index: GLuint; x: GLdouble; y: GLdouble; z: GLdouble; w: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribL1dv: procedure (index: GLuint; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribL2dv: procedure (index: GLuint; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribL3dv: procedure (index: GLuint; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribL4dv: procedure (index: GLuint; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribLPointer: procedure (index: GLuint; size: GLint; type_: GLenum; stride: GLsizei; pointer: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVertexAttribLdv: procedure (index: GLuint; pname: GLenum; params: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindVertexBuffer: procedure (bindingindex: GLuint; buffer: GLuint; offset: GLintptr; stride: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribFormat: procedure (attribindex: GLuint; size: GLint; type_: GLenum; normalized: GLboolean; relativeoffset: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribIFormat: procedure (attribindex: GLuint; size: GLint; type_: GLenum; relativeoffset: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribLFormat: procedure (attribindex: GLuint; size: GLint; type_: GLenum; relativeoffset: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribBinding: procedure (attribindex: GLuint; bindingindex: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexBindingDivisor: procedure (bindingindex: GLuint; divisor: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWeightbvARB: procedure (size: GLint; weights: PGLbyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWeightsvARB: procedure (size: GLint; weights: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWeightivARB: procedure (size: GLint; weights: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWeightfvARB: procedure (size: GLint; weights: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWeightdvARB: procedure (size: GLint; weights: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWeightubvARB: procedure (size: GLint; weights: PGLubyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWeightusvARB: procedure (size: GLint; weights: PGLushort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWeightuivARB: procedure (size: GLint; weights: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWeightPointerARB: procedure (size: GLint; type_: GLenum; stride: GLsizei; pointer: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexBlendARB: procedure (count: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindBufferARB: procedure (target: GLenum; buffer: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteBuffersARB: procedure (n: GLsizei; buffers: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenBuffersARB: procedure (n: GLsizei; buffers: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsBufferARB: function (buffer: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBufferDataARB: procedure (target: GLenum; size: GLsizeiptrARB; data: Pointer; usage: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBufferSubDataARB: procedure (target: GLenum; offset: GLintptrARB; size: GLsizeiptrARB; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetBufferSubDataARB: procedure (target: GLenum; offset: GLintptrARB; size: GLsizeiptrARB; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMapBufferARB: function (target: GLenum; access: GLenum): Pointer; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUnmapBufferARB: function (target: GLenum): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetBufferParameterivARB: procedure (target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetBufferPointervARB: procedure (target: GLenum; pname: GLenum; params: PPointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib1dARB: procedure (index: GLuint; x: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib1dvARB: procedure (index: GLuint; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib1fARB: procedure (index: GLuint; x: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib1fvARB: procedure (index: GLuint; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib1sARB: procedure (index: GLuint; x: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib1svARB: procedure (index: GLuint; v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib2dARB: procedure (index: GLuint; x: GLdouble; y: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib2dvARB: procedure (index: GLuint; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib2fARB: procedure (index: GLuint; x: GLfloat; y: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib2fvARB: procedure (index: GLuint; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib2sARB: procedure (index: GLuint; x: GLshort; y: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib2svARB: procedure (index: GLuint; v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib3dARB: procedure (index: GLuint; x: GLdouble; y: GLdouble; z: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib3dvARB: procedure (index: GLuint; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib3fARB: procedure (index: GLuint; x: GLfloat; y: GLfloat; z: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib3fvARB: procedure (index: GLuint; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib3sARB: procedure (index: GLuint; x: GLshort; y: GLshort; z: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib3svARB: procedure (index: GLuint; v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4NbvARB: procedure (index: GLuint; v: PGLbyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4NivARB: procedure (index: GLuint; v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4NsvARB: procedure (index: GLuint; v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4NubARB: procedure (index: GLuint; x: GLubyte; y: GLubyte; z: GLubyte; w: GLubyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4NubvARB: procedure (index: GLuint; v: PGLubyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4NuivARB: procedure (index: GLuint; v: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4NusvARB: procedure (index: GLuint; v: PGLushort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4bvARB: procedure (index: GLuint; v: PGLbyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4dARB: procedure (index: GLuint; x: GLdouble; y: GLdouble; z: GLdouble; w: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4dvARB: procedure (index: GLuint; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4fARB: procedure (index: GLuint; x: GLfloat; y: GLfloat; z: GLfloat; w: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4fvARB: procedure (index: GLuint; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4ivARB: procedure (index: GLuint; v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4sARB: procedure (index: GLuint; x: GLshort; y: GLshort; z: GLshort; w: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4svARB: procedure (index: GLuint; v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4ubvARB: procedure (index: GLuint; v: PGLubyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4uivARB: procedure (index: GLuint; v: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4usvARB: procedure (index: GLuint; v: PGLushort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribPointerARB: procedure (index: GLuint; size: GLint; type_: GLenum; normalized: GLboolean; stride: GLsizei; pointer: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEnableVertexAttribArrayARB: procedure (index: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDisableVertexAttribArrayARB: procedure (index: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVertexAttribdvARB: procedure (index: GLuint; pname: GLenum; params: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVertexAttribfvARB: procedure (index: GLuint; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVertexAttribivARB: procedure (index: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVertexAttribPointervARB: procedure (index: GLuint; pname: GLenum; pointer: PPointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindAttribLocationARB: procedure (programObj: GLhandleARB; index: GLuint; name: PGLcharARB); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetActiveAttribARB: procedure (programObj: GLhandleARB; index: GLuint; maxLength: GLsizei; length: PGLsizei; size: PGLint; type_: PGLenum; name: PGLcharARB); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetAttribLocationARB: function (programObj: GLhandleARB; name: PGLcharARB): GLint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribP1ui: procedure (index: GLuint; type_: GLenum; normalized: GLboolean; value: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribP1uiv: procedure (index: GLuint; type_: GLenum; normalized: GLboolean; value: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribP2ui: procedure (index: GLuint; type_: GLenum; normalized: GLboolean; value: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribP2uiv: procedure (index: GLuint; type_: GLenum; normalized: GLboolean; value: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribP3ui: procedure (index: GLuint; type_: GLenum; normalized: GLboolean; value: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribP3uiv: procedure (index: GLuint; type_: GLenum; normalized: GLboolean; value: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribP4ui: procedure (index: GLuint; type_: GLenum; normalized: GLboolean; value: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribP4uiv: procedure (index: GLuint; type_: GLenum; normalized: GLboolean; value: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexP2ui: procedure (type_: GLenum; value: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexP2uiv: procedure (type_: GLenum; value: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexP3ui: procedure (type_: GLenum; value: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexP3uiv: procedure (type_: GLenum; value: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexP4ui: procedure (type_: GLenum; value: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexP4uiv: procedure (type_: GLenum; value: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoordP1ui: procedure (type_: GLenum; coords: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoordP1uiv: procedure (type_: GLenum; coords: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoordP2ui: procedure (type_: GLenum; coords: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoordP2uiv: procedure (type_: GLenum; coords: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoordP3ui: procedure (type_: GLenum; coords: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoordP3uiv: procedure (type_: GLenum; coords: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoordP4ui: procedure (type_: GLenum; coords: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoordP4uiv: procedure (type_: GLenum; coords: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoordP1ui: procedure (texture: GLenum; type_: GLenum; coords: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoordP1uiv: procedure (texture: GLenum; type_: GLenum; coords: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoordP2ui: procedure (texture: GLenum; type_: GLenum; coords: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoordP2uiv: procedure (texture: GLenum; type_: GLenum; coords: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoordP3ui: procedure (texture: GLenum; type_: GLenum; coords: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoordP3uiv: procedure (texture: GLenum; type_: GLenum; coords: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoordP4ui: procedure (texture: GLenum; type_: GLenum; coords: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoordP4uiv: procedure (texture: GLenum; type_: GLenum; coords: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNormalP3ui: procedure (type_: GLenum; coords: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNormalP3uiv: procedure (type_: GLenum; coords: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColorP3ui: procedure (type_: GLenum; color: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColorP3uiv: procedure (type_: GLenum; color: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColorP4ui: procedure (type_: GLenum; color: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColorP4uiv: procedure (type_: GLenum; color: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSecondaryColorP3ui: procedure (type_: GLenum; color: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSecondaryColorP3uiv: procedure (type_: GLenum; color: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glViewportArrayv: procedure (first: GLuint; count: GLsizei; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glViewportIndexedf: procedure (index: GLuint; x: GLfloat; y: GLfloat; w: GLfloat; h: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glViewportIndexedfv: procedure (index: GLuint; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glScissorArrayv: procedure (first: GLuint; count: GLsizei; v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glScissorIndexed: procedure (index: GLuint; left: GLint; bottom: GLint; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glScissorIndexedv: procedure (index: GLuint; v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDepthRangeArrayv: procedure (first: GLuint; count: GLsizei; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDepthRangeIndexed: procedure (index: GLuint; n: GLdouble; f: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetFloati_v: procedure (target: GLenum; index: GLuint; data: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetDoublei_v: procedure (target: GLenum; index: GLuint; data: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDepthRangeArraydvNV: procedure (first: GLuint; count: GLsizei; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDepthRangeIndexeddNV: procedure (index: GLuint; n: GLdouble; f: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos2dARB: procedure (x: GLdouble; y: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos2dvARB: procedure (v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos2fARB: procedure (x: GLfloat; y: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos2fvARB: procedure (v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos2iARB: procedure (x: GLint; y: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos2ivARB: procedure (v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos2sARB: procedure (x: GLshort; y: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos2svARB: procedure (v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos3dARB: procedure (x: GLdouble; y: GLdouble; z: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos3dvARB: procedure (v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos3fARB: procedure (x: GLfloat; y: GLfloat; z: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos3fvARB: procedure (v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos3iARB: procedure (x: GLint; y: GLint; z: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos3ivARB: procedure (v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos3sARB: procedure (x: GLshort; y: GLshort; z: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos3svARB: procedure (v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawBuffersATI: procedure (n: GLsizei; bufs: PGLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glElementPointerATI: procedure (type_: GLenum; pointer: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawElementArrayATI: procedure (mode: GLenum; count: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawRangeElementArrayATI: procedure (mode: GLenum; start: GLuint; end_: GLuint; count: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexBumpParameterivATI: procedure (pname: GLenum; param: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexBumpParameterfvATI: procedure (pname: GLenum; param: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTexBumpParameterivATI: procedure (pname: GLenum; param: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTexBumpParameterfvATI: procedure (pname: GLenum; param: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenFragmentShadersATI: function (range: GLuint): GLuint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindFragmentShaderATI: procedure (id: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteFragmentShaderATI: procedure (id: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBeginFragmentShaderATI: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEndFragmentShaderATI: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPassTexCoordATI: procedure (dst: GLuint; coord: GLuint; swizzle: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSampleMapATI: procedure (dst: GLuint; interp: GLuint; swizzle: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColorFragmentOp1ATI: procedure (op: GLenum; dst: GLuint; dstMask: GLuint; dstMod: GLuint; arg1: GLuint; arg1Rep: GLuint; arg1Mod: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColorFragmentOp2ATI: procedure (op: GLenum; dst: GLuint; dstMask: GLuint; dstMod: GLuint; arg1: GLuint; arg1Rep: GLuint; arg1Mod: GLuint; arg2: GLuint; arg2Rep: GLuint; arg2Mod: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColorFragmentOp3ATI: procedure (op: GLenum; dst: GLuint; dstMask: GLuint; dstMod: GLuint; arg1: GLuint; arg1Rep: GLuint; arg1Mod: GLuint; arg2: GLuint; arg2Rep: GLuint; arg2Mod: GLuint; arg3: GLuint; arg3Rep: GLuint; arg3Mod: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glAlphaFragmentOp1ATI: procedure (op: GLenum; dst: GLuint; dstMod: GLuint; arg1: GLuint; arg1Rep: GLuint; arg1Mod: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glAlphaFragmentOp2ATI: procedure (op: GLenum; dst: GLuint; dstMod: GLuint; arg1: GLuint; arg1Rep: GLuint; arg1Mod: GLuint; arg2: GLuint; arg2Rep: GLuint; arg2Mod: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glAlphaFragmentOp3ATI: procedure (op: GLenum; dst: GLuint; dstMod: GLuint; arg1: GLuint; arg1Rep: GLuint; arg1Mod: GLuint; arg2: GLuint; arg2Rep: GLuint; arg2Mod: GLuint; arg3: GLuint; arg3Rep: GLuint; arg3Mod: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSetFragmentShaderConstantATI: procedure (dst: GLuint; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMapObjectBufferATI: function (buffer: GLuint): Pointer; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUnmapObjectBufferATI: procedure (buffer: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPNTrianglesiATI: procedure (pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPNTrianglesfATI: procedure (pname: GLenum; param: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glStencilOpSeparateATI: procedure (face: GLenum; sfail: GLenum; dpfail: GLenum; dppass: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glStencilFuncSeparateATI: procedure (frontfunc: GLenum; backfunc: GLenum; ref: GLint; mask: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNewObjectBufferATI: function (size: GLsizei; pointer: Pointer; usage: GLenum): GLuint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsObjectBufferATI: function (buffer: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUpdateObjectBufferATI: procedure (buffer: GLuint; offset: GLuint; size: GLsizei; pointer: Pointer; preserve: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetObjectBufferfvATI: procedure (buffer: GLuint; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetObjectBufferivATI: procedure (buffer: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFreeObjectBufferATI: procedure (buffer: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glArrayObjectATI: procedure (array_: GLenum; size: GLint; type_: GLenum; stride: GLsizei; buffer: GLuint; offset: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetArrayObjectfvATI: procedure (array_: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetArrayObjectivATI: procedure (array_: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVariantArrayObjectATI: procedure (id: GLuint; type_: GLenum; stride: GLsizei; buffer: GLuint; offset: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVariantArrayObjectfvATI: procedure (id: GLuint; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVariantArrayObjectivATI: procedure (id: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribArrayObjectATI: procedure (index: GLuint; size: GLint; type_: GLenum; normalized: GLboolean; stride: GLsizei; buffer: GLuint; offset: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVertexAttribArrayObjectfvATI: procedure (index: GLuint; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVertexAttribArrayObjectivATI: procedure (index: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexStream1sATI: procedure (stream: GLenum; x: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexStream1svATI: procedure (stream: GLenum; coords: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexStream1iATI: procedure (stream: GLenum; x: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexStream1ivATI: procedure (stream: GLenum; coords: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexStream1fATI: procedure (stream: GLenum; x: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexStream1fvATI: procedure (stream: GLenum; coords: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexStream1dATI: procedure (stream: GLenum; x: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexStream1dvATI: procedure (stream: GLenum; coords: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexStream2sATI: procedure (stream: GLenum; x: GLshort; y: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexStream2svATI: procedure (stream: GLenum; coords: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexStream2iATI: procedure (stream: GLenum; x: GLint; y: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexStream2ivATI: procedure (stream: GLenum; coords: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexStream2fATI: procedure (stream: GLenum; x: GLfloat; y: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexStream2fvATI: procedure (stream: GLenum; coords: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexStream2dATI: procedure (stream: GLenum; x: GLdouble; y: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexStream2dvATI: procedure (stream: GLenum; coords: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexStream3sATI: procedure (stream: GLenum; x: GLshort; y: GLshort; z: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexStream3svATI: procedure (stream: GLenum; coords: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexStream3iATI: procedure (stream: GLenum; x: GLint; y: GLint; z: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexStream3ivATI: procedure (stream: GLenum; coords: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexStream3fATI: procedure (stream: GLenum; x: GLfloat; y: GLfloat; z: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexStream3fvATI: procedure (stream: GLenum; coords: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexStream3dATI: procedure (stream: GLenum; x: GLdouble; y: GLdouble; z: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexStream3dvATI: procedure (stream: GLenum; coords: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexStream4sATI: procedure (stream: GLenum; x: GLshort; y: GLshort; z: GLshort; w: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexStream4svATI: procedure (stream: GLenum; coords: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexStream4iATI: procedure (stream: GLenum; x: GLint; y: GLint; z: GLint; w: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexStream4ivATI: procedure (stream: GLenum; coords: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexStream4fATI: procedure (stream: GLenum; x: GLfloat; y: GLfloat; z: GLfloat; w: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexStream4fvATI: procedure (stream: GLenum; coords: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexStream4dATI: procedure (stream: GLenum; x: GLdouble; y: GLdouble; z: GLdouble; w: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexStream4dvATI: procedure (stream: GLenum; coords: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNormalStream3bATI: procedure (stream: GLenum; nx: GLbyte; ny: GLbyte; nz: GLbyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNormalStream3bvATI: procedure (stream: GLenum; coords: PGLbyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNormalStream3sATI: procedure (stream: GLenum; nx: GLshort; ny: GLshort; nz: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNormalStream3svATI: procedure (stream: GLenum; coords: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNormalStream3iATI: procedure (stream: GLenum; nx: GLint; ny: GLint; nz: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNormalStream3ivATI: procedure (stream: GLenum; coords: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNormalStream3fATI: procedure (stream: GLenum; nx: GLfloat; ny: GLfloat; nz: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNormalStream3fvATI: procedure (stream: GLenum; coords: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNormalStream3dATI: procedure (stream: GLenum; nx: GLdouble; ny: GLdouble; nz: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNormalStream3dvATI: procedure (stream: GLenum; coords: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClientActiveVertexStreamATI: procedure (stream: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexBlendEnviATI: procedure (pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexBlendEnvfATI: procedure (pname: GLenum; param: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEGLImageTargetTexStorageEXT: procedure (target: GLenum; image: GLeglImageOES; attrib_list: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEGLImageTargetTextureStorageEXT: procedure (texture: GLuint; image: GLeglImageOES; attrib_list: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformBufferEXT: procedure (program_: GLuint; location: GLint; buffer: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetUniformBufferSizeEXT: function (program_: GLuint; location: GLint): GLint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetUniformOffsetEXT: function (program_: GLuint; location: GLint): GLintptr; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlendColorEXT: procedure (red: GLfloat; green: GLfloat; blue: GLfloat; alpha: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlendEquationSeparateEXT: procedure (modeRGB: GLenum; modeAlpha: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlendFuncSeparateEXT: procedure (sfactorRGB: GLenum; dfactorRGB: GLenum; sfactorAlpha: GLenum; dfactorAlpha: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlendEquationEXT: procedure (mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColorSubTableEXT: procedure (target: GLenum; start: GLsizei; count: GLsizei; format: GLenum; type_: GLenum; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyColorSubTableEXT: procedure (target: GLenum; start: GLsizei; x: GLint; y: GLint; width: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glLockArraysEXT: procedure (first: GLint; count: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUnlockArraysEXT: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glConvolutionFilter1DEXT: procedure (target: GLenum; internalformat: GLenum; width: GLsizei; format: GLenum; type_: GLenum; image: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glConvolutionFilter2DEXT: procedure (target: GLenum; internalformat: GLenum; width: GLsizei; height: GLsizei; format: GLenum; type_: GLenum; image: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glConvolutionParameterfEXT: procedure (target: GLenum; pname: GLenum; params: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glConvolutionParameterfvEXT: procedure (target: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glConvolutionParameteriEXT: procedure (target: GLenum; pname: GLenum; params: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glConvolutionParameterivEXT: procedure (target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyConvolutionFilter1DEXT: procedure (target: GLenum; internalformat: GLenum; x: GLint; y: GLint; width: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyConvolutionFilter2DEXT: procedure (target: GLenum; internalformat: GLenum; x: GLint; y: GLint; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetConvolutionFilterEXT: procedure (target: GLenum; format: GLenum; type_: GLenum; image: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetConvolutionParameterfvEXT: procedure (target: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetConvolutionParameterivEXT: procedure (target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetSeparableFilterEXT: procedure (target: GLenum; format: GLenum; type_: GLenum; row: Pointer; column: Pointer; span: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSeparableFilter2DEXT: procedure (target: GLenum; internalformat: GLenum; width: GLsizei; height: GLsizei; format: GLenum; type_: GLenum; row: Pointer; column: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTangent3bEXT: procedure (tx: GLbyte; ty: GLbyte; tz: GLbyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTangent3bvEXT: procedure (v: PGLbyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTangent3dEXT: procedure (tx: GLdouble; ty: GLdouble; tz: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTangent3dvEXT: procedure (v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTangent3fEXT: procedure (tx: GLfloat; ty: GLfloat; tz: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTangent3fvEXT: procedure (v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTangent3iEXT: procedure (tx: GLint; ty: GLint; tz: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTangent3ivEXT: procedure (v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTangent3sEXT: procedure (tx: GLshort; ty: GLshort; tz: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTangent3svEXT: procedure (v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBinormal3bEXT: procedure (bx: GLbyte; by: GLbyte; bz: GLbyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBinormal3bvEXT: procedure (v: PGLbyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBinormal3dEXT: procedure (bx: GLdouble; by: GLdouble; bz: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBinormal3dvEXT: procedure (v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBinormal3fEXT: procedure (bx: GLfloat; by: GLfloat; bz: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBinormal3fvEXT: procedure (v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBinormal3iEXT: procedure (bx: GLint; by: GLint; bz: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBinormal3ivEXT: procedure (v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBinormal3sEXT: procedure (bx: GLshort; by: GLshort; bz: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBinormal3svEXT: procedure (v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTangentPointerEXT: procedure (type_: GLenum; stride: GLsizei; pointer: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBinormalPointerEXT: procedure (type_: GLenum; stride: GLsizei; pointer: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyTexImage1DEXT: procedure (target: GLenum; level: GLint; internalformat: GLenum; x: GLint; y: GLint; width: GLsizei; border: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyTexImage2DEXT: procedure (target: GLenum; level: GLint; internalformat: GLenum; x: GLint; y: GLint; width: GLsizei; height: GLsizei; border: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyTexSubImage1DEXT: procedure (target: GLenum; level: GLint; xoffset: GLint; x: GLint; y: GLint; width: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyTexSubImage2DEXT: procedure (target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; x: GLint; y: GLint; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyTexSubImage3DEXT: procedure (target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; x: GLint; y: GLint; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCullParameterdvEXT: procedure (pname: GLenum; params: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCullParameterfvEXT: procedure (pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glLabelObjectEXT: procedure (type_: GLenum; object_: GLuint; length: GLsizei; label_: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetObjectLabelEXT: procedure (type_: GLenum; object_: GLuint; bufSize: GLsizei; length: PGLsizei; label_: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glInsertEventMarkerEXT: procedure (length: GLsizei; marker: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPushGroupMarkerEXT: procedure (length: GLsizei; marker: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPopGroupMarkerEXT: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDepthBoundsEXT: procedure (zmin: GLclampd; zmax: GLclampd); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixLoadfEXT: procedure (mode: GLenum; m: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixLoaddEXT: procedure (mode: GLenum; m: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixMultfEXT: procedure (mode: GLenum; m: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixMultdEXT: procedure (mode: GLenum; m: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixLoadIdentityEXT: procedure (mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixRotatefEXT: procedure (mode: GLenum; angle: GLfloat; x: GLfloat; y: GLfloat; z: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixRotatedEXT: procedure (mode: GLenum; angle: GLdouble; x: GLdouble; y: GLdouble; z: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixScalefEXT: procedure (mode: GLenum; x: GLfloat; y: GLfloat; z: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixScaledEXT: procedure (mode: GLenum; x: GLdouble; y: GLdouble; z: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixTranslatefEXT: procedure (mode: GLenum; x: GLfloat; y: GLfloat; z: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixTranslatedEXT: procedure (mode: GLenum; x: GLdouble; y: GLdouble; z: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixFrustumEXT: procedure (mode: GLenum; left: GLdouble; right: GLdouble; bottom: GLdouble; top: GLdouble; zNear: GLdouble; zFar: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixOrthoEXT: procedure (mode: GLenum; left: GLdouble; right: GLdouble; bottom: GLdouble; top: GLdouble; zNear: GLdouble; zFar: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixPopEXT: procedure (mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixPushEXT: procedure (mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClientAttribDefaultEXT: procedure (mask: GLbitfield); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPushClientAttribDefaultEXT: procedure (mask: GLbitfield); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureParameterfEXT: procedure (texture: GLuint; target: GLenum; pname: GLenum; param: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureParameterfvEXT: procedure (texture: GLuint; target: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureParameteriEXT: procedure (texture: GLuint; target: GLenum; pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureParameterivEXT: procedure (texture: GLuint; target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureImage1DEXT: procedure (texture: GLuint; target: GLenum; level: GLint; internalformat: GLint; width: GLsizei; border: GLint; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureImage2DEXT: procedure (texture: GLuint; target: GLenum; level: GLint; internalformat: GLint; width: GLsizei; height: GLsizei; border: GLint; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureSubImage1DEXT: procedure (texture: GLuint; target: GLenum; level: GLint; xoffset: GLint; width: GLsizei; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureSubImage2DEXT: procedure (texture: GLuint; target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; width: GLsizei; height: GLsizei; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyTextureImage1DEXT: procedure (texture: GLuint; target: GLenum; level: GLint; internalformat: GLenum; x: GLint; y: GLint; width: GLsizei; border: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyTextureImage2DEXT: procedure (texture: GLuint; target: GLenum; level: GLint; internalformat: GLenum; x: GLint; y: GLint; width: GLsizei; height: GLsizei; border: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyTextureSubImage1DEXT: procedure (texture: GLuint; target: GLenum; level: GLint; xoffset: GLint; x: GLint; y: GLint; width: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyTextureSubImage2DEXT: procedure (texture: GLuint; target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; x: GLint; y: GLint; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTextureImageEXT: procedure (texture: GLuint; target: GLenum; level: GLint; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTextureParameterfvEXT: procedure (texture: GLuint; target: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTextureParameterivEXT: procedure (texture: GLuint; target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTextureLevelParameterfvEXT: procedure (texture: GLuint; target: GLenum; level: GLint; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTextureLevelParameterivEXT: procedure (texture: GLuint; target: GLenum; level: GLint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureImage3DEXT: procedure (texture: GLuint; target: GLenum; level: GLint; internalformat: GLint; width: GLsizei; height: GLsizei; depth: GLsizei; border: GLint; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureSubImage3DEXT: procedure (texture: GLuint; target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; width: GLsizei; height: GLsizei; depth: GLsizei; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyTextureSubImage3DEXT: procedure (texture: GLuint; target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; x: GLint; y: GLint; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindMultiTextureEXT: procedure (texunit: GLenum; target: GLenum; texture: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoordPointerEXT: procedure (texunit: GLenum; size: GLint; type_: GLenum; stride: GLsizei; pointer: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexEnvfEXT: procedure (texunit: GLenum; target: GLenum; pname: GLenum; param: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexEnvfvEXT: procedure (texunit: GLenum; target: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexEnviEXT: procedure (texunit: GLenum; target: GLenum; pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexEnvivEXT: procedure (texunit: GLenum; target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexGendEXT: procedure (texunit: GLenum; coord: GLenum; pname: GLenum; param: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexGendvEXT: procedure (texunit: GLenum; coord: GLenum; pname: GLenum; params: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexGenfEXT: procedure (texunit: GLenum; coord: GLenum; pname: GLenum; param: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexGenfvEXT: procedure (texunit: GLenum; coord: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexGeniEXT: procedure (texunit: GLenum; coord: GLenum; pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexGenivEXT: procedure (texunit: GLenum; coord: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetMultiTexEnvfvEXT: procedure (texunit: GLenum; target: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetMultiTexEnvivEXT: procedure (texunit: GLenum; target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetMultiTexGendvEXT: procedure (texunit: GLenum; coord: GLenum; pname: GLenum; params: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetMultiTexGenfvEXT: procedure (texunit: GLenum; coord: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetMultiTexGenivEXT: procedure (texunit: GLenum; coord: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexParameteriEXT: procedure (texunit: GLenum; target: GLenum; pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexParameterivEXT: procedure (texunit: GLenum; target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexParameterfEXT: procedure (texunit: GLenum; target: GLenum; pname: GLenum; param: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexParameterfvEXT: procedure (texunit: GLenum; target: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexImage1DEXT: procedure (texunit: GLenum; target: GLenum; level: GLint; internalformat: GLint; width: GLsizei; border: GLint; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexImage2DEXT: procedure (texunit: GLenum; target: GLenum; level: GLint; internalformat: GLint; width: GLsizei; height: GLsizei; border: GLint; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexSubImage1DEXT: procedure (texunit: GLenum; target: GLenum; level: GLint; xoffset: GLint; width: GLsizei; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexSubImage2DEXT: procedure (texunit: GLenum; target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; width: GLsizei; height: GLsizei; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyMultiTexImage1DEXT: procedure (texunit: GLenum; target: GLenum; level: GLint; internalformat: GLenum; x: GLint; y: GLint; width: GLsizei; border: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyMultiTexImage2DEXT: procedure (texunit: GLenum; target: GLenum; level: GLint; internalformat: GLenum; x: GLint; y: GLint; width: GLsizei; height: GLsizei; border: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyMultiTexSubImage1DEXT: procedure (texunit: GLenum; target: GLenum; level: GLint; xoffset: GLint; x: GLint; y: GLint; width: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyMultiTexSubImage2DEXT: procedure (texunit: GLenum; target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; x: GLint; y: GLint; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetMultiTexImageEXT: procedure (texunit: GLenum; target: GLenum; level: GLint; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetMultiTexParameterfvEXT: procedure (texunit: GLenum; target: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetMultiTexParameterivEXT: procedure (texunit: GLenum; target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetMultiTexLevelParameterfvEXT: procedure (texunit: GLenum; target: GLenum; level: GLint; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetMultiTexLevelParameterivEXT: procedure (texunit: GLenum; target: GLenum; level: GLint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexImage3DEXT: procedure (texunit: GLenum; target: GLenum; level: GLint; internalformat: GLint; width: GLsizei; height: GLsizei; depth: GLsizei; border: GLint; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexSubImage3DEXT: procedure (texunit: GLenum; target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; width: GLsizei; height: GLsizei; depth: GLsizei; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyMultiTexSubImage3DEXT: procedure (texunit: GLenum; target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; x: GLint; y: GLint; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEnableClientStateIndexedEXT: procedure (array_: GLenum; index: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDisableClientStateIndexedEXT: procedure (array_: GLenum; index: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetFloatIndexedvEXT: procedure (target: GLenum; index: GLuint; data: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetDoubleIndexedvEXT: procedure (target: GLenum; index: GLuint; data: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPointerIndexedvEXT: procedure (target: GLenum; index: GLuint; data: PPointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEnableIndexedEXT: procedure (target: GLenum; index: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDisableIndexedEXT: procedure (target: GLenum; index: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsEnabledIndexedEXT: function (target: GLenum; index: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetIntegerIndexedvEXT: procedure (target: GLenum; index: GLuint; data: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetBooleanIndexedvEXT: procedure (target: GLenum; index: GLuint; data: PGLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCompressedTextureImage3DEXT: procedure (texture: GLuint; target: GLenum; level: GLint; internalformat: GLenum; width: GLsizei; height: GLsizei; depth: GLsizei; border: GLint; imageSize: GLsizei; bits: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCompressedTextureImage2DEXT: procedure (texture: GLuint; target: GLenum; level: GLint; internalformat: GLenum; width: GLsizei; height: GLsizei; border: GLint; imageSize: GLsizei; bits: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCompressedTextureImage1DEXT: procedure (texture: GLuint; target: GLenum; level: GLint; internalformat: GLenum; width: GLsizei; border: GLint; imageSize: GLsizei; bits: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCompressedTextureSubImage3DEXT: procedure (texture: GLuint; target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; width: GLsizei; height: GLsizei; depth: GLsizei; format: GLenum; imageSize: GLsizei; bits: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCompressedTextureSubImage2DEXT: procedure (texture: GLuint; target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; width: GLsizei; height: GLsizei; format: GLenum; imageSize: GLsizei; bits: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCompressedTextureSubImage1DEXT: procedure (texture: GLuint; target: GLenum; level: GLint; xoffset: GLint; width: GLsizei; format: GLenum; imageSize: GLsizei; bits: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetCompressedTextureImageEXT: procedure (texture: GLuint; target: GLenum; lod: GLint; img: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCompressedMultiTexImage3DEXT: procedure (texunit: GLenum; target: GLenum; level: GLint; internalformat: GLenum; width: GLsizei; height: GLsizei; depth: GLsizei; border: GLint; imageSize: GLsizei; bits: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCompressedMultiTexImage2DEXT: procedure (texunit: GLenum; target: GLenum; level: GLint; internalformat: GLenum; width: GLsizei; height: GLsizei; border: GLint; imageSize: GLsizei; bits: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCompressedMultiTexImage1DEXT: procedure (texunit: GLenum; target: GLenum; level: GLint; internalformat: GLenum; width: GLsizei; border: GLint; imageSize: GLsizei; bits: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCompressedMultiTexSubImage3DEXT: procedure (texunit: GLenum; target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; width: GLsizei; height: GLsizei; depth: GLsizei; format: GLenum; imageSize: GLsizei; bits: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCompressedMultiTexSubImage2DEXT: procedure (texunit: GLenum; target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; width: GLsizei; height: GLsizei; format: GLenum; imageSize: GLsizei; bits: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCompressedMultiTexSubImage1DEXT: procedure (texunit: GLenum; target: GLenum; level: GLint; xoffset: GLint; width: GLsizei; format: GLenum; imageSize: GLsizei; bits: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetCompressedMultiTexImageEXT: procedure (texunit: GLenum; target: GLenum; lod: GLint; img: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixLoadTransposefEXT: procedure (mode: GLenum; m: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixLoadTransposedEXT: procedure (mode: GLenum; m: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixMultTransposefEXT: procedure (mode: GLenum; m: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixMultTransposedEXT: procedure (mode: GLenum; m: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedBufferDataEXT: procedure (buffer: GLuint; size: GLsizeiptr; data: Pointer; usage: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedBufferSubDataEXT: procedure (buffer: GLuint; offset: GLintptr; size: GLsizeiptr; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMapNamedBufferEXT: function (buffer: GLuint; access: GLenum): Pointer; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUnmapNamedBufferEXT: function (buffer: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetNamedBufferParameterivEXT: procedure (buffer: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetNamedBufferPointervEXT: procedure (buffer: GLuint; pname: GLenum; params: PPointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetNamedBufferSubDataEXT: procedure (buffer: GLuint; offset: GLintptr; size: GLsizeiptr; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform1fEXT: procedure (program_: GLuint; location: GLint; v0: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform2fEXT: procedure (program_: GLuint; location: GLint; v0: GLfloat; v1: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform3fEXT: procedure (program_: GLuint; location: GLint; v0: GLfloat; v1: GLfloat; v2: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform4fEXT: procedure (program_: GLuint; location: GLint; v0: GLfloat; v1: GLfloat; v2: GLfloat; v3: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform1iEXT: procedure (program_: GLuint; location: GLint; v0: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform2iEXT: procedure (program_: GLuint; location: GLint; v0: GLint; v1: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform3iEXT: procedure (program_: GLuint; location: GLint; v0: GLint; v1: GLint; v2: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform4iEXT: procedure (program_: GLuint; location: GLint; v0: GLint; v1: GLint; v2: GLint; v3: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform1fvEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform2fvEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform3fvEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform4fvEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform1ivEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform2ivEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform3ivEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform4ivEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformMatrix2fvEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformMatrix3fvEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformMatrix4fvEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformMatrix2x3fvEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformMatrix3x2fvEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformMatrix2x4fvEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformMatrix4x2fvEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformMatrix3x4fvEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformMatrix4x3fvEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureBufferEXT: procedure (texture: GLuint; target: GLenum; internalformat: GLenum; buffer: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexBufferEXT: procedure (texunit: GLenum; target: GLenum; internalformat: GLenum; buffer: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureParameterIivEXT: procedure (texture: GLuint; target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureParameterIuivEXT: procedure (texture: GLuint; target: GLenum; pname: GLenum; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTextureParameterIivEXT: procedure (texture: GLuint; target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTextureParameterIuivEXT: procedure (texture: GLuint; target: GLenum; pname: GLenum; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexParameterIivEXT: procedure (texunit: GLenum; target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexParameterIuivEXT: procedure (texunit: GLenum; target: GLenum; pname: GLenum; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetMultiTexParameterIivEXT: procedure (texunit: GLenum; target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetMultiTexParameterIuivEXT: procedure (texunit: GLenum; target: GLenum; pname: GLenum; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform1uiEXT: procedure (program_: GLuint; location: GLint; v0: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform2uiEXT: procedure (program_: GLuint; location: GLint; v0: GLuint; v1: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform3uiEXT: procedure (program_: GLuint; location: GLint; v0: GLuint; v1: GLuint; v2: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform4uiEXT: procedure (program_: GLuint; location: GLint; v0: GLuint; v1: GLuint; v2: GLuint; v3: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform1uivEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform2uivEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform3uivEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform4uivEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedProgramLocalParameters4fvEXT: procedure (program_: GLuint; target: GLenum; index: GLuint; count: GLsizei; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedProgramLocalParameterI4iEXT: procedure (program_: GLuint; target: GLenum; index: GLuint; x: GLint; y: GLint; z: GLint; w: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedProgramLocalParameterI4ivEXT: procedure (program_: GLuint; target: GLenum; index: GLuint; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedProgramLocalParametersI4ivEXT: procedure (program_: GLuint; target: GLenum; index: GLuint; count: GLsizei; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedProgramLocalParameterI4uiEXT: procedure (program_: GLuint; target: GLenum; index: GLuint; x: GLuint; y: GLuint; z: GLuint; w: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedProgramLocalParameterI4uivEXT: procedure (program_: GLuint; target: GLenum; index: GLuint; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedProgramLocalParametersI4uivEXT: procedure (program_: GLuint; target: GLenum; index: GLuint; count: GLsizei; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetNamedProgramLocalParameterIivEXT: procedure (program_: GLuint; target: GLenum; index: GLuint; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetNamedProgramLocalParameterIuivEXT: procedure (program_: GLuint; target: GLenum; index: GLuint; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEnableClientStateiEXT: procedure (array_: GLenum; index: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDisableClientStateiEXT: procedure (array_: GLenum; index: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetFloati_vEXT: procedure (pname: GLenum; index: GLuint; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetDoublei_vEXT: procedure (pname: GLenum; index: GLuint; params: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPointeri_vEXT: procedure (pname: GLenum; index: GLuint; params: PPointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedProgramStringEXT: procedure (program_: GLuint; target: GLenum; format: GLenum; len: GLsizei; string_: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedProgramLocalParameter4dEXT: procedure (program_: GLuint; target: GLenum; index: GLuint; x: GLdouble; y: GLdouble; z: GLdouble; w: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedProgramLocalParameter4dvEXT: procedure (program_: GLuint; target: GLenum; index: GLuint; params: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedProgramLocalParameter4fEXT: procedure (program_: GLuint; target: GLenum; index: GLuint; x: GLfloat; y: GLfloat; z: GLfloat; w: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedProgramLocalParameter4fvEXT: procedure (program_: GLuint; target: GLenum; index: GLuint; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetNamedProgramLocalParameterdvEXT: procedure (program_: GLuint; target: GLenum; index: GLuint; params: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetNamedProgramLocalParameterfvEXT: procedure (program_: GLuint; target: GLenum; index: GLuint; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetNamedProgramivEXT: procedure (program_: GLuint; target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetNamedProgramStringEXT: procedure (program_: GLuint; target: GLenum; pname: GLenum; string_: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedRenderbufferStorageEXT: procedure (renderbuffer: GLuint; internalformat: GLenum; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetNamedRenderbufferParameterivEXT: procedure (renderbuffer: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedRenderbufferStorageMultisampleEXT: procedure (renderbuffer: GLuint; samples: GLsizei; internalformat: GLenum; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedRenderbufferStorageMultisampleCoverageEXT: procedure (renderbuffer: GLuint; coverageSamples: GLsizei; colorSamples: GLsizei; internalformat: GLenum; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCheckNamedFramebufferStatusEXT: function (framebuffer: GLuint; target: GLenum): GLenum; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedFramebufferTexture1DEXT: procedure (framebuffer: GLuint; attachment: GLenum; textarget: GLenum; texture: GLuint; level: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedFramebufferTexture2DEXT: procedure (framebuffer: GLuint; attachment: GLenum; textarget: GLenum; texture: GLuint; level: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedFramebufferTexture3DEXT: procedure (framebuffer: GLuint; attachment: GLenum; textarget: GLenum; texture: GLuint; level: GLint; zoffset: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedFramebufferRenderbufferEXT: procedure (framebuffer: GLuint; attachment: GLenum; renderbuffertarget: GLenum; renderbuffer: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetNamedFramebufferAttachmentParameterivEXT: procedure (framebuffer: GLuint; attachment: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenerateTextureMipmapEXT: procedure (texture: GLuint; target: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenerateMultiTexMipmapEXT: procedure (texunit: GLenum; target: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFramebufferDrawBufferEXT: procedure (framebuffer: GLuint; mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFramebufferDrawBuffersEXT: procedure (framebuffer: GLuint; n: GLsizei; bufs: PGLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFramebufferReadBufferEXT: procedure (framebuffer: GLuint; mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetFramebufferParameterivEXT: procedure (framebuffer: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedCopyBufferSubDataEXT: procedure (readBuffer: GLuint; writeBuffer: GLuint; readOffset: GLintptr; writeOffset: GLintptr; size: GLsizeiptr); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedFramebufferTextureEXT: procedure (framebuffer: GLuint; attachment: GLenum; texture: GLuint; level: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedFramebufferTextureLayerEXT: procedure (framebuffer: GLuint; attachment: GLenum; texture: GLuint; level: GLint; layer: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedFramebufferTextureFaceEXT: procedure (framebuffer: GLuint; attachment: GLenum; texture: GLuint; level: GLint; face: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureRenderbufferEXT: procedure (texture: GLuint; target: GLenum; renderbuffer: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexRenderbufferEXT: procedure (texunit: GLenum; target: GLenum; renderbuffer: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexArrayVertexOffsetEXT: procedure (vaobj: GLuint; buffer: GLuint; size: GLint; type_: GLenum; stride: GLsizei; offset: GLintptr); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexArrayColorOffsetEXT: procedure (vaobj: GLuint; buffer: GLuint; size: GLint; type_: GLenum; stride: GLsizei; offset: GLintptr); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexArrayEdgeFlagOffsetEXT: procedure (vaobj: GLuint; buffer: GLuint; stride: GLsizei; offset: GLintptr); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexArrayIndexOffsetEXT: procedure (vaobj: GLuint; buffer: GLuint; type_: GLenum; stride: GLsizei; offset: GLintptr); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexArrayNormalOffsetEXT: procedure (vaobj: GLuint; buffer: GLuint; type_: GLenum; stride: GLsizei; offset: GLintptr); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexArrayTexCoordOffsetEXT: procedure (vaobj: GLuint; buffer: GLuint; size: GLint; type_: GLenum; stride: GLsizei; offset: GLintptr); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexArrayMultiTexCoordOffsetEXT: procedure (vaobj: GLuint; buffer: GLuint; texunit: GLenum; size: GLint; type_: GLenum; stride: GLsizei; offset: GLintptr); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexArrayFogCoordOffsetEXT: procedure (vaobj: GLuint; buffer: GLuint; type_: GLenum; stride: GLsizei; offset: GLintptr); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexArraySecondaryColorOffsetEXT: procedure (vaobj: GLuint; buffer: GLuint; size: GLint; type_: GLenum; stride: GLsizei; offset: GLintptr); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexArrayVertexAttribOffsetEXT: procedure (vaobj: GLuint; buffer: GLuint; index: GLuint; size: GLint; type_: GLenum; normalized: GLboolean; stride: GLsizei; offset: GLintptr); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexArrayVertexAttribIOffsetEXT: procedure (vaobj: GLuint; buffer: GLuint; index: GLuint; size: GLint; type_: GLenum; stride: GLsizei; offset: GLintptr); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEnableVertexArrayEXT: procedure (vaobj: GLuint; array_: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDisableVertexArrayEXT: procedure (vaobj: GLuint; array_: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEnableVertexArrayAttribEXT: procedure (vaobj: GLuint; index: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDisableVertexArrayAttribEXT: procedure (vaobj: GLuint; index: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVertexArrayIntegervEXT: procedure (vaobj: GLuint; pname: GLenum; param: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVertexArrayPointervEXT: procedure (vaobj: GLuint; pname: GLenum; param: PPointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVertexArrayIntegeri_vEXT: procedure (vaobj: GLuint; index: GLuint; pname: GLenum; param: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVertexArrayPointeri_vEXT: procedure (vaobj: GLuint; index: GLuint; pname: GLenum; param: PPointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMapNamedBufferRangeEXT: function (buffer: GLuint; offset: GLintptr; length: GLsizeiptr; access: GLbitfield): Pointer; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFlushMappedNamedBufferRangeEXT: procedure (buffer: GLuint; offset: GLintptr; length: GLsizeiptr); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedBufferStorageEXT: procedure (buffer: GLuint; size: GLsizeiptr; data: Pointer; flags: GLbitfield); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClearNamedBufferDataEXT: procedure (buffer: GLuint; internalformat: GLenum; format: GLenum; type_: GLenum; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClearNamedBufferSubDataEXT: procedure (buffer: GLuint; internalformat: GLenum; offset: GLsizeiptr; size: GLsizeiptr; format: GLenum; type_: GLenum; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedFramebufferParameteriEXT: procedure (framebuffer: GLuint; pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetNamedFramebufferParameterivEXT: procedure (framebuffer: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform1dEXT: procedure (program_: GLuint; location: GLint; x: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform2dEXT: procedure (program_: GLuint; location: GLint; x: GLdouble; y: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform3dEXT: procedure (program_: GLuint; location: GLint; x: GLdouble; y: GLdouble; z: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform4dEXT: procedure (program_: GLuint; location: GLint; x: GLdouble; y: GLdouble; z: GLdouble; w: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform1dvEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform2dvEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform3dvEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform4dvEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformMatrix2dvEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; transpose: GLboolean; value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformMatrix3dvEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; transpose: GLboolean; value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformMatrix4dvEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; transpose: GLboolean; value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformMatrix2x3dvEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; transpose: GLboolean; value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformMatrix2x4dvEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; transpose: GLboolean; value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformMatrix3x2dvEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; transpose: GLboolean; value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformMatrix3x4dvEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; transpose: GLboolean; value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformMatrix4x2dvEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; transpose: GLboolean; value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformMatrix4x3dvEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; transpose: GLboolean; value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureBufferRangeEXT: procedure (texture: GLuint; target: GLenum; internalformat: GLenum; buffer: GLuint; offset: GLintptr; size: GLsizeiptr); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureStorage1DEXT: procedure (texture: GLuint; target: GLenum; levels: GLsizei; internalformat: GLenum; width: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureStorage2DEXT: procedure (texture: GLuint; target: GLenum; levels: GLsizei; internalformat: GLenum; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureStorage3DEXT: procedure (texture: GLuint; target: GLenum; levels: GLsizei; internalformat: GLenum; width: GLsizei; height: GLsizei; depth: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureStorage2DMultisampleEXT: procedure (texture: GLuint; target: GLenum; samples: GLsizei; internalformat: GLenum; width: GLsizei; height: GLsizei; fixedsamplelocations: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureStorage3DMultisampleEXT: procedure (texture: GLuint; target: GLenum; samples: GLsizei; internalformat: GLenum; width: GLsizei; height: GLsizei; depth: GLsizei; fixedsamplelocations: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexArrayBindVertexBufferEXT: procedure (vaobj: GLuint; bindingindex: GLuint; buffer: GLuint; offset: GLintptr; stride: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexArrayVertexAttribFormatEXT: procedure (vaobj: GLuint; attribindex: GLuint; size: GLint; type_: GLenum; normalized: GLboolean; relativeoffset: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexArrayVertexAttribIFormatEXT: procedure (vaobj: GLuint; attribindex: GLuint; size: GLint; type_: GLenum; relativeoffset: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexArrayVertexAttribLFormatEXT: procedure (vaobj: GLuint; attribindex: GLuint; size: GLint; type_: GLenum; relativeoffset: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexArrayVertexAttribBindingEXT: procedure (vaobj: GLuint; attribindex: GLuint; bindingindex: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexArrayVertexBindingDivisorEXT: procedure (vaobj: GLuint; bindingindex: GLuint; divisor: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexArrayVertexAttribLOffsetEXT: procedure (vaobj: GLuint; buffer: GLuint; index: GLuint; size: GLint; type_: GLenum; stride: GLsizei; offset: GLintptr); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexturePageCommitmentEXT: procedure (texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; width: GLsizei; height: GLsizei; depth: GLsizei; commit: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexArrayVertexAttribDivisorEXT: procedure (vaobj: GLuint; index: GLuint; divisor: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColorMaskIndexedEXT: procedure (index: GLuint; r: GLboolean; g: GLboolean; b: GLboolean; a: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawArraysInstancedEXT: procedure (mode: GLenum; start: GLint; count: GLsizei; primcount: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawElementsInstancedEXT: procedure (mode: GLenum; count: GLsizei; type_: GLenum; indices: Pointer; primcount: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawRangeElementsEXT: procedure (mode: GLenum; start: GLuint; end_: GLuint; count: GLsizei; type_: GLenum; indices: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBufferStorageExternalEXT: procedure (target: GLenum; offset: GLintptr; size: GLsizeiptr; clientBuffer: GLeglClientBufferEXT; flags: GLbitfield); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedBufferStorageExternalEXT: procedure (buffer: GLuint; offset: GLintptr; size: GLsizeiptr; clientBuffer: GLeglClientBufferEXT; flags: GLbitfield); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFogCoordfEXT: procedure (coord: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFogCoordfvEXT: procedure (coord: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFogCoorddEXT: procedure (coord: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFogCoorddvEXT: procedure (coord: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFogCoordPointerEXT: procedure (type_: GLenum; stride: GLsizei; pointer: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlitFramebufferEXT: procedure (srcX0: GLint; srcY0: GLint; srcX1: GLint; srcY1: GLint; dstX0: GLint; dstY0: GLint; dstX1: GLint; dstY1: GLint; mask: GLbitfield; filter: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlitFramebufferLayersEXT: procedure (srcX0: GLint; srcY0: GLint; srcX1: GLint; srcY1: GLint; dstX0: GLint; dstY0: GLint; dstX1: GLint; dstY1: GLint; mask: GLbitfield; filter: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlitFramebufferLayerEXT: procedure (srcX0: GLint; srcY0: GLint; srcX1: GLint; srcY1: GLint; srcLayer: GLint; dstX0: GLint; dstY0: GLint; dstX1: GLint; dstY1: GLint; dstLayer: GLint; mask: GLbitfield; filter: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRenderbufferStorageMultisampleEXT: procedure (target: GLenum; samples: GLsizei; internalformat: GLenum; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsRenderbufferEXT: function (renderbuffer: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindRenderbufferEXT: procedure (target: GLenum; renderbuffer: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteRenderbuffersEXT: procedure (n: GLsizei; renderbuffers: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenRenderbuffersEXT: procedure (n: GLsizei; renderbuffers: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRenderbufferStorageEXT: procedure (target: GLenum; internalformat: GLenum; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetRenderbufferParameterivEXT: procedure (target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsFramebufferEXT: function (framebuffer: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindFramebufferEXT: procedure (target: GLenum; framebuffer: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteFramebuffersEXT: procedure (n: GLsizei; framebuffers: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenFramebuffersEXT: procedure (n: GLsizei; framebuffers: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCheckFramebufferStatusEXT: function (target: GLenum): GLenum; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFramebufferTexture1DEXT: procedure (target: GLenum; attachment: GLenum; textarget: GLenum; texture: GLuint; level: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFramebufferTexture2DEXT: procedure (target: GLenum; attachment: GLenum; textarget: GLenum; texture: GLuint; level: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFramebufferTexture3DEXT: procedure (target: GLenum; attachment: GLenum; textarget: GLenum; texture: GLuint; level: GLint; zoffset: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFramebufferRenderbufferEXT: procedure (target: GLenum; attachment: GLenum; renderbuffertarget: GLenum; renderbuffer: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetFramebufferAttachmentParameterivEXT: procedure (target: GLenum; attachment: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenerateMipmapEXT: procedure (target: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramParameteriEXT: procedure (program_: GLuint; pname: GLenum; value: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramEnvParameters4fvEXT: procedure (target: GLenum; index: GLuint; count: GLsizei; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramLocalParameters4fvEXT: procedure (target: GLenum; index: GLuint; count: GLsizei; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetUniformuivEXT: procedure (program_: GLuint; location: GLint; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindFragDataLocationEXT: procedure (program_: GLuint; color: GLuint; name: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetFragDataLocationEXT: function (program_: GLuint; name: PGLchar): GLint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform1uiEXT: procedure (location: GLint; v0: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform2uiEXT: procedure (location: GLint; v0: GLuint; v1: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform3uiEXT: procedure (location: GLint; v0: GLuint; v1: GLuint; v2: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform4uiEXT: procedure (location: GLint; v0: GLuint; v1: GLuint; v2: GLuint; v3: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform1uivEXT: procedure (location: GLint; count: GLsizei; value: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform2uivEXT: procedure (location: GLint; count: GLsizei; value: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform3uivEXT: procedure (location: GLint; count: GLsizei; value: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform4uivEXT: procedure (location: GLint; count: GLsizei; value: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribI1iEXT: procedure (index: GLuint; x: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribI2iEXT: procedure (index: GLuint; x: GLint; y: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribI3iEXT: procedure (index: GLuint; x: GLint; y: GLint; z: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribI4iEXT: procedure (index: GLuint; x: GLint; y: GLint; z: GLint; w: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribI1uiEXT: procedure (index: GLuint; x: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribI2uiEXT: procedure (index: GLuint; x: GLuint; y: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribI3uiEXT: procedure (index: GLuint; x: GLuint; y: GLuint; z: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribI4uiEXT: procedure (index: GLuint; x: GLuint; y: GLuint; z: GLuint; w: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribI1ivEXT: procedure (index: GLuint; v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribI2ivEXT: procedure (index: GLuint; v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribI3ivEXT: procedure (index: GLuint; v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribI4ivEXT: procedure (index: GLuint; v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribI1uivEXT: procedure (index: GLuint; v: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribI2uivEXT: procedure (index: GLuint; v: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribI3uivEXT: procedure (index: GLuint; v: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribI4uivEXT: procedure (index: GLuint; v: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribI4bvEXT: procedure (index: GLuint; v: PGLbyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribI4svEXT: procedure (index: GLuint; v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribI4ubvEXT: procedure (index: GLuint; v: PGLubyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribI4usvEXT: procedure (index: GLuint; v: PGLushort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribIPointerEXT: procedure (index: GLuint; size: GLint; type_: GLenum; stride: GLsizei; pointer: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVertexAttribIivEXT: procedure (index: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVertexAttribIuivEXT: procedure (index: GLuint; pname: GLenum; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetHistogramEXT: procedure (target: GLenum; reset: GLboolean; format: GLenum; type_: GLenum; values: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetHistogramParameterfvEXT: procedure (target: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetHistogramParameterivEXT: procedure (target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetMinmaxEXT: procedure (target: GLenum; reset: GLboolean; format: GLenum; type_: GLenum; values: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetMinmaxParameterfvEXT: procedure (target: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetMinmaxParameterivEXT: procedure (target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glHistogramEXT: procedure (target: GLenum; width: GLsizei; internalformat: GLenum; sink: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMinmaxEXT: procedure (target: GLenum; internalformat: GLenum; sink: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glResetHistogramEXT: procedure (target: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glResetMinmaxEXT: procedure (target: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIndexFuncEXT: procedure (func: GLenum; ref: GLclampf); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIndexMaterialEXT: procedure (face: GLenum; mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glApplyTextureEXT: procedure (mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureLightEXT: procedure (pname: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureMaterialEXT: procedure (face: GLenum; mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetUnsignedBytevEXT: procedure (pname: GLenum; data: PGLubyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetUnsignedBytei_vEXT: procedure (target: GLenum; index: GLuint; data: PGLubyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteMemoryObjectsEXT: procedure (n: GLsizei; memoryObjects: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsMemoryObjectEXT: function (memoryObject: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCreateMemoryObjectsEXT: procedure (n: GLsizei; memoryObjects: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMemoryObjectParameterivEXT: procedure (memoryObject: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetMemoryObjectParameterivEXT: procedure (memoryObject: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexStorageMem2DEXT: procedure (target: GLenum; levels: GLsizei; internalFormat: GLenum; width: GLsizei; height: GLsizei; memory: GLuint; offset: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexStorageMem2DMultisampleEXT: procedure (target: GLenum; samples: GLsizei; internalFormat: GLenum; width: GLsizei; height: GLsizei; fixedSampleLocations: GLboolean; memory: GLuint; offset: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexStorageMem3DEXT: procedure (target: GLenum; levels: GLsizei; internalFormat: GLenum; width: GLsizei; height: GLsizei; depth: GLsizei; memory: GLuint; offset: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexStorageMem3DMultisampleEXT: procedure (target: GLenum; samples: GLsizei; internalFormat: GLenum; width: GLsizei; height: GLsizei; depth: GLsizei; fixedSampleLocations: GLboolean; memory: GLuint; offset: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBufferStorageMemEXT: procedure (target: GLenum; size: GLsizeiptr; memory: GLuint; offset: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureStorageMem2DEXT: procedure (texture: GLuint; levels: GLsizei; internalFormat: GLenum; width: GLsizei; height: GLsizei; memory: GLuint; offset: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureStorageMem2DMultisampleEXT: procedure (texture: GLuint; samples: GLsizei; internalFormat: GLenum; width: GLsizei; height: GLsizei; fixedSampleLocations: GLboolean; memory: GLuint; offset: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureStorageMem3DEXT: procedure (texture: GLuint; levels: GLsizei; internalFormat: GLenum; width: GLsizei; height: GLsizei; depth: GLsizei; memory: GLuint; offset: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureStorageMem3DMultisampleEXT: procedure (texture: GLuint; samples: GLsizei; internalFormat: GLenum; width: GLsizei; height: GLsizei; depth: GLsizei; fixedSampleLocations: GLboolean; memory: GLuint; offset: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedBufferStorageMemEXT: procedure (buffer: GLuint; size: GLsizeiptr; memory: GLuint; offset: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexStorageMem1DEXT: procedure (target: GLenum; levels: GLsizei; internalFormat: GLenum; width: GLsizei; memory: GLuint; offset: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureStorageMem1DEXT: procedure (texture: GLuint; levels: GLsizei; internalFormat: GLenum; width: GLsizei; memory: GLuint; offset: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glImportMemoryFdEXT: procedure (memory: GLuint; size: GLuint64; handleType: GLenum; fd: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glImportMemoryWin32HandleEXT: procedure (memory: GLuint; size: GLuint64; handleType: GLenum; handle: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glImportMemoryWin32NameEXT: procedure (memory: GLuint; size: GLuint64; handleType: GLenum; name: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiDrawArraysEXT: procedure (mode: GLenum; first: PGLint; count: PGLsizei; primcount: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiDrawElementsEXT: procedure (mode: GLenum; count: PGLsizei; type_: GLenum; indices: PPointer; primcount: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSampleMaskEXT: procedure (value: GLclampf; invert: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSamplePatternEXT: procedure (pattern: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColorTableEXT: procedure (target: GLenum; internalFormat: GLenum; width: GLsizei; format: GLenum; type_: GLenum; table: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetColorTableEXT: procedure (target: GLenum; format: GLenum; type_: GLenum; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetColorTableParameterivEXT: procedure (target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetColorTableParameterfvEXT: procedure (target: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPixelTransformParameteriEXT: procedure (target: GLenum; pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPixelTransformParameterfEXT: procedure (target: GLenum; pname: GLenum; param: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPixelTransformParameterivEXT: procedure (target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPixelTransformParameterfvEXT: procedure (target: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPixelTransformParameterivEXT: procedure (target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPixelTransformParameterfvEXT: procedure (target: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPointParameterfEXT: procedure (pname: GLenum; param: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPointParameterfvEXT: procedure (pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPolygonOffsetEXT: procedure (factor: GLfloat; bias: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPolygonOffsetClampEXT: procedure (factor: GLfloat; units: GLfloat; clamp: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProvokingVertexEXT: procedure (mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRasterSamplesEXT: procedure (samples: GLuint; fixedsamplelocations: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSecondaryColor3bEXT: procedure (red: GLbyte; green: GLbyte; blue: GLbyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSecondaryColor3bvEXT: procedure (v: PGLbyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSecondaryColor3dEXT: procedure (red: GLdouble; green: GLdouble; blue: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSecondaryColor3dvEXT: procedure (v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSecondaryColor3fEXT: procedure (red: GLfloat; green: GLfloat; blue: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSecondaryColor3fvEXT: procedure (v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSecondaryColor3iEXT: procedure (red: GLint; green: GLint; blue: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSecondaryColor3ivEXT: procedure (v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSecondaryColor3sEXT: procedure (red: GLshort; green: GLshort; blue: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSecondaryColor3svEXT: procedure (v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSecondaryColor3ubEXT: procedure (red: GLubyte; green: GLubyte; blue: GLubyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSecondaryColor3ubvEXT: procedure (v: PGLubyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSecondaryColor3uiEXT: procedure (red: GLuint; green: GLuint; blue: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSecondaryColor3uivEXT: procedure (v: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSecondaryColor3usEXT: procedure (red: GLushort; green: GLushort; blue: GLushort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSecondaryColor3usvEXT: procedure (v: PGLushort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSecondaryColorPointerEXT: procedure (size: GLint; type_: GLenum; stride: GLsizei; pointer: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenSemaphoresEXT: procedure (n: GLsizei; semaphores: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteSemaphoresEXT: procedure (n: GLsizei; semaphores: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsSemaphoreEXT: function (semaphore: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSemaphoreParameterui64vEXT: procedure (semaphore: GLuint; pname: GLenum; params: PGLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetSemaphoreParameterui64vEXT: procedure (semaphore: GLuint; pname: GLenum; params: PGLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWaitSemaphoreEXT: procedure (semaphore: GLuint; numBufferBarriers: GLuint; buffers: PGLuint; numTextureBarriers: GLuint; textures: PGLuint; srcLayouts: PGLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSignalSemaphoreEXT: procedure (semaphore: GLuint; numBufferBarriers: GLuint; buffers: PGLuint; numTextureBarriers: GLuint; textures: PGLuint; dstLayouts: PGLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glImportSemaphoreFdEXT: procedure (semaphore: GLuint; handleType: GLenum; fd: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glImportSemaphoreWin32HandleEXT: procedure (semaphore: GLuint; handleType: GLenum; handle: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glImportSemaphoreWin32NameEXT: procedure (semaphore: GLuint; handleType: GLenum; name: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUseShaderProgramEXT: procedure (type_: GLenum; program_: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glActiveProgramEXT: procedure (program_: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCreateShaderProgramEXT: function (type_: GLenum; string_: PGLchar): GLuint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glActiveShaderProgramEXT: procedure (pipeline: GLuint; program_: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindProgramPipelineEXT: procedure (pipeline: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCreateShaderProgramvEXT: function (type_: GLenum; count: GLsizei; strings: PPGLchar): GLuint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteProgramPipelinesEXT: procedure (n: GLsizei; pipelines: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenProgramPipelinesEXT: procedure (n: GLsizei; pipelines: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetProgramPipelineInfoLogEXT: procedure (pipeline: GLuint; bufSize: GLsizei; length: PGLsizei; infoLog: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetProgramPipelineivEXT: procedure (pipeline: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsProgramPipelineEXT: function (pipeline: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUseProgramStagesEXT: procedure (pipeline: GLuint; stages: GLbitfield; program_: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glValidateProgramPipelineEXT: procedure (pipeline: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFramebufferFetchBarrierEXT: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindImageTextureEXT: procedure (index: GLuint; texture: GLuint; level: GLint; layered: GLboolean; layer: GLint; access: GLenum; format: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMemoryBarrierEXT: procedure (barriers: GLbitfield); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glStencilClearTagEXT: procedure (stencilTagBits: GLsizei; stencilClearTag: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glActiveStencilFaceEXT: procedure (face: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexSubImage1DEXT: procedure (target: GLenum; level: GLint; xoffset: GLint; width: GLsizei; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexSubImage2DEXT: procedure (target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; width: GLsizei; height: GLsizei; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexImage3DEXT: procedure (target: GLenum; level: GLint; internalformat: GLenum; width: GLsizei; height: GLsizei; depth: GLsizei; border: GLint; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexSubImage3DEXT: procedure (target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; width: GLsizei; height: GLsizei; depth: GLsizei; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFramebufferTextureLayerEXT: procedure (target: GLenum; attachment: GLenum; texture: GLuint; level: GLint; layer: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexBufferEXT: procedure (target: GLenum; internalformat: GLenum; buffer: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexParameterIivEXT: procedure (target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexParameterIuivEXT: procedure (target: GLenum; pname: GLenum; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTexParameterIivEXT: procedure (target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTexParameterIuivEXT: procedure (target: GLenum; pname: GLenum; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClearColorIiEXT: procedure (red: GLint; green: GLint; blue: GLint; alpha: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClearColorIuiEXT: procedure (red: GLuint; green: GLuint; blue: GLuint; alpha: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glAreTexturesResidentEXT: function (n: GLsizei; textures: PGLuint; residences: PGLboolean): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindTextureEXT: procedure (target: GLenum; texture: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteTexturesEXT: procedure (n: GLsizei; textures: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenTexturesEXT: procedure (n: GLsizei; textures: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsTextureEXT: function (texture: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPrioritizeTexturesEXT: procedure (n: GLsizei; textures: PGLuint; priorities: PGLclampf); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureNormalEXT: procedure (mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexStorage1DEXT: procedure (target: GLenum; levels: GLsizei; internalformat: GLenum; width: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexStorage2DEXT: procedure (target: GLenum; levels: GLsizei; internalformat: GLenum; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexStorage3DEXT: procedure (target: GLenum; levels: GLsizei; internalformat: GLenum; width: GLsizei; height: GLsizei; depth: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetQueryObjecti64vEXT: procedure (id: GLuint; pname: GLenum; params: PGLint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetQueryObjectui64vEXT: procedure (id: GLuint; pname: GLenum; params: PGLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBeginTransformFeedbackEXT: procedure (primitiveMode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEndTransformFeedbackEXT: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindBufferRangeEXT: procedure (target: GLenum; index: GLuint; buffer: GLuint; offset: GLintptr; size: GLsizeiptr); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindBufferOffsetEXT: procedure (target: GLenum; index: GLuint; buffer: GLuint; offset: GLintptr); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindBufferBaseEXT: procedure (target: GLenum; index: GLuint; buffer: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTransformFeedbackVaryingsEXT: procedure (program_: GLuint; count: GLsizei; varyings: PPGLchar; bufferMode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTransformFeedbackVaryingEXT: procedure (program_: GLuint; index: GLuint; bufSize: GLsizei; length: PGLsizei; size: PGLsizei; type_: PGLenum; name: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glArrayElementEXT: procedure (i: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColorPointerEXT: procedure (size: GLint; type_: GLenum; stride: GLsizei; count: GLsizei; pointer: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawArraysEXT: procedure (mode: GLenum; first: GLint; count: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEdgeFlagPointerEXT: procedure (stride: GLsizei; count: GLsizei; pointer: PGLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPointervEXT: procedure (pname: GLenum; params: PPointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIndexPointerEXT: procedure (type_: GLenum; stride: GLsizei; count: GLsizei; pointer: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNormalPointerEXT: procedure (type_: GLenum; stride: GLsizei; count: GLsizei; pointer: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoordPointerEXT: procedure (size: GLint; type_: GLenum; stride: GLsizei; count: GLsizei; pointer: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexPointerEXT: procedure (size: GLint; type_: GLenum; stride: GLsizei; count: GLsizei; pointer: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribL1dEXT: procedure (index: GLuint; x: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribL2dEXT: procedure (index: GLuint; x: GLdouble; y: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribL3dEXT: procedure (index: GLuint; x: GLdouble; y: GLdouble; z: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribL4dEXT: procedure (index: GLuint; x: GLdouble; y: GLdouble; z: GLdouble; w: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribL1dvEXT: procedure (index: GLuint; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribL2dvEXT: procedure (index: GLuint; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribL3dvEXT: procedure (index: GLuint; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribL4dvEXT: procedure (index: GLuint; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribLPointerEXT: procedure (index: GLuint; size: GLint; type_: GLenum; stride: GLsizei; pointer: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVertexAttribLdvEXT: procedure (index: GLuint; pname: GLenum; params: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBeginVertexShaderEXT: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEndVertexShaderEXT: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindVertexShaderEXT: procedure (id: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenVertexShadersEXT: function (range: GLuint): GLuint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteVertexShaderEXT: procedure (id: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glShaderOp1EXT: procedure (op: GLenum; res: GLuint; arg1: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glShaderOp2EXT: procedure (op: GLenum; res: GLuint; arg1: GLuint; arg2: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glShaderOp3EXT: procedure (op: GLenum; res: GLuint; arg1: GLuint; arg2: GLuint; arg3: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSwizzleEXT: procedure (res: GLuint; in_: GLuint; outX: GLenum; outY: GLenum; outZ: GLenum; outW: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWriteMaskEXT: procedure (res: GLuint; in_: GLuint; outX: GLenum; outY: GLenum; outZ: GLenum; outW: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glInsertComponentEXT: procedure (res: GLuint; src: GLuint; num: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glExtractComponentEXT: procedure (res: GLuint; src: GLuint; num: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenSymbolsEXT: function (datatype: GLenum; storagetype: GLenum; range: GLenum; components: GLuint): GLuint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSetInvariantEXT: procedure (id: GLuint; type_: GLenum; addr: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSetLocalConstantEXT: procedure (id: GLuint; type_: GLenum; addr: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVariantbvEXT: procedure (id: GLuint; addr: PGLbyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVariantsvEXT: procedure (id: GLuint; addr: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVariantivEXT: procedure (id: GLuint; addr: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVariantfvEXT: procedure (id: GLuint; addr: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVariantdvEXT: procedure (id: GLuint; addr: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVariantubvEXT: procedure (id: GLuint; addr: PGLubyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVariantusvEXT: procedure (id: GLuint; addr: PGLushort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVariantuivEXT: procedure (id: GLuint; addr: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVariantPointerEXT: procedure (id: GLuint; type_: GLenum; stride: GLuint; addr: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEnableVariantClientStateEXT: procedure (id: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDisableVariantClientStateEXT: procedure (id: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindLightParameterEXT: function (light: GLenum; value: GLenum): GLuint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindMaterialParameterEXT: function (face: GLenum; value: GLenum): GLuint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindTexGenParameterEXT: function (unit_: GLenum; coord: GLenum; value: GLenum): GLuint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindTextureUnitParameterEXT: function (unit_: GLenum; value: GLenum): GLuint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindParameterEXT: function (value: GLenum): GLuint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsVariantEnabledEXT: function (id: GLuint; cap: GLenum): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVariantBooleanvEXT: procedure (id: GLuint; value: GLenum; data: PGLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVariantIntegervEXT: procedure (id: GLuint; value: GLenum; data: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVariantFloatvEXT: procedure (id: GLuint; value: GLenum; data: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVariantPointervEXT: procedure (id: GLuint; value: GLenum; data: PPointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetInvariantBooleanvEXT: procedure (id: GLuint; value: GLenum; data: PGLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetInvariantIntegervEXT: procedure (id: GLuint; value: GLenum; data: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetInvariantFloatvEXT: procedure (id: GLuint; value: GLenum; data: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetLocalConstantBooleanvEXT: procedure (id: GLuint; value: GLenum; data: PGLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetLocalConstantIntegervEXT: procedure (id: GLuint; value: GLenum; data: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetLocalConstantFloatvEXT: procedure (id: GLuint; value: GLenum; data: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexWeightfEXT: procedure (weight: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexWeightfvEXT: procedure (weight: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexWeightPointerEXT: procedure (size: GLint; type_: GLenum; stride: GLsizei; pointer: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glAcquireKeyedMutexWin32EXT: function (memory: GLuint; key: GLuint64; timeout: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glReleaseKeyedMutexWin32EXT: function (memory: GLuint; key: GLuint64): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowRectanglesEXT: procedure (mode: GLenum; count: GLsizei; box: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glImportSyncEXT: function (external_sync_type: GLenum; external_sync: GLintptr; flags: GLbitfield): GLsync; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFrameTerminatorGREMEDY: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glStringMarkerGREMEDY: procedure (len: GLsizei; string_: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glImageTransformParameteriHP: procedure (target: GLenum; pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glImageTransformParameterfHP: procedure (target: GLenum; pname: GLenum; param: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glImageTransformParameterivHP: procedure (target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glImageTransformParameterfvHP: procedure (target: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetImageTransformParameterivHP: procedure (target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetImageTransformParameterfvHP: procedure (target: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiModeDrawArraysIBM: procedure (mode: PGLenum; first: PGLint; count: PGLsizei; primcount: GLsizei; modestride: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiModeDrawElementsIBM: procedure (mode: PGLenum; count: PGLsizei; type_: GLenum; indices: PPointer; primcount: GLsizei; modestride: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFlushStaticDataIBM: procedure (target: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColorPointerListIBM: procedure (size: GLint; type_: GLenum; stride: GLint; pointer: PPointer; ptrstride: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSecondaryColorPointerListIBM: procedure (size: GLint; type_: GLenum; stride: GLint; pointer: PPointer; ptrstride: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEdgeFlagPointerListIBM: procedure (stride: GLint; pointer: PPGLboolean; ptrstride: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFogCoordPointerListIBM: procedure (type_: GLenum; stride: GLint; pointer: PPointer; ptrstride: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIndexPointerListIBM: procedure (type_: GLenum; stride: GLint; pointer: PPointer; ptrstride: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNormalPointerListIBM: procedure (type_: GLenum; stride: GLint; pointer: PPointer; ptrstride: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoordPointerListIBM: procedure (size: GLint; type_: GLenum; stride: GLint; pointer: PPointer; ptrstride: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexPointerListIBM: procedure (size: GLint; type_: GLenum; stride: GLint; pointer: PPointer; ptrstride: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlendFuncSeparateINGR: procedure (sfactorRGB: GLenum; dfactorRGB: GLenum; sfactorAlpha: GLenum; dfactorAlpha: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glApplyFramebufferAttachmentCMAAINTEL: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSyncTextureINTEL: procedure (texture: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUnmapTexture2DINTEL: procedure (texture: GLuint; level: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMapTexture2DINTEL: function (texture: GLuint; level: GLint; access: GLbitfield; stride: PGLint; layout: PGLenum): Pointer; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexPointervINTEL: procedure (size: GLint; type_: GLenum; pointer: PPointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNormalPointervINTEL: procedure (type_: GLenum; pointer: PPointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColorPointervINTEL: procedure (size: GLint; type_: GLenum; pointer: PPointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoordPointervINTEL: procedure (size: GLint; type_: GLenum; pointer: PPointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBeginPerfQueryINTEL: procedure (queryHandle: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCreatePerfQueryINTEL: procedure (queryId: GLuint; queryHandle: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeletePerfQueryINTEL: procedure (queryHandle: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEndPerfQueryINTEL: procedure (queryHandle: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetFirstPerfQueryIdINTEL: procedure (queryId: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetNextPerfQueryIdINTEL: procedure (queryId: GLuint; nextQueryId: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPerfCounterInfoINTEL: procedure (queryId: GLuint; counterId: GLuint; counterNameLength: GLuint; counterName: PGLchar; counterDescLength: GLuint; counterDesc: PGLchar; counterOffset: PGLuint; counterDataSize: PGLuint; counterTypeEnum: PGLuint; counterDataTypeEnum: PGLuint; rawCounterMaxValue: PGLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPerfQueryDataINTEL: procedure (queryHandle: GLuint; flags: GLuint; dataSize: GLsizei; data: Pointer; bytesWritten: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPerfQueryIdByNameINTEL: procedure (queryName: PGLchar; queryId: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPerfQueryInfoINTEL: procedure (queryId: GLuint; queryNameLength: GLuint; queryName: PGLchar; dataSize: PGLuint; noCounters: PGLuint; noInstances: PGLuint; capsMask: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlendBarrierKHR: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDebugMessageControl: procedure (source: GLenum; type_: GLenum; severity: GLenum; count: GLsizei; ids: PGLuint; enabled: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDebugMessageInsert: procedure (source: GLenum; type_: GLenum; id: GLuint; severity: GLenum; length: GLsizei; buf: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDebugMessageCallback: procedure (callback: GLDEBUGPROC; userParam: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetDebugMessageLog: function (count: GLuint; bufSize: GLsizei; sources: PGLenum; types: PGLenum; ids: PGLuint; severities: PGLenum; lengths: PGLsizei; messageLog: PGLchar): GLuint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPushDebugGroup: procedure (source: GLenum; id: GLuint; length: GLsizei; message: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPopDebugGroup: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glObjectLabel: procedure (identifier: GLenum; name: GLuint; length: GLsizei; label_: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetObjectLabel: procedure (identifier: GLenum; name: GLuint; bufSize: GLsizei; length: PGLsizei; label_: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glObjectPtrLabel: procedure (ptr: Pointer; length: GLsizei; label_: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetObjectPtrLabel: procedure (ptr: Pointer; bufSize: GLsizei; length: PGLsizei; label_: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPointerv: procedure (pname: GLenum; params: PPointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDebugMessageControlKHR: procedure (source: GLenum; type_: GLenum; severity: GLenum; count: GLsizei; ids: PGLuint; enabled: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDebugMessageInsertKHR: procedure (source: GLenum; type_: GLenum; id: GLuint; severity: GLenum; length: GLsizei; buf: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDebugMessageCallbackKHR: procedure (callback: GLDEBUGPROCKHR; userParam: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetDebugMessageLogKHR: function (count: GLuint; bufSize: GLsizei; sources: PGLenum; types: PGLenum; ids: PGLuint; severities: PGLenum; lengths: PGLsizei; messageLog: PGLchar): GLuint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPushDebugGroupKHR: procedure (source: GLenum; id: GLuint; length: GLsizei; message: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPopDebugGroupKHR: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glObjectLabelKHR: procedure (identifier: GLenum; name: GLuint; length: GLsizei; label_: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetObjectLabelKHR: procedure (identifier: GLenum; name: GLuint; bufSize: GLsizei; length: PGLsizei; label_: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glObjectPtrLabelKHR: procedure (ptr: Pointer; length: GLsizei; label_: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetObjectPtrLabelKHR: procedure (ptr: Pointer; bufSize: GLsizei; length: PGLsizei; label_: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPointervKHR: procedure (pname: GLenum; params: PPointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMaxShaderCompilerThreadsKHR: procedure (count: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetGraphicsResetStatus: function (): GLenum; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glReadnPixels: procedure (x: GLint; y: GLint; width: GLsizei; height: GLsizei; format: GLenum; type_: GLenum; bufSize: GLsizei; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetnUniformfv: procedure (program_: GLuint; location: GLint; bufSize: GLsizei; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetnUniformiv: procedure (program_: GLuint; location: GLint; bufSize: GLsizei; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetnUniformuiv: procedure (program_: GLuint; location: GLint; bufSize: GLsizei; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetGraphicsResetStatusKHR: function (): GLenum; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glReadnPixelsKHR: procedure (x: GLint; y: GLint; width: GLsizei; height: GLsizei; format: GLenum; type_: GLenum; bufSize: GLsizei; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetnUniformfvKHR: procedure (program_: GLuint; location: GLint; bufSize: GLsizei; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetnUniformivKHR: procedure (program_: GLuint; location: GLint; bufSize: GLsizei; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetnUniformuivKHR: procedure (program_: GLuint; location: GLint; bufSize: GLsizei; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFramebufferParameteriMESA: procedure (target: GLenum; pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetFramebufferParameterivMESA: procedure (target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glResizeBuffersMESA: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos2dMESA: procedure (x: GLdouble; y: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos2dvMESA: procedure (v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos2fMESA: procedure (x: GLfloat; y: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos2fvMESA: procedure (v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos2iMESA: procedure (x: GLint; y: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos2ivMESA: procedure (v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos2sMESA: procedure (x: GLshort; y: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos2svMESA: procedure (v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos3dMESA: procedure (x: GLdouble; y: GLdouble; z: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos3dvMESA: procedure (v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos3fMESA: procedure (x: GLfloat; y: GLfloat; z: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos3fvMESA: procedure (v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos3iMESA: procedure (x: GLint; y: GLint; z: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos3ivMESA: procedure (v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos3sMESA: procedure (x: GLshort; y: GLshort; z: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos3svMESA: procedure (v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos4dMESA: procedure (x: GLdouble; y: GLdouble; z: GLdouble; w: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos4dvMESA: procedure (v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos4fMESA: procedure (x: GLfloat; y: GLfloat; z: GLfloat; w: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos4fvMESA: procedure (v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos4iMESA: procedure (x: GLint; y: GLint; z: GLint; w: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos4ivMESA: procedure (v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos4sMESA: procedure (x: GLshort; y: GLshort; z: GLshort; w: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos4svMESA: procedure (v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBeginConditionalRenderNVX: procedure (id: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEndConditionalRenderNVX: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUploadGpuMaskNVX: procedure (mask: GLbitfield); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMulticastViewportArrayvNVX: procedure (gpu: GLuint; first: GLuint; count: GLsizei; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMulticastViewportPositionWScaleNVX: procedure (gpu: GLuint; index: GLuint; xcoeff: GLfloat; ycoeff: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMulticastScissorArrayvNVX: procedure (gpu: GLuint; first: GLuint; count: GLsizei; v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glAsyncCopyBufferSubDataNVX: function (waitSemaphoreCount: GLsizei; waitSemaphoreArray: PGLuint; fenceValueArray: PGLuint64; readGpu: GLuint; writeGpuMask: GLbitfield; readBuffer: GLuint; writeBuffer: GLuint; readOffset: GLintptr; writeOffset: GLintptr; size: GLsizeiptr; signalSemaphoreCount: GLsizei; signalSemaphoreArray: PGLuint; signalValueArray: PGLuint64): GLuint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glAsyncCopyImageSubDataNVX: function (waitSemaphoreCount: GLsizei; waitSemaphoreArray: PGLuint; waitValueArray: PGLuint64; srcGpu: GLuint; dstGpuMask: GLbitfield; srcName: GLuint; srcTarget: GLenum; srcLevel: GLint; srcX: GLint; srcY: GLint; srcZ: GLint; dstName: GLuint; dstTarget: GLenum; dstLevel: GLint; dstX: GLint; dstY: GLint; dstZ: GLint; srcWidth: GLsizei; srcHeight: GLsizei; srcDepth: GLsizei; signalSemaphoreCount: GLsizei; signalSemaphoreArray: PGLuint; signalValueArray: PGLuint64): GLuint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glLGPUNamedBufferSubDataNVX: procedure (gpuMask: GLbitfield; buffer: GLuint; offset: GLintptr; size: GLsizeiptr; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glLGPUCopyImageSubDataNVX: procedure (sourceGpu: GLuint; destinationGpuMask: GLbitfield; srcName: GLuint; srcTarget: GLenum; srcLevel: GLint; srcX: GLint; srxY: GLint; srcZ: GLint; dstName: GLuint; dstTarget: GLenum; dstLevel: GLint; dstX: GLint; dstY: GLint; dstZ: GLint; width: GLsizei; height: GLsizei; depth: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glLGPUInterlockNVX: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCreateProgressFenceNVX: function (): GLuint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSignalSemaphoreui64NVX: procedure (signalGpu: GLuint; fenceObjectCount: GLsizei; semaphoreArray: PGLuint; fenceValueArray: PGLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWaitSemaphoreui64NVX: procedure (waitGpu: GLuint; fenceObjectCount: GLsizei; semaphoreArray: PGLuint; fenceValueArray: PGLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClientWaitSemaphoreui64NVX: procedure (fenceObjectCount: GLsizei; semaphoreArray: PGLuint; fenceValueArray: PGLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glAlphaToCoverageDitherControlNV: procedure (mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiDrawArraysIndirectBindlessNV: procedure (mode: GLenum; indirect: Pointer; drawCount: GLsizei; stride: GLsizei; vertexBufferCount: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiDrawElementsIndirectBindlessNV: procedure (mode: GLenum; type_: GLenum; indirect: Pointer; drawCount: GLsizei; stride: GLsizei; vertexBufferCount: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiDrawArraysIndirectBindlessCountNV: procedure (mode: GLenum; indirect: Pointer; drawCount: GLsizei; maxDrawCount: GLsizei; stride: GLsizei; vertexBufferCount: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiDrawElementsIndirectBindlessCountNV: procedure (mode: GLenum; type_: GLenum; indirect: Pointer; drawCount: GLsizei; maxDrawCount: GLsizei; stride: GLsizei; vertexBufferCount: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTextureHandleNV: function (texture: GLuint): GLuint64; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTextureSamplerHandleNV: function (texture: GLuint; sampler: GLuint): GLuint64; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMakeTextureHandleResidentNV: procedure (handle: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMakeTextureHandleNonResidentNV: procedure (handle: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetImageHandleNV: function (texture: GLuint; level: GLint; layered: GLboolean; layer: GLint; format: GLenum): GLuint64; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMakeImageHandleResidentNV: procedure (handle: GLuint64; access: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMakeImageHandleNonResidentNV: procedure (handle: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformHandleui64NV: procedure (location: GLint; value: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformHandleui64vNV: procedure (location: GLint; count: GLsizei; value: PGLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformHandleui64NV: procedure (program_: GLuint; location: GLint; value: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformHandleui64vNV: procedure (program_: GLuint; location: GLint; count: GLsizei; values: PGLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsTextureHandleResidentNV: function (handle: GLuint64): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsImageHandleResidentNV: function (handle: GLuint64): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlendParameteriNV: procedure (pname: GLenum; value: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlendBarrierNV: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glViewportPositionWScaleNV: procedure (index: GLuint; xcoeff: GLfloat; ycoeff: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCreateStatesNV: procedure (n: GLsizei; states: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteStatesNV: procedure (n: GLsizei; states: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsStateNV: function (state: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glStateCaptureNV: procedure (state: GLuint; mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetCommandHeaderNV: function (tokenID: GLenum; size: GLuint): GLuint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetStageIndexNV: function (shadertype: GLenum): GLushort; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawCommandsNV: procedure (primitiveMode: GLenum; buffer: GLuint; indirects: PGLintptr; sizes: PGLsizei; count: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawCommandsAddressNV: procedure (primitiveMode: GLenum; indirects: PGLuint64; sizes: PGLsizei; count: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawCommandsStatesNV: procedure (buffer: GLuint; indirects: PGLintptr; sizes: PGLsizei; states: PGLuint; fbos: PGLuint; count: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawCommandsStatesAddressNV: procedure (indirects: PGLuint64; sizes: PGLsizei; states: PGLuint; fbos: PGLuint; count: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCreateCommandListsNV: procedure (n: GLsizei; lists: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteCommandListsNV: procedure (n: GLsizei; lists: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsCommandListNV: function (list: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glListDrawCommandsStatesClientNV: procedure (list: GLuint; segment: GLuint; indirects: PPointer; sizes: PGLsizei; states: PGLuint; fbos: PGLuint; count: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCommandListSegmentsNV: procedure (list: GLuint; segments: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCompileCommandListNV: procedure (list: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCallCommandListNV: procedure (list: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBeginConditionalRenderNV: procedure (id: GLuint; mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEndConditionalRenderNV: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSubpixelPrecisionBiasNV: procedure (xbits: GLuint; ybits: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glConservativeRasterParameterfNV: procedure (pname: GLenum; value: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glConservativeRasterParameteriNV: procedure (pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyImageSubDataNV: procedure (srcName: GLuint; srcTarget: GLenum; srcLevel: GLint; srcX: GLint; srcY: GLint; srcZ: GLint; dstName: GLuint; dstTarget: GLenum; dstLevel: GLint; dstX: GLint; dstY: GLint; dstZ: GLint; width: GLsizei; height: GLsizei; depth: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDepthRangedNV: procedure (zNear: GLdouble; zFar: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClearDepthdNV: procedure (depth: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDepthBoundsdNV: procedure (zmin: GLdouble; zmax: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawTextureNV: procedure (texture: GLuint; sampler: GLuint; x0: GLfloat; y0: GLfloat; x1: GLfloat; y1: GLfloat; z: GLfloat; s0: GLfloat; t0: GLfloat; s1: GLfloat; t1: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawVkImageNV: procedure (vkImage: GLuint64; sampler: GLuint; x0: GLfloat; y0: GLfloat; x1: GLfloat; y1: GLfloat; z: GLfloat; s0: GLfloat; t0: GLfloat; s1: GLfloat; t1: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVkProcAddrNV: function (name: PGLchar): GLVULKANPROCNV; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWaitVkSemaphoreNV: procedure (vkSemaphore: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSignalVkSemaphoreNV: procedure (vkSemaphore: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSignalVkFenceNV: procedure (vkFence: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMapControlPointsNV: procedure (target: GLenum; index: GLuint; type_: GLenum; ustride: GLsizei; vstride: GLsizei; uorder: GLint; vorder: GLint; packed_: GLboolean; points: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMapParameterivNV: procedure (target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMapParameterfvNV: procedure (target: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetMapControlPointsNV: procedure (target: GLenum; index: GLuint; type_: GLenum; ustride: GLsizei; vstride: GLsizei; packed_: GLboolean; points: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetMapParameterivNV: procedure (target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetMapParameterfvNV: procedure (target: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetMapAttribParameterivNV: procedure (target: GLenum; index: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetMapAttribParameterfvNV: procedure (target: GLenum; index: GLuint; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEvalMapsNV: procedure (target: GLenum; mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetMultisamplefvNV: procedure (pname: GLenum; index: GLuint; val: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSampleMaskIndexedNV: procedure (index: GLuint; mask: GLbitfield); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexRenderbufferNV: procedure (target: GLenum; renderbuffer: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteFencesNV: procedure (n: GLsizei; fences: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenFencesNV: procedure (n: GLsizei; fences: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsFenceNV: function (fence: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTestFenceNV: function (fence: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetFenceivNV: procedure (fence: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFinishFenceNV: procedure (fence: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSetFenceNV: procedure (fence: GLuint; condition: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFragmentCoverageColorNV: procedure (color: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramNamedParameter4fNV: procedure (id: GLuint; len: GLsizei; name: PGLubyte; x: GLfloat; y: GLfloat; z: GLfloat; w: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramNamedParameter4fvNV: procedure (id: GLuint; len: GLsizei; name: PGLubyte; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramNamedParameter4dNV: procedure (id: GLuint; len: GLsizei; name: PGLubyte; x: GLdouble; y: GLdouble; z: GLdouble; w: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramNamedParameter4dvNV: procedure (id: GLuint; len: GLsizei; name: PGLubyte; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetProgramNamedParameterfvNV: procedure (id: GLuint; len: GLsizei; name: PGLubyte; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetProgramNamedParameterdvNV: procedure (id: GLuint; len: GLsizei; name: PGLubyte; params: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCoverageModulationTableNV: procedure (n: GLsizei; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetCoverageModulationTableNV: procedure (bufSize: GLsizei; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCoverageModulationNV: procedure (components: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRenderbufferStorageMultisampleCoverageNV: procedure (target: GLenum; coverageSamples: GLsizei; colorSamples: GLsizei; internalformat: GLenum; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramVertexLimitNV: procedure (target: GLenum; limit: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFramebufferTextureEXT: procedure (target: GLenum; attachment: GLenum; texture: GLuint; level: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFramebufferTextureFaceEXT: procedure (target: GLenum; attachment: GLenum; texture: GLuint; level: GLint; face: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRenderGpuMaskNV: procedure (mask: GLbitfield); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMulticastBufferSubDataNV: procedure (gpuMask: GLbitfield; buffer: GLuint; offset: GLintptr; size: GLsizeiptr; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMulticastCopyBufferSubDataNV: procedure (readGpu: GLuint; writeGpuMask: GLbitfield; readBuffer: GLuint; writeBuffer: GLuint; readOffset: GLintptr; writeOffset: GLintptr; size: GLsizeiptr); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMulticastCopyImageSubDataNV: procedure (srcGpu: GLuint; dstGpuMask: GLbitfield; srcName: GLuint; srcTarget: GLenum; srcLevel: GLint; srcX: GLint; srcY: GLint; srcZ: GLint; dstName: GLuint; dstTarget: GLenum; dstLevel: GLint; dstX: GLint; dstY: GLint; dstZ: GLint; srcWidth: GLsizei; srcHeight: GLsizei; srcDepth: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMulticastBlitFramebufferNV: procedure (srcGpu: GLuint; dstGpu: GLuint; srcX0: GLint; srcY0: GLint; srcX1: GLint; srcY1: GLint; dstX0: GLint; dstY0: GLint; dstX1: GLint; dstY1: GLint; mask: GLbitfield; filter: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMulticastFramebufferSampleLocationsfvNV: procedure (gpu: GLuint; framebuffer: GLuint; start: GLuint; count: GLsizei; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMulticastBarrierNV: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMulticastWaitSyncNV: procedure (signalGpu: GLuint; waitGpuMask: GLbitfield); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMulticastGetQueryObjectivNV: procedure (gpu: GLuint; id: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMulticastGetQueryObjectuivNV: procedure (gpu: GLuint; id: GLuint; pname: GLenum; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMulticastGetQueryObjecti64vNV: procedure (gpu: GLuint; id: GLuint; pname: GLenum; params: PGLint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMulticastGetQueryObjectui64vNV: procedure (gpu: GLuint; id: GLuint; pname: GLenum; params: PGLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramLocalParameterI4iNV: procedure (target: GLenum; index: GLuint; x: GLint; y: GLint; z: GLint; w: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramLocalParameterI4ivNV: procedure (target: GLenum; index: GLuint; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramLocalParametersI4ivNV: procedure (target: GLenum; index: GLuint; count: GLsizei; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramLocalParameterI4uiNV: procedure (target: GLenum; index: GLuint; x: GLuint; y: GLuint; z: GLuint; w: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramLocalParameterI4uivNV: procedure (target: GLenum; index: GLuint; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramLocalParametersI4uivNV: procedure (target: GLenum; index: GLuint; count: GLsizei; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramEnvParameterI4iNV: procedure (target: GLenum; index: GLuint; x: GLint; y: GLint; z: GLint; w: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramEnvParameterI4ivNV: procedure (target: GLenum; index: GLuint; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramEnvParametersI4ivNV: procedure (target: GLenum; index: GLuint; count: GLsizei; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramEnvParameterI4uiNV: procedure (target: GLenum; index: GLuint; x: GLuint; y: GLuint; z: GLuint; w: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramEnvParameterI4uivNV: procedure (target: GLenum; index: GLuint; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramEnvParametersI4uivNV: procedure (target: GLenum; index: GLuint; count: GLsizei; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetProgramLocalParameterIivNV: procedure (target: GLenum; index: GLuint; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetProgramLocalParameterIuivNV: procedure (target: GLenum; index: GLuint; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetProgramEnvParameterIivNV: procedure (target: GLenum; index: GLuint; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetProgramEnvParameterIuivNV: procedure (target: GLenum; index: GLuint; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramSubroutineParametersuivNV: procedure (target: GLenum; count: GLsizei; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetProgramSubroutineParameteruivNV: procedure (target: GLenum; index: GLuint; param: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertex2hNV: procedure (x: GLhalfNV; y: GLhalfNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertex2hvNV: procedure (v: PGLhalfNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertex3hNV: procedure (x: GLhalfNV; y: GLhalfNV; z: GLhalfNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertex3hvNV: procedure (v: PGLhalfNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertex4hNV: procedure (x: GLhalfNV; y: GLhalfNV; z: GLhalfNV; w: GLhalfNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertex4hvNV: procedure (v: PGLhalfNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNormal3hNV: procedure (nx: GLhalfNV; ny: GLhalfNV; nz: GLhalfNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNormal3hvNV: procedure (v: PGLhalfNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor3hNV: procedure (red: GLhalfNV; green: GLhalfNV; blue: GLhalfNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor3hvNV: procedure (v: PGLhalfNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor4hNV: procedure (red: GLhalfNV; green: GLhalfNV; blue: GLhalfNV; alpha: GLhalfNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor4hvNV: procedure (v: PGLhalfNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord1hNV: procedure (s: GLhalfNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord1hvNV: procedure (v: PGLhalfNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord2hNV: procedure (s: GLhalfNV; t: GLhalfNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord2hvNV: procedure (v: PGLhalfNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord3hNV: procedure (s: GLhalfNV; t: GLhalfNV; r: GLhalfNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord3hvNV: procedure (v: PGLhalfNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord4hNV: procedure (s: GLhalfNV; t: GLhalfNV; r: GLhalfNV; q: GLhalfNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord4hvNV: procedure (v: PGLhalfNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord1hNV: procedure (target: GLenum; s: GLhalfNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord1hvNV: procedure (target: GLenum; v: PGLhalfNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord2hNV: procedure (target: GLenum; s: GLhalfNV; t: GLhalfNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord2hvNV: procedure (target: GLenum; v: PGLhalfNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord3hNV: procedure (target: GLenum; s: GLhalfNV; t: GLhalfNV; r: GLhalfNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord3hvNV: procedure (target: GLenum; v: PGLhalfNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord4hNV: procedure (target: GLenum; s: GLhalfNV; t: GLhalfNV; r: GLhalfNV; q: GLhalfNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord4hvNV: procedure (target: GLenum; v: PGLhalfNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib1hNV: procedure (index: GLuint; x: GLhalfNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib1hvNV: procedure (index: GLuint; v: PGLhalfNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib2hNV: procedure (index: GLuint; x: GLhalfNV; y: GLhalfNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib2hvNV: procedure (index: GLuint; v: PGLhalfNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib3hNV: procedure (index: GLuint; x: GLhalfNV; y: GLhalfNV; z: GLhalfNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib3hvNV: procedure (index: GLuint; v: PGLhalfNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4hNV: procedure (index: GLuint; x: GLhalfNV; y: GLhalfNV; z: GLhalfNV; w: GLhalfNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4hvNV: procedure (index: GLuint; v: PGLhalfNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribs1hvNV: procedure (index: GLuint; n: GLsizei; v: PGLhalfNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribs2hvNV: procedure (index: GLuint; n: GLsizei; v: PGLhalfNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribs3hvNV: procedure (index: GLuint; n: GLsizei; v: PGLhalfNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribs4hvNV: procedure (index: GLuint; n: GLsizei; v: PGLhalfNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFogCoordhNV: procedure (fog: GLhalfNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFogCoordhvNV: procedure (fog: PGLhalfNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSecondaryColor3hNV: procedure (red: GLhalfNV; green: GLhalfNV; blue: GLhalfNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSecondaryColor3hvNV: procedure (v: PGLhalfNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexWeighthNV: procedure (weight: GLhalfNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexWeighthvNV: procedure (weight: PGLhalfNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetInternalformatSampleivNV: procedure (target: GLenum; internalformat: GLenum; samples: GLsizei; pname: GLenum; count: GLsizei; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetMemoryObjectDetachedResourcesuivNV: procedure (memory: GLuint; pname: GLenum; first: GLint; count: GLsizei; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glResetMemoryObjectParameterNV: procedure (memory: GLuint; pname: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexAttachMemoryNV: procedure (target: GLenum; memory: GLuint; offset: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBufferAttachMemoryNV: procedure (target: GLenum; memory: GLuint; offset: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureAttachMemoryNV: procedure (texture: GLuint; memory: GLuint; offset: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedBufferAttachMemoryNV: procedure (buffer: GLuint; memory: GLuint; offset: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBufferPageCommitmentMemNV: procedure (target: GLenum; offset: GLintptr; size: GLsizeiptr; memory: GLuint; memOffset: GLuint64; commit: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexPageCommitmentMemNV: procedure (target: GLenum; layer: GLint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; width: GLsizei; height: GLsizei; depth: GLsizei; memory: GLuint; offset: GLuint64; commit: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedBufferPageCommitmentMemNV: procedure (buffer: GLuint; offset: GLintptr; size: GLsizeiptr; memory: GLuint; memOffset: GLuint64; commit: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexturePageCommitmentMemNV: procedure (texture: GLuint; layer: GLint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; width: GLsizei; height: GLsizei; depth: GLsizei; memory: GLuint; offset: GLuint64; commit: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawMeshTasksNV: procedure (first: GLuint; count: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawMeshTasksIndirectNV: procedure (indirect: GLintptr); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiDrawMeshTasksIndirectNV: procedure (indirect: GLintptr; drawcount: GLsizei; stride: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiDrawMeshTasksIndirectCountNV: procedure (indirect: GLintptr; drawcount: GLintptr; maxdrawcount: GLsizei; stride: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenOcclusionQueriesNV: procedure (n: GLsizei; ids: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteOcclusionQueriesNV: procedure (n: GLsizei; ids: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsOcclusionQueryNV: function (id: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBeginOcclusionQueryNV: procedure (id: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEndOcclusionQueryNV: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetOcclusionQueryivNV: procedure (id: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetOcclusionQueryuivNV: procedure (id: GLuint; pname: GLenum; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramBufferParametersfvNV: procedure (target: GLenum; bindingIndex: GLuint; wordIndex: GLuint; count: GLsizei; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramBufferParametersIivNV: procedure (target: GLenum; bindingIndex: GLuint; wordIndex: GLuint; count: GLsizei; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramBufferParametersIuivNV: procedure (target: GLenum; bindingIndex: GLuint; wordIndex: GLuint; count: GLsizei; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenPathsNV: function (range: GLsizei): GLuint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeletePathsNV: procedure (path: GLuint; range: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsPathNV: function (path: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPathCommandsNV: procedure (path: GLuint; numCommands: GLsizei; commands: PGLubyte; numCoords: GLsizei; coordType: GLenum; coords: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPathCoordsNV: procedure (path: GLuint; numCoords: GLsizei; coordType: GLenum; coords: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPathSubCommandsNV: procedure (path: GLuint; commandStart: GLsizei; commandsToDelete: GLsizei; numCommands: GLsizei; commands: PGLubyte; numCoords: GLsizei; coordType: GLenum; coords: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPathSubCoordsNV: procedure (path: GLuint; coordStart: GLsizei; numCoords: GLsizei; coordType: GLenum; coords: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPathStringNV: procedure (path: GLuint; format: GLenum; length: GLsizei; pathString: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPathGlyphsNV: procedure (firstPathName: GLuint; fontTarget: GLenum; fontName: Pointer; fontStyle: GLbitfield; numGlyphs: GLsizei; type_: GLenum; charcodes: Pointer; handleMissingGlyphs: GLenum; pathParameterTemplate: GLuint; emScale: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPathGlyphRangeNV: procedure (firstPathName: GLuint; fontTarget: GLenum; fontName: Pointer; fontStyle: GLbitfield; firstGlyph: GLuint; numGlyphs: GLsizei; handleMissingGlyphs: GLenum; pathParameterTemplate: GLuint; emScale: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWeightPathsNV: procedure (resultPath: GLuint; numPaths: GLsizei; paths: PGLuint; weights: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyPathNV: procedure (resultPath: GLuint; srcPath: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glInterpolatePathsNV: procedure (resultPath: GLuint; pathA: GLuint; pathB: GLuint; weight: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTransformPathNV: procedure (resultPath: GLuint; srcPath: GLuint; transformType: GLenum; transformValues: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPathParameterivNV: procedure (path: GLuint; pname: GLenum; value: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPathParameteriNV: procedure (path: GLuint; pname: GLenum; value: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPathParameterfvNV: procedure (path: GLuint; pname: GLenum; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPathParameterfNV: procedure (path: GLuint; pname: GLenum; value: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPathDashArrayNV: procedure (path: GLuint; dashCount: GLsizei; dashArray: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPathStencilFuncNV: procedure (func: GLenum; ref: GLint; mask: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPathStencilDepthOffsetNV: procedure (factor: GLfloat; units: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glStencilFillPathNV: procedure (path: GLuint; fillMode: GLenum; mask: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glStencilStrokePathNV: procedure (path: GLuint; reference: GLint; mask: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glStencilFillPathInstancedNV: procedure (numPaths: GLsizei; pathNameType: GLenum; paths: Pointer; pathBase: GLuint; fillMode: GLenum; mask: GLuint; transformType: GLenum; transformValues: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glStencilStrokePathInstancedNV: procedure (numPaths: GLsizei; pathNameType: GLenum; paths: Pointer; pathBase: GLuint; reference: GLint; mask: GLuint; transformType: GLenum; transformValues: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPathCoverDepthFuncNV: procedure (func: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCoverFillPathNV: procedure (path: GLuint; coverMode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCoverStrokePathNV: procedure (path: GLuint; coverMode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCoverFillPathInstancedNV: procedure (numPaths: GLsizei; pathNameType: GLenum; paths: Pointer; pathBase: GLuint; coverMode: GLenum; transformType: GLenum; transformValues: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCoverStrokePathInstancedNV: procedure (numPaths: GLsizei; pathNameType: GLenum; paths: Pointer; pathBase: GLuint; coverMode: GLenum; transformType: GLenum; transformValues: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPathParameterivNV: procedure (path: GLuint; pname: GLenum; value: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPathParameterfvNV: procedure (path: GLuint; pname: GLenum; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPathCommandsNV: procedure (path: GLuint; commands: PGLubyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPathCoordsNV: procedure (path: GLuint; coords: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPathDashArrayNV: procedure (path: GLuint; dashArray: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPathMetricsNV: procedure (metricQueryMask: GLbitfield; numPaths: GLsizei; pathNameType: GLenum; paths: Pointer; pathBase: GLuint; stride: GLsizei; metrics: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPathMetricRangeNV: procedure (metricQueryMask: GLbitfield; firstPathName: GLuint; numPaths: GLsizei; stride: GLsizei; metrics: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPathSpacingNV: procedure (pathListMode: GLenum; numPaths: GLsizei; pathNameType: GLenum; paths: Pointer; pathBase: GLuint; advanceScale: GLfloat; kerningScale: GLfloat; transformType: GLenum; returnedSpacing: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsPointInFillPathNV: function (path: GLuint; mask: GLuint; x: GLfloat; y: GLfloat): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsPointInStrokePathNV: function (path: GLuint; x: GLfloat; y: GLfloat): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPathLengthNV: function (path: GLuint; startSegment: GLsizei; numSegments: GLsizei): GLfloat; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPointAlongPathNV: function (path: GLuint; startSegment: GLsizei; numSegments: GLsizei; distance: GLfloat; x: PGLfloat; y: PGLfloat; tangentX: PGLfloat; tangentY: PGLfloat): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixLoad3x2fNV: procedure (matrixMode: GLenum; m: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixLoad3x3fNV: procedure (matrixMode: GLenum; m: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixLoadTranspose3x3fNV: procedure (matrixMode: GLenum; m: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixMult3x2fNV: procedure (matrixMode: GLenum; m: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixMult3x3fNV: procedure (matrixMode: GLenum; m: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixMultTranspose3x3fNV: procedure (matrixMode: GLenum; m: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glStencilThenCoverFillPathNV: procedure (path: GLuint; fillMode: GLenum; mask: GLuint; coverMode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glStencilThenCoverStrokePathNV: procedure (path: GLuint; reference: GLint; mask: GLuint; coverMode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glStencilThenCoverFillPathInstancedNV: procedure (numPaths: GLsizei; pathNameType: GLenum; paths: Pointer; pathBase: GLuint; fillMode: GLenum; mask: GLuint; coverMode: GLenum; transformType: GLenum; transformValues: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glStencilThenCoverStrokePathInstancedNV: procedure (numPaths: GLsizei; pathNameType: GLenum; paths: Pointer; pathBase: GLuint; reference: GLint; mask: GLuint; coverMode: GLenum; transformType: GLenum; transformValues: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPathGlyphIndexRangeNV: function (fontTarget: GLenum; fontName: Pointer; fontStyle: GLbitfield; pathParameterTemplate: GLuint; emScale: GLfloat; baseAndCount: PGLuint): GLenum; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPathGlyphIndexArrayNV: function (firstPathName: GLuint; fontTarget: GLenum; fontName: Pointer; fontStyle: GLbitfield; firstGlyphIndex: GLuint; numGlyphs: GLsizei; pathParameterTemplate: GLuint; emScale: GLfloat): GLenum; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPathMemoryGlyphIndexArrayNV: function (firstPathName: GLuint; fontTarget: GLenum; fontSize: GLsizeiptr; fontData: Pointer; faceIndex: GLsizei; firstGlyphIndex: GLuint; numGlyphs: GLsizei; pathParameterTemplate: GLuint; emScale: GLfloat): GLenum; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramPathFragmentInputGenNV: procedure (program_: GLuint; location: GLint; genMode: GLenum; components: GLint; coeffs: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetProgramResourcefvNV: procedure (program_: GLuint; programInterface: GLenum; index: GLuint; propCount: GLsizei; props: PGLenum; count: GLsizei; length: PGLsizei; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPathColorGenNV: procedure (color: GLenum; genMode: GLenum; colorFormat: GLenum; coeffs: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPathTexGenNV: procedure (texCoordSet: GLenum; genMode: GLenum; components: GLint; coeffs: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPathFogGenNV: procedure (genMode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPathColorGenivNV: procedure (color: GLenum; pname: GLenum; value: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPathColorGenfvNV: procedure (color: GLenum; pname: GLenum; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPathTexGenivNV: procedure (texCoordSet: GLenum; pname: GLenum; value: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPathTexGenfvNV: procedure (texCoordSet: GLenum; pname: GLenum; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPixelDataRangeNV: procedure (target: GLenum; length: GLsizei; pointer: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFlushPixelDataRangeNV: procedure (target: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPointParameteriNV: procedure (pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPointParameterivNV: procedure (pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPresentFrameKeyedNV: procedure (video_slot: GLuint; minPresentTime: GLuint64EXT; beginPresentTimeId: GLuint; presentDurationId: GLuint; type_: GLenum; target0: GLenum; fill0: GLuint; key0: GLuint; target1: GLenum; fill1: GLuint; key1: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPresentFrameDualFillNV: procedure (video_slot: GLuint; minPresentTime: GLuint64EXT; beginPresentTimeId: GLuint; presentDurationId: GLuint; type_: GLenum; target0: GLenum; fill0: GLuint; target1: GLenum; fill1: GLuint; target2: GLenum; fill2: GLuint; target3: GLenum; fill3: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVideoivNV: procedure (video_slot: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVideouivNV: procedure (video_slot: GLuint; pname: GLenum; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVideoi64vNV: procedure (video_slot: GLuint; pname: GLenum; params: PGLint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVideoui64vNV: procedure (video_slot: GLuint; pname: GLenum; params: PGLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPrimitiveRestartNV: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPrimitiveRestartIndexNV: procedure (index: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glQueryResourceNV: function (queryType: GLenum; tagId: GLint; count: GLuint; buffer: PGLint): GLint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenQueryResourceTagNV: procedure (n: GLsizei; tagIds: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteQueryResourceTagNV: procedure (n: GLsizei; tagIds: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glQueryResourceTagNV: procedure (tagId: GLint; tagString: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCombinerParameterfvNV: procedure (pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCombinerParameterfNV: procedure (pname: GLenum; param: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCombinerParameterivNV: procedure (pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCombinerParameteriNV: procedure (pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCombinerInputNV: procedure (stage: GLenum; portion: GLenum; variable: GLenum; input: GLenum; mapping: GLenum; componentUsage: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCombinerOutputNV: procedure (stage: GLenum; portion: GLenum; abOutput: GLenum; cdOutput: GLenum; sumOutput: GLenum; scale: GLenum; bias: GLenum; abDotProduct: GLboolean; cdDotProduct: GLboolean; muxSum: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFinalCombinerInputNV: procedure (variable: GLenum; input: GLenum; mapping: GLenum; componentUsage: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetCombinerInputParameterfvNV: procedure (stage: GLenum; portion: GLenum; variable: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetCombinerInputParameterivNV: procedure (stage: GLenum; portion: GLenum; variable: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetCombinerOutputParameterfvNV: procedure (stage: GLenum; portion: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetCombinerOutputParameterivNV: procedure (stage: GLenum; portion: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetFinalCombinerInputParameterfvNV: procedure (variable: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetFinalCombinerInputParameterivNV: procedure (variable: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCombinerStageParameterfvNV: procedure (stage: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetCombinerStageParameterfvNV: procedure (stage: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFramebufferSampleLocationsfvNV: procedure (target: GLenum; start: GLuint; count: GLsizei; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedFramebufferSampleLocationsfvNV: procedure (framebuffer: GLuint; start: GLuint; count: GLsizei; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glResolveDepthValuesNV: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glScissorExclusiveNV: procedure (x: GLint; y: GLint; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glScissorExclusiveArrayvNV: procedure (first: GLuint; count: GLsizei; v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMakeBufferResidentNV: procedure (target: GLenum; access: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMakeBufferNonResidentNV: procedure (target: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsBufferResidentNV: function (target: GLenum): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMakeNamedBufferResidentNV: procedure (buffer: GLuint; access: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMakeNamedBufferNonResidentNV: procedure (buffer: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsNamedBufferResidentNV: function (buffer: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetBufferParameterui64vNV: procedure (target: GLenum; pname: GLenum; params: PGLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetNamedBufferParameterui64vNV: procedure (buffer: GLuint; pname: GLenum; params: PGLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetIntegerui64vNV: procedure (value: GLenum; result: PGLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformui64NV: procedure (location: GLint; value: GLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformui64vNV: procedure (location: GLint; count: GLsizei; value: PGLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformui64NV: procedure (program_: GLuint; location: GLint; value: GLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformui64vNV: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindShadingRateImageNV: procedure (texture: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetShadingRateImagePaletteNV: procedure (viewport: GLuint; entry: GLuint; rate: PGLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetShadingRateSampleLocationivNV: procedure (rate: GLenum; samples: GLuint; index: GLuint; location: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glShadingRateImageBarrierNV: procedure (synchronize: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glShadingRateImagePaletteNV: procedure (viewport: GLuint; first: GLuint; count: GLsizei; rates: PGLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glShadingRateSampleOrderNV: procedure (order: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glShadingRateSampleOrderCustomNV: procedure (rate: GLenum; samples: GLuint; locations: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureBarrierNV: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexImage2DMultisampleCoverageNV: procedure (target: GLenum; coverageSamples: GLsizei; colorSamples: GLsizei; internalFormat: GLint; width: GLsizei; height: GLsizei; fixedSampleLocations: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexImage3DMultisampleCoverageNV: procedure (target: GLenum; coverageSamples: GLsizei; colorSamples: GLsizei; internalFormat: GLint; width: GLsizei; height: GLsizei; depth: GLsizei; fixedSampleLocations: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureImage2DMultisampleNV: procedure (texture: GLuint; target: GLenum; samples: GLsizei; internalFormat: GLint; width: GLsizei; height: GLsizei; fixedSampleLocations: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureImage3DMultisampleNV: procedure (texture: GLuint; target: GLenum; samples: GLsizei; internalFormat: GLint; width: GLsizei; height: GLsizei; depth: GLsizei; fixedSampleLocations: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureImage2DMultisampleCoverageNV: procedure (texture: GLuint; target: GLenum; coverageSamples: GLsizei; colorSamples: GLsizei; internalFormat: GLint; width: GLsizei; height: GLsizei; fixedSampleLocations: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureImage3DMultisampleCoverageNV: procedure (texture: GLuint; target: GLenum; coverageSamples: GLsizei; colorSamples: GLsizei; internalFormat: GLint; width: GLsizei; height: GLsizei; depth: GLsizei; fixedSampleLocations: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCreateSemaphoresNV: procedure (n: GLsizei; semaphores: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSemaphoreParameterivNV: procedure (semaphore: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetSemaphoreParameterivNV: procedure (semaphore: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBeginTransformFeedbackNV: procedure (primitiveMode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEndTransformFeedbackNV: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTransformFeedbackAttribsNV: procedure (count: GLsizei; attribs: PGLint; bufferMode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindBufferRangeNV: procedure (target: GLenum; index: GLuint; buffer: GLuint; offset: GLintptr; size: GLsizeiptr); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindBufferOffsetNV: procedure (target: GLenum; index: GLuint; buffer: GLuint; offset: GLintptr); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindBufferBaseNV: procedure (target: GLenum; index: GLuint; buffer: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTransformFeedbackVaryingsNV: procedure (program_: GLuint; count: GLsizei; locations: PGLint; bufferMode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glActiveVaryingNV: procedure (program_: GLuint; name: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVaryingLocationNV: function (program_: GLuint; name: PGLchar): GLint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetActiveVaryingNV: procedure (program_: GLuint; index: GLuint; bufSize: GLsizei; length: PGLsizei; size: PGLsizei; type_: PGLenum; name: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTransformFeedbackVaryingNV: procedure (program_: GLuint; index: GLuint; location: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTransformFeedbackStreamAttribsNV: procedure (count: GLsizei; attribs: PGLint; nbuffers: GLsizei; bufstreams: PGLint; bufferMode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindTransformFeedbackNV: procedure (target: GLenum; id: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteTransformFeedbacksNV: procedure (n: GLsizei; ids: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenTransformFeedbacksNV: procedure (n: GLsizei; ids: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsTransformFeedbackNV: function (id: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPauseTransformFeedbackNV: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glResumeTransformFeedbackNV: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawTransformFeedbackNV: procedure (mode: GLenum; id: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVDPAUInitNV: procedure (vdpDevice: Pointer; getProcAddress: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVDPAUFiniNV: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVDPAURegisterVideoSurfaceNV: function (vdpSurface: Pointer; target: GLenum; numTextureNames: GLsizei; textureNames: PGLuint): GLvdpauSurfaceNV; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVDPAURegisterOutputSurfaceNV: function (vdpSurface: Pointer; target: GLenum; numTextureNames: GLsizei; textureNames: PGLuint): GLvdpauSurfaceNV; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVDPAUIsSurfaceNV: function (surface: GLvdpauSurfaceNV): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVDPAUUnregisterSurfaceNV: procedure (surface: GLvdpauSurfaceNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVDPAUGetSurfaceivNV: procedure (surface: GLvdpauSurfaceNV; pname: GLenum; count: GLsizei; length: PGLsizei; values: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVDPAUSurfaceAccessNV: procedure (surface: GLvdpauSurfaceNV; access: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVDPAUMapSurfacesNV: procedure (numSurfaces: GLsizei; surfaces: PGLvdpauSurfaceNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVDPAUUnmapSurfacesNV: procedure (numSurface: GLsizei; surfaces: PGLvdpauSurfaceNV); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVDPAURegisterVideoSurfaceWithPictureStructureNV: function (vdpSurface: Pointer; target: GLenum; numTextureNames: GLsizei; textureNames: PGLuint; isFrameStructure: GLboolean): GLvdpauSurfaceNV; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFlushVertexArrayRangeNV: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexArrayRangeNV: procedure (length: GLsizei; pointer: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribL1i64NV: procedure (index: GLuint; x: GLint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribL2i64NV: procedure (index: GLuint; x: GLint64EXT; y: GLint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribL3i64NV: procedure (index: GLuint; x: GLint64EXT; y: GLint64EXT; z: GLint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribL4i64NV: procedure (index: GLuint; x: GLint64EXT; y: GLint64EXT; z: GLint64EXT; w: GLint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribL1i64vNV: procedure (index: GLuint; v: PGLint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribL2i64vNV: procedure (index: GLuint; v: PGLint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribL3i64vNV: procedure (index: GLuint; v: PGLint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribL4i64vNV: procedure (index: GLuint; v: PGLint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribL1ui64NV: procedure (index: GLuint; x: GLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribL2ui64NV: procedure (index: GLuint; x: GLuint64EXT; y: GLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribL3ui64NV: procedure (index: GLuint; x: GLuint64EXT; y: GLuint64EXT; z: GLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribL4ui64NV: procedure (index: GLuint; x: GLuint64EXT; y: GLuint64EXT; z: GLuint64EXT; w: GLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribL1ui64vNV: procedure (index: GLuint; v: PGLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribL2ui64vNV: procedure (index: GLuint; v: PGLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribL3ui64vNV: procedure (index: GLuint; v: PGLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribL4ui64vNV: procedure (index: GLuint; v: PGLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVertexAttribLi64vNV: procedure (index: GLuint; pname: GLenum; params: PGLint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVertexAttribLui64vNV: procedure (index: GLuint; pname: GLenum; params: PGLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribLFormatNV: procedure (index: GLuint; size: GLint; type_: GLenum; stride: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBufferAddressRangeNV: procedure (pname: GLenum; index: GLuint; address: GLuint64EXT; length: GLsizeiptr); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexFormatNV: procedure (size: GLint; type_: GLenum; stride: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNormalFormatNV: procedure (type_: GLenum; stride: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColorFormatNV: procedure (size: GLint; type_: GLenum; stride: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIndexFormatNV: procedure (type_: GLenum; stride: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoordFormatNV: procedure (size: GLint; type_: GLenum; stride: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEdgeFlagFormatNV: procedure (stride: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSecondaryColorFormatNV: procedure (size: GLint; type_: GLenum; stride: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFogCoordFormatNV: procedure (type_: GLenum; stride: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribFormatNV: procedure (index: GLuint; size: GLint; type_: GLenum; normalized: GLboolean; stride: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribIFormatNV: procedure (index: GLuint; size: GLint; type_: GLenum; stride: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetIntegerui64i_vNV: procedure (value: GLenum; index: GLuint; result: PGLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glAreProgramsResidentNV: function (n: GLsizei; programs: PGLuint; residences: PGLboolean): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindProgramNV: procedure (target: GLenum; id: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteProgramsNV: procedure (n: GLsizei; programs: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glExecuteProgramNV: procedure (target: GLenum; id: GLuint; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenProgramsNV: procedure (n: GLsizei; programs: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetProgramParameterdvNV: procedure (target: GLenum; index: GLuint; pname: GLenum; params: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetProgramParameterfvNV: procedure (target: GLenum; index: GLuint; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetProgramivNV: procedure (id: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetProgramStringNV: procedure (id: GLuint; pname: GLenum; program_: PGLubyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTrackMatrixivNV: procedure (target: GLenum; address: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVertexAttribdvNV: procedure (index: GLuint; pname: GLenum; params: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVertexAttribfvNV: procedure (index: GLuint; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVertexAttribivNV: procedure (index: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVertexAttribPointervNV: procedure (index: GLuint; pname: GLenum; pointer: PPointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsProgramNV: function (id: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glLoadProgramNV: procedure (target: GLenum; id: GLuint; len: GLsizei; program_: PGLubyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramParameter4dNV: procedure (target: GLenum; index: GLuint; x: GLdouble; y: GLdouble; z: GLdouble; w: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramParameter4dvNV: procedure (target: GLenum; index: GLuint; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramParameter4fNV: procedure (target: GLenum; index: GLuint; x: GLfloat; y: GLfloat; z: GLfloat; w: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramParameter4fvNV: procedure (target: GLenum; index: GLuint; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramParameters4dvNV: procedure (target: GLenum; index: GLuint; count: GLsizei; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramParameters4fvNV: procedure (target: GLenum; index: GLuint; count: GLsizei; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRequestResidentProgramsNV: procedure (n: GLsizei; programs: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTrackMatrixNV: procedure (target: GLenum; address: GLuint; matrix: GLenum; transform: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribPointerNV: procedure (index: GLuint; fsize: GLint; type_: GLenum; stride: GLsizei; pointer: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib1dNV: procedure (index: GLuint; x: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib1dvNV: procedure (index: GLuint; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib1fNV: procedure (index: GLuint; x: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib1fvNV: procedure (index: GLuint; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib1sNV: procedure (index: GLuint; x: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib1svNV: procedure (index: GLuint; v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib2dNV: procedure (index: GLuint; x: GLdouble; y: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib2dvNV: procedure (index: GLuint; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib2fNV: procedure (index: GLuint; x: GLfloat; y: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib2fvNV: procedure (index: GLuint; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib2sNV: procedure (index: GLuint; x: GLshort; y: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib2svNV: procedure (index: GLuint; v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib3dNV: procedure (index: GLuint; x: GLdouble; y: GLdouble; z: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib3dvNV: procedure (index: GLuint; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib3fNV: procedure (index: GLuint; x: GLfloat; y: GLfloat; z: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib3fvNV: procedure (index: GLuint; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib3sNV: procedure (index: GLuint; x: GLshort; y: GLshort; z: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib3svNV: procedure (index: GLuint; v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4dNV: procedure (index: GLuint; x: GLdouble; y: GLdouble; z: GLdouble; w: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4dvNV: procedure (index: GLuint; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4fNV: procedure (index: GLuint; x: GLfloat; y: GLfloat; z: GLfloat; w: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4fvNV: procedure (index: GLuint; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4sNV: procedure (index: GLuint; x: GLshort; y: GLshort; z: GLshort; w: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4svNV: procedure (index: GLuint; v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4ubNV: procedure (index: GLuint; x: GLubyte; y: GLubyte; z: GLubyte; w: GLubyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4ubvNV: procedure (index: GLuint; v: PGLubyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribs1dvNV: procedure (index: GLuint; count: GLsizei; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribs1fvNV: procedure (index: GLuint; count: GLsizei; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribs1svNV: procedure (index: GLuint; count: GLsizei; v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribs2dvNV: procedure (index: GLuint; count: GLsizei; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribs2fvNV: procedure (index: GLuint; count: GLsizei; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribs2svNV: procedure (index: GLuint; count: GLsizei; v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribs3dvNV: procedure (index: GLuint; count: GLsizei; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribs3fvNV: procedure (index: GLuint; count: GLsizei; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribs3svNV: procedure (index: GLuint; count: GLsizei; v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribs4dvNV: procedure (index: GLuint; count: GLsizei; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribs4fvNV: procedure (index: GLuint; count: GLsizei; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribs4svNV: procedure (index: GLuint; count: GLsizei; v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribs4ubvNV: procedure (index: GLuint; count: GLsizei; v: PGLubyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBeginVideoCaptureNV: procedure (video_capture_slot: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindVideoCaptureStreamBufferNV: procedure (video_capture_slot: GLuint; stream: GLuint; frame_region: GLenum; offset: GLintptrARB); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindVideoCaptureStreamTextureNV: procedure (video_capture_slot: GLuint; stream: GLuint; frame_region: GLenum; target: GLenum; texture: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEndVideoCaptureNV: procedure (video_capture_slot: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVideoCaptureivNV: procedure (video_capture_slot: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVideoCaptureStreamivNV: procedure (video_capture_slot: GLuint; stream: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVideoCaptureStreamfvNV: procedure (video_capture_slot: GLuint; stream: GLuint; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVideoCaptureStreamdvNV: procedure (video_capture_slot: GLuint; stream: GLuint; pname: GLenum; params: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVideoCaptureNV: function (video_capture_slot: GLuint; sequence_num: PGLuint; capture_time: PGLuint64EXT): GLenum; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVideoCaptureStreamParameterivNV: procedure (video_capture_slot: GLuint; stream: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVideoCaptureStreamParameterfvNV: procedure (video_capture_slot: GLuint; stream: GLuint; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVideoCaptureStreamParameterdvNV: procedure (video_capture_slot: GLuint; stream: GLuint; pname: GLenum; params: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glViewportSwizzleNV: procedure (index: GLuint; swizzlex: GLenum; swizzley: GLenum; swizzlez: GLenum; swizzlew: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord1bOES: procedure (texture: GLenum; s: GLbyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord1bvOES: procedure (texture: GLenum; coords: PGLbyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord2bOES: procedure (texture: GLenum; s: GLbyte; t: GLbyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord2bvOES: procedure (texture: GLenum; coords: PGLbyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord3bOES: procedure (texture: GLenum; s: GLbyte; t: GLbyte; r: GLbyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord3bvOES: procedure (texture: GLenum; coords: PGLbyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord4bOES: procedure (texture: GLenum; s: GLbyte; t: GLbyte; r: GLbyte; q: GLbyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord4bvOES: procedure (texture: GLenum; coords: PGLbyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord1bOES: procedure (s: GLbyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord1bvOES: procedure (coords: PGLbyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord2bOES: procedure (s: GLbyte; t: GLbyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord2bvOES: procedure (coords: PGLbyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord3bOES: procedure (s: GLbyte; t: GLbyte; r: GLbyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord3bvOES: procedure (coords: PGLbyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord4bOES: procedure (s: GLbyte; t: GLbyte; r: GLbyte; q: GLbyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord4bvOES: procedure (coords: PGLbyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertex2bOES: procedure (x: GLbyte; y: GLbyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertex2bvOES: procedure (coords: PGLbyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertex3bOES: procedure (x: GLbyte; y: GLbyte; z: GLbyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertex3bvOES: procedure (coords: PGLbyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertex4bOES: procedure (x: GLbyte; y: GLbyte; z: GLbyte; w: GLbyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertex4bvOES: procedure (coords: PGLbyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glAlphaFuncxOES: procedure (func: GLenum; ref: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClearColorxOES: procedure (red: GLfixed; green: GLfixed; blue: GLfixed; alpha: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClearDepthxOES: procedure (depth: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClipPlanexOES: procedure (plane: GLenum; equation: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor4xOES: procedure (red: GLfixed; green: GLfixed; blue: GLfixed; alpha: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDepthRangexOES: procedure (n: GLfixed; f: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFogxOES: procedure (pname: GLenum; param: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFogxvOES: procedure (pname: GLenum; param: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFrustumxOES: procedure (l: GLfixed; r: GLfixed; b: GLfixed; t: GLfixed; n: GLfixed; f: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetClipPlanexOES: procedure (plane: GLenum; equation: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetFixedvOES: procedure (pname: GLenum; params: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTexEnvxvOES: procedure (target: GLenum; pname: GLenum; params: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTexParameterxvOES: procedure (target: GLenum; pname: GLenum; params: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glLightModelxOES: procedure (pname: GLenum; param: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glLightModelxvOES: procedure (pname: GLenum; param: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glLightxOES: procedure (light: GLenum; pname: GLenum; param: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glLightxvOES: procedure (light: GLenum; pname: GLenum; params: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glLineWidthxOES: procedure (width: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glLoadMatrixxOES: procedure (m: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMaterialxOES: procedure (face: GLenum; pname: GLenum; param: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMaterialxvOES: procedure (face: GLenum; pname: GLenum; param: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultMatrixxOES: procedure (m: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord4xOES: procedure (texture: GLenum; s: GLfixed; t: GLfixed; r: GLfixed; q: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNormal3xOES: procedure (nx: GLfixed; ny: GLfixed; nz: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glOrthoxOES: procedure (l: GLfixed; r: GLfixed; b: GLfixed; t: GLfixed; n: GLfixed; f: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPointParameterxvOES: procedure (pname: GLenum; params: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPointSizexOES: procedure (size: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPolygonOffsetxOES: procedure (factor: GLfixed; units: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRotatexOES: procedure (angle: GLfixed; x: GLfixed; y: GLfixed; z: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glScalexOES: procedure (x: GLfixed; y: GLfixed; z: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexEnvxOES: procedure (target: GLenum; pname: GLenum; param: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexEnvxvOES: procedure (target: GLenum; pname: GLenum; params: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexParameterxOES: procedure (target: GLenum; pname: GLenum; param: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexParameterxvOES: procedure (target: GLenum; pname: GLenum; params: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTranslatexOES: procedure (x: GLfixed; y: GLfixed; z: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetLightxvOES: procedure (light: GLenum; pname: GLenum; params: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetMaterialxvOES: procedure (face: GLenum; pname: GLenum; params: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPointParameterxOES: procedure (pname: GLenum; param: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSampleCoveragexOES: procedure (value: GLclampx; invert: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glAccumxOES: procedure (op: GLenum; value: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBitmapxOES: procedure (width: GLsizei; height: GLsizei; xorig: GLfixed; yorig: GLfixed; xmove: GLfixed; ymove: GLfixed; bitmap: PGLubyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlendColorxOES: procedure (red: GLfixed; green: GLfixed; blue: GLfixed; alpha: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClearAccumxOES: procedure (red: GLfixed; green: GLfixed; blue: GLfixed; alpha: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor3xOES: procedure (red: GLfixed; green: GLfixed; blue: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor3xvOES: procedure (components: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor4xvOES: procedure (components: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glConvolutionParameterxOES: procedure (target: GLenum; pname: GLenum; param: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glConvolutionParameterxvOES: procedure (target: GLenum; pname: GLenum; params: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEvalCoord1xOES: procedure (u: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEvalCoord1xvOES: procedure (coords: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEvalCoord2xOES: procedure (u: GLfixed; v: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEvalCoord2xvOES: procedure (coords: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFeedbackBufferxOES: procedure (n: GLsizei; type_: GLenum; buffer: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetConvolutionParameterxvOES: procedure (target: GLenum; pname: GLenum; params: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetHistogramParameterxvOES: procedure (target: GLenum; pname: GLenum; params: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetLightxOES: procedure (light: GLenum; pname: GLenum; params: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetMapxvOES: procedure (target: GLenum; query: GLenum; v: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetMaterialxOES: procedure (face: GLenum; pname: GLenum; param: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPixelMapxv: procedure (map: GLenum; size: GLint; values: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTexGenxvOES: procedure (coord: GLenum; pname: GLenum; params: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTexLevelParameterxvOES: procedure (target: GLenum; level: GLint; pname: GLenum; params: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIndexxOES: procedure (component: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIndexxvOES: procedure (component: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glLoadTransposeMatrixxOES: procedure (m: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMap1xOES: procedure (target: GLenum; u1: GLfixed; u2: GLfixed; stride: GLint; order: GLint; points: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMap2xOES: procedure (target: GLenum; u1: GLfixed; u2: GLfixed; ustride: GLint; uorder: GLint; v1: GLfixed; v2: GLfixed; vstride: GLint; vorder: GLint; points: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMapGrid1xOES: procedure (n: GLint; u1: GLfixed; u2: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMapGrid2xOES: procedure (n: GLint; u1: GLfixed; u2: GLfixed; v1: GLfixed; v2: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultTransposeMatrixxOES: procedure (m: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord1xOES: procedure (texture: GLenum; s: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord1xvOES: procedure (texture: GLenum; coords: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord2xOES: procedure (texture: GLenum; s: GLfixed; t: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord2xvOES: procedure (texture: GLenum; coords: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord3xOES: procedure (texture: GLenum; s: GLfixed; t: GLfixed; r: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord3xvOES: procedure (texture: GLenum; coords: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord4xvOES: procedure (texture: GLenum; coords: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNormal3xvOES: procedure (coords: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPassThroughxOES: procedure (token: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPixelMapx: procedure (map: GLenum; size: GLint; values: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPixelStorex: procedure (pname: GLenum; param: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPixelTransferxOES: procedure (pname: GLenum; param: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPixelZoomxOES: procedure (xfactor: GLfixed; yfactor: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPrioritizeTexturesxOES: procedure (n: GLsizei; textures: PGLuint; priorities: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRasterPos2xOES: procedure (x: GLfixed; y: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRasterPos2xvOES: procedure (coords: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRasterPos3xOES: procedure (x: GLfixed; y: GLfixed; z: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRasterPos3xvOES: procedure (coords: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRasterPos4xOES: procedure (x: GLfixed; y: GLfixed; z: GLfixed; w: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRasterPos4xvOES: procedure (coords: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRectxOES: procedure (x1: GLfixed; y1: GLfixed; x2: GLfixed; y2: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRectxvOES: procedure (v1: PGLfixed; v2: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord1xOES: procedure (s: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord1xvOES: procedure (coords: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord2xOES: procedure (s: GLfixed; t: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord2xvOES: procedure (coords: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord3xOES: procedure (s: GLfixed; t: GLfixed; r: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord3xvOES: procedure (coords: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord4xOES: procedure (s: GLfixed; t: GLfixed; r: GLfixed; q: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord4xvOES: procedure (coords: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexGenxOES: procedure (coord: GLenum; pname: GLenum; param: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexGenxvOES: procedure (coord: GLenum; pname: GLenum; params: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertex2xOES: procedure (x: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertex2xvOES: procedure (coords: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertex3xOES: procedure (x: GLfixed; y: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertex3xvOES: procedure (coords: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertex4xOES: procedure (x: GLfixed; y: GLfixed; z: GLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertex4xvOES: procedure (coords: PGLfixed); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glQueryMatrixxOES: function (mantissa: PGLfixed; exponent: PGLint): GLbitfield; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClearDepthfOES: procedure (depth: GLclampf); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClipPlanefOES: procedure (plane: GLenum; equation: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDepthRangefOES: procedure (n: GLclampf; f: GLclampf); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFrustumfOES: procedure (l: GLfloat; r: GLfloat; b: GLfloat; t: GLfloat; n: GLfloat; f: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetClipPlanefOES: procedure (plane: GLenum; equation: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glOrthofOES: procedure (l: GLfloat; r: GLfloat; b: GLfloat; t: GLfloat; n: GLfloat; f: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFramebufferTextureMultiviewOVR: procedure (target: GLenum; attachment: GLenum; texture: GLuint; level: GLint; baseViewIndex: GLint; numViews: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedFramebufferTextureMultiviewOVR: procedure (framebuffer: GLuint; attachment: GLenum; texture: GLuint; level: GLint; baseViewIndex: GLint; numViews: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glHintPGI: procedure (target: GLenum; mode: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDetailTexFuncSGIS: procedure (target: GLenum; n: GLsizei; points: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetDetailTexFuncSGIS: procedure (target: GLenum; points: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFogFuncSGIS: procedure (n: GLsizei; points: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetFogFuncSGIS: procedure (points: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSampleMaskSGIS: procedure (value: GLclampf; invert: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSamplePatternSGIS: procedure (pattern: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPixelTexGenParameteriSGIS: procedure (pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPixelTexGenParameterivSGIS: procedure (pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPixelTexGenParameterfSGIS: procedure (pname: GLenum; param: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPixelTexGenParameterfvSGIS: procedure (pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPixelTexGenParameterivSGIS: procedure (pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPixelTexGenParameterfvSGIS: procedure (pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPointParameterfSGIS: procedure (pname: GLenum; param: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPointParameterfvSGIS: procedure (pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSharpenTexFuncSGIS: procedure (target: GLenum; n: GLsizei; points: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetSharpenTexFuncSGIS: procedure (target: GLenum; points: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexImage4DSGIS: procedure (target: GLenum; level: GLint; internalformat: GLenum; width: GLsizei; height: GLsizei; depth: GLsizei; size4d: GLsizei; border: GLint; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexSubImage4DSGIS: procedure (target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; woffset: GLint; width: GLsizei; height: GLsizei; depth: GLsizei; size4d: GLsizei; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureColorMaskSGIS: procedure (red: GLboolean; green: GLboolean; blue: GLboolean; alpha: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTexFilterFuncSGIS: procedure (target: GLenum; filter: GLenum; weights: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexFilterFuncSGIS: procedure (target: GLenum; filter: GLenum; n: GLsizei; weights: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glAsyncMarkerSGIX: procedure (marker: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFinishAsyncSGIX: function (markerp: PGLuint): GLint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPollAsyncSGIX: function (markerp: PGLuint): GLint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenAsyncMarkersSGIX: function (range: GLsizei): GLuint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteAsyncMarkersSGIX: procedure (marker: GLuint; range: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsAsyncMarkerSGIX: function (marker: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFlushRasterSGIX: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFragmentColorMaterialSGIX: procedure (face: GLenum; mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFragmentLightfSGIX: procedure (light: GLenum; pname: GLenum; param: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFragmentLightfvSGIX: procedure (light: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFragmentLightiSGIX: procedure (light: GLenum; pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFragmentLightivSGIX: procedure (light: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFragmentLightModelfSGIX: procedure (pname: GLenum; param: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFragmentLightModelfvSGIX: procedure (pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFragmentLightModeliSGIX: procedure (pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFragmentLightModelivSGIX: procedure (pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFragmentMaterialfSGIX: procedure (face: GLenum; pname: GLenum; param: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFragmentMaterialfvSGIX: procedure (face: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFragmentMaterialiSGIX: procedure (face: GLenum; pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFragmentMaterialivSGIX: procedure (face: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetFragmentLightfvSGIX: procedure (light: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetFragmentLightivSGIX: procedure (light: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetFragmentMaterialfvSGIX: procedure (face: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetFragmentMaterialivSGIX: procedure (face: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glLightEnviSGIX: procedure (pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFrameZoomSGIX: procedure (factor: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIglooInterfaceSGIX: procedure (pname: GLenum; params: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetInstrumentsSGIX: function (): GLint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glInstrumentsBufferSGIX: procedure (size: GLsizei; buffer: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPollInstrumentsSGIX: function (marker_p: PGLint): GLint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glReadInstrumentsSGIX: procedure (marker: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glStartInstrumentsSGIX: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glStopInstrumentsSGIX: procedure (marker: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetListParameterfvSGIX: procedure (list: GLuint; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetListParameterivSGIX: procedure (list: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glListParameterfSGIX: procedure (list: GLuint; pname: GLenum; param: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glListParameterfvSGIX: procedure (list: GLuint; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glListParameteriSGIX: procedure (list: GLuint; pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glListParameterivSGIX: procedure (list: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPixelTexGenSGIX: procedure (mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeformationMap3dSGIX: procedure (target: GLenum; u1: GLdouble; u2: GLdouble; ustride: GLint; uorder: GLint; v1: GLdouble; v2: GLdouble; vstride: GLint; vorder: GLint; w1: GLdouble; w2: GLdouble; wstride: GLint; worder: GLint; points: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeformationMap3fSGIX: procedure (target: GLenum; u1: GLfloat; u2: GLfloat; ustride: GLint; uorder: GLint; v1: GLfloat; v2: GLfloat; vstride: GLint; vorder: GLint; w1: GLfloat; w2: GLfloat; wstride: GLint; worder: GLint; points: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeformSGIX: procedure (mask: GLbitfield); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glLoadIdentityDeformationMapSGIX: procedure (mask: GLbitfield); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glReferencePlaneSGIX: procedure (equation: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSpriteParameterfSGIX: procedure (pname: GLenum; param: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSpriteParameterfvSGIX: procedure (pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSpriteParameteriSGIX: procedure (pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSpriteParameterivSGIX: procedure (pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTagSampleBufferSGIX: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColorTableSGI: procedure (target: GLenum; internalformat: GLenum; width: GLsizei; format: GLenum; type_: GLenum; table: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColorTableParameterfvSGI: procedure (target: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColorTableParameterivSGI: procedure (target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyColorTableSGI: procedure (target: GLenum; internalformat: GLenum; x: GLint; y: GLint; width: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetColorTableSGI: procedure (target: GLenum; format: GLenum; type_: GLenum; table: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetColorTableParameterfvSGI: procedure (target: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetColorTableParameterivSGI: procedure (target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFinishTextureSUNX: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGlobalAlphaFactorbSUN: procedure (factor: GLbyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGlobalAlphaFactorsSUN: procedure (factor: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGlobalAlphaFactoriSUN: procedure (factor: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGlobalAlphaFactorfSUN: procedure (factor: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGlobalAlphaFactordSUN: procedure (factor: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGlobalAlphaFactorubSUN: procedure (factor: GLubyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGlobalAlphaFactorusSUN: procedure (factor: GLushort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGlobalAlphaFactoruiSUN: procedure (factor: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawMeshArraysSUN: procedure (mode: GLenum; first: GLint; count: GLsizei; width: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glReplacementCodeuiSUN: procedure (code: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glReplacementCodeusSUN: procedure (code: GLushort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glReplacementCodeubSUN: procedure (code: GLubyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glReplacementCodeuivSUN: procedure (code: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glReplacementCodeusvSUN: procedure (code: PGLushort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glReplacementCodeubvSUN: procedure (code: PGLubyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glReplacementCodePointerSUN: procedure (type_: GLenum; stride: GLsizei; pointer: PPointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor4ubVertex2fSUN: procedure (r: GLubyte; g: GLubyte; b: GLubyte; a: GLubyte; x: GLfloat; y: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor4ubVertex2fvSUN: procedure (c: PGLubyte; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor4ubVertex3fSUN: procedure (r: GLubyte; g: GLubyte; b: GLubyte; a: GLubyte; x: GLfloat; y: GLfloat; z: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor4ubVertex3fvSUN: procedure (c: PGLubyte; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor3fVertex3fSUN: procedure (r: GLfloat; g: GLfloat; b: GLfloat; x: GLfloat; y: GLfloat; z: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor3fVertex3fvSUN: procedure (c: PGLfloat; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNormal3fVertex3fSUN: procedure (nx: GLfloat; ny: GLfloat; nz: GLfloat; x: GLfloat; y: GLfloat; z: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNormal3fVertex3fvSUN: procedure (n: PGLfloat; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor4fNormal3fVertex3fSUN: procedure (r: GLfloat; g: GLfloat; b: GLfloat; a: GLfloat; nx: GLfloat; ny: GLfloat; nz: GLfloat; x: GLfloat; y: GLfloat; z: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor4fNormal3fVertex3fvSUN: procedure (c: PGLfloat; n: PGLfloat; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord2fVertex3fSUN: procedure (s: GLfloat; t: GLfloat; x: GLfloat; y: GLfloat; z: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord2fVertex3fvSUN: procedure (tc: PGLfloat; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord4fVertex4fSUN: procedure (s: GLfloat; t: GLfloat; p: GLfloat; q: GLfloat; x: GLfloat; y: GLfloat; z: GLfloat; w: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord4fVertex4fvSUN: procedure (tc: PGLfloat; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord2fColor4ubVertex3fSUN: procedure (s: GLfloat; t: GLfloat; r: GLubyte; g: GLubyte; b: GLubyte; a: GLubyte; x: GLfloat; y: GLfloat; z: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord2fColor4ubVertex3fvSUN: procedure (tc: PGLfloat; c: PGLubyte; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord2fColor3fVertex3fSUN: procedure (s: GLfloat; t: GLfloat; r: GLfloat; g: GLfloat; b: GLfloat; x: GLfloat; y: GLfloat; z: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord2fColor3fVertex3fvSUN: procedure (tc: PGLfloat; c: PGLfloat; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord2fNormal3fVertex3fSUN: procedure (s: GLfloat; t: GLfloat; nx: GLfloat; ny: GLfloat; nz: GLfloat; x: GLfloat; y: GLfloat; z: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord2fNormal3fVertex3fvSUN: procedure (tc: PGLfloat; n: PGLfloat; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord2fColor4fNormal3fVertex3fSUN: procedure (s: GLfloat; t: GLfloat; r: GLfloat; g: GLfloat; b: GLfloat; a: GLfloat; nx: GLfloat; ny: GLfloat; nz: GLfloat; x: GLfloat; y: GLfloat; z: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord2fColor4fNormal3fVertex3fvSUN: procedure (tc: PGLfloat; c: PGLfloat; n: PGLfloat; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord4fColor4fNormal3fVertex4fSUN: procedure (s: GLfloat; t: GLfloat; p: GLfloat; q: GLfloat; r: GLfloat; g: GLfloat; b: GLfloat; a: GLfloat; nx: GLfloat; ny: GLfloat; nz: GLfloat; x: GLfloat; y: GLfloat; z: GLfloat; w: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord4fColor4fNormal3fVertex4fvSUN: procedure (tc: PGLfloat; c: PGLfloat; n: PGLfloat; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glReplacementCodeuiVertex3fSUN: procedure (rc: GLuint; x: GLfloat; y: GLfloat; z: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glReplacementCodeuiVertex3fvSUN: procedure (rc: PGLuint; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glReplacementCodeuiColor4ubVertex3fSUN: procedure (rc: GLuint; r: GLubyte; g: GLubyte; b: GLubyte; a: GLubyte; x: GLfloat; y: GLfloat; z: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glReplacementCodeuiColor4ubVertex3fvSUN: procedure (rc: PGLuint; c: PGLubyte; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glReplacementCodeuiColor3fVertex3fSUN: procedure (rc: GLuint; r: GLfloat; g: GLfloat; b: GLfloat; x: GLfloat; y: GLfloat; z: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glReplacementCodeuiColor3fVertex3fvSUN: procedure (rc: PGLuint; c: PGLfloat; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glReplacementCodeuiNormal3fVertex3fSUN: procedure (rc: GLuint; nx: GLfloat; ny: GLfloat; nz: GLfloat; x: GLfloat; y: GLfloat; z: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glReplacementCodeuiNormal3fVertex3fvSUN: procedure (rc: PGLuint; n: PGLfloat; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glReplacementCodeuiColor4fNormal3fVertex3fSUN: procedure (rc: GLuint; r: GLfloat; g: GLfloat; b: GLfloat; a: GLfloat; nx: GLfloat; ny: GLfloat; nz: GLfloat; x: GLfloat; y: GLfloat; z: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glReplacementCodeuiColor4fNormal3fVertex3fvSUN: procedure (rc: PGLuint; c: PGLfloat; n: PGLfloat; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glReplacementCodeuiTexCoord2fVertex3fSUN: procedure (rc: GLuint; s: GLfloat; t: GLfloat; x: GLfloat; y: GLfloat; z: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glReplacementCodeuiTexCoord2fVertex3fvSUN: procedure (rc: PGLuint; tc: PGLfloat; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN: procedure (rc: GLuint; s: GLfloat; t: GLfloat; nx: GLfloat; ny: GLfloat; nz: GLfloat; x: GLfloat; y: GLfloat; z: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN: procedure (rc: PGLuint; tc: PGLfloat; n: PGLfloat; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN: procedure (rc: GLuint; s: GLfloat; t: GLfloat; r: GLfloat; g: GLfloat; b: GLfloat; a: GLfloat; nx: GLfloat; ny: GLfloat; nz: GLfloat; x: GLfloat; y: GLfloat; z: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN: procedure (rc: PGLuint; tc: PGLfloat; c: PGLfloat; n: PGLfloat; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}

type
  TLoadProc = function(proc: PAnsiChar): Pointer;

function gladLoadGLExt(load: TLoadProc): boolean;


implementation


procedure load_GL_3DFX_tbuffer(load: TLoadProc);
begin
  if not GLAD_GL_3DFX_tbuffer then exit;
  glTbufferMask3DFX := load('glTbufferMask3DFX');
end;

procedure load_GL_AMD_debug_output(load: TLoadProc);
begin
  if not GLAD_GL_AMD_debug_output then exit;
  glDebugMessageEnableAMD := load('glDebugMessageEnableAMD');
  glDebugMessageInsertAMD := load('glDebugMessageInsertAMD');
  glDebugMessageCallbackAMD := load('glDebugMessageCallbackAMD');
  glGetDebugMessageLogAMD := load('glGetDebugMessageLogAMD');
end;

procedure load_GL_AMD_draw_buffers_blend(load: TLoadProc);
begin
  if not GLAD_GL_AMD_draw_buffers_blend then exit;
  glBlendFuncIndexedAMD := load('glBlendFuncIndexedAMD');
  glBlendFuncSeparateIndexedAMD := load('glBlendFuncSeparateIndexedAMD');
  glBlendEquationIndexedAMD := load('glBlendEquationIndexedAMD');
  glBlendEquationSeparateIndexedAMD := load('glBlendEquationSeparateIndexedAMD');
end;

procedure load_GL_AMD_framebuffer_multisample_advanced(load: TLoadProc);
begin
  if not GLAD_GL_AMD_framebuffer_multisample_advanced then exit;
  glRenderbufferStorageMultisampleAdvancedAMD := load('glRenderbufferStorageMultisampleAdvancedAMD');
  glNamedRenderbufferStorageMultisampleAdvancedAMD := load('glNamedRenderbufferStorageMultisampleAdvancedAMD');
end;

procedure load_GL_AMD_framebuffer_sample_positions(load: TLoadProc);
begin
  if not GLAD_GL_AMD_framebuffer_sample_positions then exit;
  glFramebufferSamplePositionsfvAMD := load('glFramebufferSamplePositionsfvAMD');
  glNamedFramebufferSamplePositionsfvAMD := load('glNamedFramebufferSamplePositionsfvAMD');
  glGetFramebufferParameterfvAMD := load('glGetFramebufferParameterfvAMD');
  glGetNamedFramebufferParameterfvAMD := load('glGetNamedFramebufferParameterfvAMD');
end;

procedure load_GL_AMD_gpu_shader_int64(load: TLoadProc);
begin
  if not GLAD_GL_AMD_gpu_shader_int64 then exit;
  glUniform1i64NV := load('glUniform1i64NV');
  glUniform2i64NV := load('glUniform2i64NV');
  glUniform3i64NV := load('glUniform3i64NV');
  glUniform4i64NV := load('glUniform4i64NV');
  glUniform1i64vNV := load('glUniform1i64vNV');
  glUniform2i64vNV := load('glUniform2i64vNV');
  glUniform3i64vNV := load('glUniform3i64vNV');
  glUniform4i64vNV := load('glUniform4i64vNV');
  glUniform1ui64NV := load('glUniform1ui64NV');
  glUniform2ui64NV := load('glUniform2ui64NV');
  glUniform3ui64NV := load('glUniform3ui64NV');
  glUniform4ui64NV := load('glUniform4ui64NV');
  glUniform1ui64vNV := load('glUniform1ui64vNV');
  glUniform2ui64vNV := load('glUniform2ui64vNV');
  glUniform3ui64vNV := load('glUniform3ui64vNV');
  glUniform4ui64vNV := load('glUniform4ui64vNV');
  glGetUniformi64vNV := load('glGetUniformi64vNV');
  glGetUniformui64vNV := load('glGetUniformui64vNV');
  glProgramUniform1i64NV := load('glProgramUniform1i64NV');
  glProgramUniform2i64NV := load('glProgramUniform2i64NV');
  glProgramUniform3i64NV := load('glProgramUniform3i64NV');
  glProgramUniform4i64NV := load('glProgramUniform4i64NV');
  glProgramUniform1i64vNV := load('glProgramUniform1i64vNV');
  glProgramUniform2i64vNV := load('glProgramUniform2i64vNV');
  glProgramUniform3i64vNV := load('glProgramUniform3i64vNV');
  glProgramUniform4i64vNV := load('glProgramUniform4i64vNV');
  glProgramUniform1ui64NV := load('glProgramUniform1ui64NV');
  glProgramUniform2ui64NV := load('glProgramUniform2ui64NV');
  glProgramUniform3ui64NV := load('glProgramUniform3ui64NV');
  glProgramUniform4ui64NV := load('glProgramUniform4ui64NV');
  glProgramUniform1ui64vNV := load('glProgramUniform1ui64vNV');
  glProgramUniform2ui64vNV := load('glProgramUniform2ui64vNV');
  glProgramUniform3ui64vNV := load('glProgramUniform3ui64vNV');
  glProgramUniform4ui64vNV := load('glProgramUniform4ui64vNV');
end;

procedure load_GL_AMD_interleaved_elements(load: TLoadProc);
begin
  if not GLAD_GL_AMD_interleaved_elements then exit;
  glVertexAttribParameteriAMD := load('glVertexAttribParameteriAMD');
end;

procedure load_GL_AMD_multi_draw_indirect(load: TLoadProc);
begin
  if not GLAD_GL_AMD_multi_draw_indirect then exit;
  glMultiDrawArraysIndirectAMD := load('glMultiDrawArraysIndirectAMD');
  glMultiDrawElementsIndirectAMD := load('glMultiDrawElementsIndirectAMD');
end;

procedure load_GL_AMD_name_gen_delete(load: TLoadProc);
begin
  if not GLAD_GL_AMD_name_gen_delete then exit;
  glGenNamesAMD := load('glGenNamesAMD');
  glDeleteNamesAMD := load('glDeleteNamesAMD');
  glIsNameAMD := load('glIsNameAMD');
end;

procedure load_GL_AMD_occlusion_query_event(load: TLoadProc);
begin
  if not GLAD_GL_AMD_occlusion_query_event then exit;
  glQueryObjectParameteruiAMD := load('glQueryObjectParameteruiAMD');
end;

procedure load_GL_AMD_performance_monitor(load: TLoadProc);
begin
  if not GLAD_GL_AMD_performance_monitor then exit;
  glGetPerfMonitorGroupsAMD := load('glGetPerfMonitorGroupsAMD');
  glGetPerfMonitorCountersAMD := load('glGetPerfMonitorCountersAMD');
  glGetPerfMonitorGroupStringAMD := load('glGetPerfMonitorGroupStringAMD');
  glGetPerfMonitorCounterStringAMD := load('glGetPerfMonitorCounterStringAMD');
  glGetPerfMonitorCounterInfoAMD := load('glGetPerfMonitorCounterInfoAMD');
  glGenPerfMonitorsAMD := load('glGenPerfMonitorsAMD');
  glDeletePerfMonitorsAMD := load('glDeletePerfMonitorsAMD');
  glSelectPerfMonitorCountersAMD := load('glSelectPerfMonitorCountersAMD');
  glBeginPerfMonitorAMD := load('glBeginPerfMonitorAMD');
  glEndPerfMonitorAMD := load('glEndPerfMonitorAMD');
  glGetPerfMonitorCounterDataAMD := load('glGetPerfMonitorCounterDataAMD');
end;

procedure load_GL_AMD_sample_positions(load: TLoadProc);
begin
  if not GLAD_GL_AMD_sample_positions then exit;
  glSetMultisamplefvAMD := load('glSetMultisamplefvAMD');
end;

procedure load_GL_AMD_sparse_texture(load: TLoadProc);
begin
  if not GLAD_GL_AMD_sparse_texture then exit;
  glTexStorageSparseAMD := load('glTexStorageSparseAMD');
  glTextureStorageSparseAMD := load('glTextureStorageSparseAMD');
end;

procedure load_GL_AMD_stencil_operation_extended(load: TLoadProc);
begin
  if not GLAD_GL_AMD_stencil_operation_extended then exit;
  glStencilOpValueAMD := load('glStencilOpValueAMD');
end;

procedure load_GL_AMD_vertex_shader_tessellator(load: TLoadProc);
begin
  if not GLAD_GL_AMD_vertex_shader_tessellator then exit;
  glTessellationFactorAMD := load('glTessellationFactorAMD');
  glTessellationModeAMD := load('glTessellationModeAMD');
end;

procedure load_GL_APPLE_element_array(load: TLoadProc);
begin
  if not GLAD_GL_APPLE_element_array then exit;
  glElementPointerAPPLE := load('glElementPointerAPPLE');
  glDrawElementArrayAPPLE := load('glDrawElementArrayAPPLE');
  glDrawRangeElementArrayAPPLE := load('glDrawRangeElementArrayAPPLE');
  glMultiDrawElementArrayAPPLE := load('glMultiDrawElementArrayAPPLE');
  glMultiDrawRangeElementArrayAPPLE := load('glMultiDrawRangeElementArrayAPPLE');
end;

procedure load_GL_APPLE_fence(load: TLoadProc);
begin
  if not GLAD_GL_APPLE_fence then exit;
  glGenFencesAPPLE := load('glGenFencesAPPLE');
  glDeleteFencesAPPLE := load('glDeleteFencesAPPLE');
  glSetFenceAPPLE := load('glSetFenceAPPLE');
  glIsFenceAPPLE := load('glIsFenceAPPLE');
  glTestFenceAPPLE := load('glTestFenceAPPLE');
  glFinishFenceAPPLE := load('glFinishFenceAPPLE');
  glTestObjectAPPLE := load('glTestObjectAPPLE');
  glFinishObjectAPPLE := load('glFinishObjectAPPLE');
end;

procedure load_GL_APPLE_flush_buffer_range(load: TLoadProc);
begin
  if not GLAD_GL_APPLE_flush_buffer_range then exit;
  glBufferParameteriAPPLE := load('glBufferParameteriAPPLE');
  glFlushMappedBufferRangeAPPLE := load('glFlushMappedBufferRangeAPPLE');
end;

procedure load_GL_APPLE_object_purgeable(load: TLoadProc);
begin
  if not GLAD_GL_APPLE_object_purgeable then exit;
  glObjectPurgeableAPPLE := load('glObjectPurgeableAPPLE');
  glObjectUnpurgeableAPPLE := load('glObjectUnpurgeableAPPLE');
  glGetObjectParameterivAPPLE := load('glGetObjectParameterivAPPLE');
end;

procedure load_GL_APPLE_texture_range(load: TLoadProc);
begin
  if not GLAD_GL_APPLE_texture_range then exit;
  glTextureRangeAPPLE := load('glTextureRangeAPPLE');
  glGetTexParameterPointervAPPLE := load('glGetTexParameterPointervAPPLE');
end;

procedure load_GL_APPLE_vertex_array_object(load: TLoadProc);
begin
  if not GLAD_GL_APPLE_vertex_array_object then exit;
  glBindVertexArrayAPPLE := load('glBindVertexArrayAPPLE');
  glDeleteVertexArraysAPPLE := load('glDeleteVertexArraysAPPLE');
  glGenVertexArraysAPPLE := load('glGenVertexArraysAPPLE');
  glIsVertexArrayAPPLE := load('glIsVertexArrayAPPLE');
end;

procedure load_GL_APPLE_vertex_array_range(load: TLoadProc);
begin
  if not GLAD_GL_APPLE_vertex_array_range then exit;
  glVertexArrayRangeAPPLE := load('glVertexArrayRangeAPPLE');
  glFlushVertexArrayRangeAPPLE := load('glFlushVertexArrayRangeAPPLE');
  glVertexArrayParameteriAPPLE := load('glVertexArrayParameteriAPPLE');
end;

procedure load_GL_APPLE_vertex_program_evaluators(load: TLoadProc);
begin
  if not GLAD_GL_APPLE_vertex_program_evaluators then exit;
  glEnableVertexAttribAPPLE := load('glEnableVertexAttribAPPLE');
  glDisableVertexAttribAPPLE := load('glDisableVertexAttribAPPLE');
  glIsVertexAttribEnabledAPPLE := load('glIsVertexAttribEnabledAPPLE');
  glMapVertexAttrib1dAPPLE := load('glMapVertexAttrib1dAPPLE');
  glMapVertexAttrib1fAPPLE := load('glMapVertexAttrib1fAPPLE');
  glMapVertexAttrib2dAPPLE := load('glMapVertexAttrib2dAPPLE');
  glMapVertexAttrib2fAPPLE := load('glMapVertexAttrib2fAPPLE');
end;

procedure load_GL_ARB_ES2_compatibility(load: TLoadProc);
begin
  if not GLAD_GL_ARB_ES2_compatibility then exit;
  glReleaseShaderCompiler := load('glReleaseShaderCompiler');
  glShaderBinary := load('glShaderBinary');
  glGetShaderPrecisionFormat := load('glGetShaderPrecisionFormat');
  glDepthRangef := load('glDepthRangef');
  glClearDepthf := load('glClearDepthf');
end;

procedure load_GL_ARB_ES3_1_compatibility(load: TLoadProc);
begin
  if not GLAD_GL_ARB_ES3_1_compatibility then exit;
  glMemoryBarrierByRegion := load('glMemoryBarrierByRegion');
end;

procedure load_GL_ARB_ES3_2_compatibility(load: TLoadProc);
begin
  if not GLAD_GL_ARB_ES3_2_compatibility then exit;
  glPrimitiveBoundingBoxARB := load('glPrimitiveBoundingBoxARB');
end;

procedure load_GL_ARB_base_instance(load: TLoadProc);
begin
  if not GLAD_GL_ARB_base_instance then exit;
  glDrawArraysInstancedBaseInstance := load('glDrawArraysInstancedBaseInstance');
  glDrawElementsInstancedBaseInstance := load('glDrawElementsInstancedBaseInstance');
  glDrawElementsInstancedBaseVertexBaseInstance := load('glDrawElementsInstancedBaseVertexBaseInstance');
end;

procedure load_GL_ARB_bindless_texture(load: TLoadProc);
begin
  if not GLAD_GL_ARB_bindless_texture then exit;
  glGetTextureHandleARB := load('glGetTextureHandleARB');
  glGetTextureSamplerHandleARB := load('glGetTextureSamplerHandleARB');
  glMakeTextureHandleResidentARB := load('glMakeTextureHandleResidentARB');
  glMakeTextureHandleNonResidentARB := load('glMakeTextureHandleNonResidentARB');
  glGetImageHandleARB := load('glGetImageHandleARB');
  glMakeImageHandleResidentARB := load('glMakeImageHandleResidentARB');
  glMakeImageHandleNonResidentARB := load('glMakeImageHandleNonResidentARB');
  glUniformHandleui64ARB := load('glUniformHandleui64ARB');
  glUniformHandleui64vARB := load('glUniformHandleui64vARB');
  glProgramUniformHandleui64ARB := load('glProgramUniformHandleui64ARB');
  glProgramUniformHandleui64vARB := load('glProgramUniformHandleui64vARB');
  glIsTextureHandleResidentARB := load('glIsTextureHandleResidentARB');
  glIsImageHandleResidentARB := load('glIsImageHandleResidentARB');
  glVertexAttribL1ui64ARB := load('glVertexAttribL1ui64ARB');
  glVertexAttribL1ui64vARB := load('glVertexAttribL1ui64vARB');
  glGetVertexAttribLui64vARB := load('glGetVertexAttribLui64vARB');
end;

procedure load_GL_ARB_blend_func_extended(load: TLoadProc);
begin
  if not GLAD_GL_ARB_blend_func_extended then exit;
  glBindFragDataLocationIndexed := load('glBindFragDataLocationIndexed');
  glGetFragDataIndex := load('glGetFragDataIndex');
end;

procedure load_GL_ARB_buffer_storage(load: TLoadProc);
begin
  if not GLAD_GL_ARB_buffer_storage then exit;
  glBufferStorage := load('glBufferStorage');
end;

procedure load_GL_ARB_cl_event(load: TLoadProc);
begin
  if not GLAD_GL_ARB_cl_event then exit;
  glCreateSyncFromCLeventARB := load('glCreateSyncFromCLeventARB');
end;

procedure load_GL_ARB_clear_buffer_object(load: TLoadProc);
begin
  if not GLAD_GL_ARB_clear_buffer_object then exit;
  glClearBufferData := load('glClearBufferData');
  glClearBufferSubData := load('glClearBufferSubData');
end;

procedure load_GL_ARB_clear_texture(load: TLoadProc);
begin
  if not GLAD_GL_ARB_clear_texture then exit;
  glClearTexImage := load('glClearTexImage');
  glClearTexSubImage := load('glClearTexSubImage');
end;

procedure load_GL_ARB_clip_control(load: TLoadProc);
begin
  if not GLAD_GL_ARB_clip_control then exit;
  glClipControl := load('glClipControl');
end;

procedure load_GL_ARB_color_buffer_float(load: TLoadProc);
begin
  if not GLAD_GL_ARB_color_buffer_float then exit;
  glClampColorARB := load('glClampColorARB');
end;

procedure load_GL_ARB_compute_shader(load: TLoadProc);
begin
  if not GLAD_GL_ARB_compute_shader then exit;
  glDispatchCompute := load('glDispatchCompute');
  glDispatchComputeIndirect := load('glDispatchComputeIndirect');
end;

procedure load_GL_ARB_compute_variable_group_size(load: TLoadProc);
begin
  if not GLAD_GL_ARB_compute_variable_group_size then exit;
  glDispatchComputeGroupSizeARB := load('glDispatchComputeGroupSizeARB');
end;

procedure load_GL_ARB_copy_buffer(load: TLoadProc);
begin
  if not GLAD_GL_ARB_copy_buffer then exit;
  glCopyBufferSubData := load('glCopyBufferSubData');
end;

procedure load_GL_ARB_copy_image(load: TLoadProc);
begin
  if not GLAD_GL_ARB_copy_image then exit;
  glCopyImageSubData := load('glCopyImageSubData');
end;

procedure load_GL_ARB_debug_output(load: TLoadProc);
begin
  if not GLAD_GL_ARB_debug_output then exit;
  glDebugMessageControlARB := load('glDebugMessageControlARB');
  glDebugMessageInsertARB := load('glDebugMessageInsertARB');
  glDebugMessageCallbackARB := load('glDebugMessageCallbackARB');
  glGetDebugMessageLogARB := load('glGetDebugMessageLogARB');
end;

procedure load_GL_ARB_direct_state_access(load: TLoadProc);
begin
  if not GLAD_GL_ARB_direct_state_access then exit;
  glCreateTransformFeedbacks := load('glCreateTransformFeedbacks');
  glTransformFeedbackBufferBase := load('glTransformFeedbackBufferBase');
  glTransformFeedbackBufferRange := load('glTransformFeedbackBufferRange');
  glGetTransformFeedbackiv := load('glGetTransformFeedbackiv');
  glGetTransformFeedbacki_v := load('glGetTransformFeedbacki_v');
  glGetTransformFeedbacki64_v := load('glGetTransformFeedbacki64_v');
  glCreateBuffers := load('glCreateBuffers');
  glNamedBufferStorage := load('glNamedBufferStorage');
  glNamedBufferData := load('glNamedBufferData');
  glNamedBufferSubData := load('glNamedBufferSubData');
  glCopyNamedBufferSubData := load('glCopyNamedBufferSubData');
  glClearNamedBufferData := load('glClearNamedBufferData');
  glClearNamedBufferSubData := load('glClearNamedBufferSubData');
  glMapNamedBuffer := load('glMapNamedBuffer');
  glMapNamedBufferRange := load('glMapNamedBufferRange');
  glUnmapNamedBuffer := load('glUnmapNamedBuffer');
  glFlushMappedNamedBufferRange := load('glFlushMappedNamedBufferRange');
  glGetNamedBufferParameteriv := load('glGetNamedBufferParameteriv');
  glGetNamedBufferParameteri64v := load('glGetNamedBufferParameteri64v');
  glGetNamedBufferPointerv := load('glGetNamedBufferPointerv');
  glGetNamedBufferSubData := load('glGetNamedBufferSubData');
  glCreateFramebuffers := load('glCreateFramebuffers');
  glNamedFramebufferRenderbuffer := load('glNamedFramebufferRenderbuffer');
  glNamedFramebufferParameteri := load('glNamedFramebufferParameteri');
  glNamedFramebufferTexture := load('glNamedFramebufferTexture');
  glNamedFramebufferTextureLayer := load('glNamedFramebufferTextureLayer');
  glNamedFramebufferDrawBuffer := load('glNamedFramebufferDrawBuffer');
  glNamedFramebufferDrawBuffers := load('glNamedFramebufferDrawBuffers');
  glNamedFramebufferReadBuffer := load('glNamedFramebufferReadBuffer');
  glInvalidateNamedFramebufferData := load('glInvalidateNamedFramebufferData');
  glInvalidateNamedFramebufferSubData := load('glInvalidateNamedFramebufferSubData');
  glClearNamedFramebufferiv := load('glClearNamedFramebufferiv');
  glClearNamedFramebufferuiv := load('glClearNamedFramebufferuiv');
  glClearNamedFramebufferfv := load('glClearNamedFramebufferfv');
  glClearNamedFramebufferfi := load('glClearNamedFramebufferfi');
  glBlitNamedFramebuffer := load('glBlitNamedFramebuffer');
  glCheckNamedFramebufferStatus := load('glCheckNamedFramebufferStatus');
  glGetNamedFramebufferParameteriv := load('glGetNamedFramebufferParameteriv');
  glGetNamedFramebufferAttachmentParameteriv := load('glGetNamedFramebufferAttachmentParameteriv');
  glCreateRenderbuffers := load('glCreateRenderbuffers');
  glNamedRenderbufferStorage := load('glNamedRenderbufferStorage');
  glNamedRenderbufferStorageMultisample := load('glNamedRenderbufferStorageMultisample');
  glGetNamedRenderbufferParameteriv := load('glGetNamedRenderbufferParameteriv');
  glCreateTextures := load('glCreateTextures');
  glTextureBuffer := load('glTextureBuffer');
  glTextureBufferRange := load('glTextureBufferRange');
  glTextureStorage1D := load('glTextureStorage1D');
  glTextureStorage2D := load('glTextureStorage2D');
  glTextureStorage3D := load('glTextureStorage3D');
  glTextureStorage2DMultisample := load('glTextureStorage2DMultisample');
  glTextureStorage3DMultisample := load('glTextureStorage3DMultisample');
  glTextureSubImage1D := load('glTextureSubImage1D');
  glTextureSubImage2D := load('glTextureSubImage2D');
  glTextureSubImage3D := load('glTextureSubImage3D');
  glCompressedTextureSubImage1D := load('glCompressedTextureSubImage1D');
  glCompressedTextureSubImage2D := load('glCompressedTextureSubImage2D');
  glCompressedTextureSubImage3D := load('glCompressedTextureSubImage3D');
  glCopyTextureSubImage1D := load('glCopyTextureSubImage1D');
  glCopyTextureSubImage2D := load('glCopyTextureSubImage2D');
  glCopyTextureSubImage3D := load('glCopyTextureSubImage3D');
  glTextureParameterf := load('glTextureParameterf');
  glTextureParameterfv := load('glTextureParameterfv');
  glTextureParameteri := load('glTextureParameteri');
  glTextureParameterIiv := load('glTextureParameterIiv');
  glTextureParameterIuiv := load('glTextureParameterIuiv');
  glTextureParameteriv := load('glTextureParameteriv');
  glGenerateTextureMipmap := load('glGenerateTextureMipmap');
  glBindTextureUnit := load('glBindTextureUnit');
  glGetTextureImage := load('glGetTextureImage');
  glGetCompressedTextureImage := load('glGetCompressedTextureImage');
  glGetTextureLevelParameterfv := load('glGetTextureLevelParameterfv');
  glGetTextureLevelParameteriv := load('glGetTextureLevelParameteriv');
  glGetTextureParameterfv := load('glGetTextureParameterfv');
  glGetTextureParameterIiv := load('glGetTextureParameterIiv');
  glGetTextureParameterIuiv := load('glGetTextureParameterIuiv');
  glGetTextureParameteriv := load('glGetTextureParameteriv');
  glCreateVertexArrays := load('glCreateVertexArrays');
  glDisableVertexArrayAttrib := load('glDisableVertexArrayAttrib');
  glEnableVertexArrayAttrib := load('glEnableVertexArrayAttrib');
  glVertexArrayElementBuffer := load('glVertexArrayElementBuffer');
  glVertexArrayVertexBuffer := load('glVertexArrayVertexBuffer');
  glVertexArrayVertexBuffers := load('glVertexArrayVertexBuffers');
  glVertexArrayAttribBinding := load('glVertexArrayAttribBinding');
  glVertexArrayAttribFormat := load('glVertexArrayAttribFormat');
  glVertexArrayAttribIFormat := load('glVertexArrayAttribIFormat');
  glVertexArrayAttribLFormat := load('glVertexArrayAttribLFormat');
  glVertexArrayBindingDivisor := load('glVertexArrayBindingDivisor');
  glGetVertexArrayiv := load('glGetVertexArrayiv');
  glGetVertexArrayIndexediv := load('glGetVertexArrayIndexediv');
  glGetVertexArrayIndexed64iv := load('glGetVertexArrayIndexed64iv');
  glCreateSamplers := load('glCreateSamplers');
  glCreateProgramPipelines := load('glCreateProgramPipelines');
  glCreateQueries := load('glCreateQueries');
  glGetQueryBufferObjecti64v := load('glGetQueryBufferObjecti64v');
  glGetQueryBufferObjectiv := load('glGetQueryBufferObjectiv');
  glGetQueryBufferObjectui64v := load('glGetQueryBufferObjectui64v');
  glGetQueryBufferObjectuiv := load('glGetQueryBufferObjectuiv');
end;

procedure load_GL_ARB_draw_buffers(load: TLoadProc);
begin
  if not GLAD_GL_ARB_draw_buffers then exit;
  glDrawBuffersARB := load('glDrawBuffersARB');
end;

procedure load_GL_ARB_draw_buffers_blend(load: TLoadProc);
begin
  if not GLAD_GL_ARB_draw_buffers_blend then exit;
  glBlendEquationiARB := load('glBlendEquationiARB');
  glBlendEquationSeparateiARB := load('glBlendEquationSeparateiARB');
  glBlendFunciARB := load('glBlendFunciARB');
  glBlendFuncSeparateiARB := load('glBlendFuncSeparateiARB');
end;

procedure load_GL_ARB_draw_elements_base_vertex(load: TLoadProc);
begin
  if not GLAD_GL_ARB_draw_elements_base_vertex then exit;
  glDrawElementsBaseVertex := load('glDrawElementsBaseVertex');
  glDrawRangeElementsBaseVertex := load('glDrawRangeElementsBaseVertex');
  glDrawElementsInstancedBaseVertex := load('glDrawElementsInstancedBaseVertex');
  glMultiDrawElementsBaseVertex := load('glMultiDrawElementsBaseVertex');
end;

procedure load_GL_ARB_draw_indirect(load: TLoadProc);
begin
  if not GLAD_GL_ARB_draw_indirect then exit;
  glDrawArraysIndirect := load('glDrawArraysIndirect');
  glDrawElementsIndirect := load('glDrawElementsIndirect');
end;

procedure load_GL_ARB_draw_instanced(load: TLoadProc);
begin
  if not GLAD_GL_ARB_draw_instanced then exit;
  glDrawArraysInstancedARB := load('glDrawArraysInstancedARB');
  glDrawElementsInstancedARB := load('glDrawElementsInstancedARB');
end;

procedure load_GL_ARB_fragment_program(load: TLoadProc);
begin
  if not GLAD_GL_ARB_fragment_program then exit;
  glProgramStringARB := load('glProgramStringARB');
  glBindProgramARB := load('glBindProgramARB');
  glDeleteProgramsARB := load('glDeleteProgramsARB');
  glGenProgramsARB := load('glGenProgramsARB');
  glProgramEnvParameter4dARB := load('glProgramEnvParameter4dARB');
  glProgramEnvParameter4dvARB := load('glProgramEnvParameter4dvARB');
  glProgramEnvParameter4fARB := load('glProgramEnvParameter4fARB');
  glProgramEnvParameter4fvARB := load('glProgramEnvParameter4fvARB');
  glProgramLocalParameter4dARB := load('glProgramLocalParameter4dARB');
  glProgramLocalParameter4dvARB := load('glProgramLocalParameter4dvARB');
  glProgramLocalParameter4fARB := load('glProgramLocalParameter4fARB');
  glProgramLocalParameter4fvARB := load('glProgramLocalParameter4fvARB');
  glGetProgramEnvParameterdvARB := load('glGetProgramEnvParameterdvARB');
  glGetProgramEnvParameterfvARB := load('glGetProgramEnvParameterfvARB');
  glGetProgramLocalParameterdvARB := load('glGetProgramLocalParameterdvARB');
  glGetProgramLocalParameterfvARB := load('glGetProgramLocalParameterfvARB');
  glGetProgramivARB := load('glGetProgramivARB');
  glGetProgramStringARB := load('glGetProgramStringARB');
  glIsProgramARB := load('glIsProgramARB');
end;

procedure load_GL_ARB_framebuffer_no_attachments(load: TLoadProc);
begin
  if not GLAD_GL_ARB_framebuffer_no_attachments then exit;
  glFramebufferParameteri := load('glFramebufferParameteri');
  glGetFramebufferParameteriv := load('glGetFramebufferParameteriv');
end;

procedure load_GL_ARB_framebuffer_object(load: TLoadProc);
begin
  if not GLAD_GL_ARB_framebuffer_object then exit;
  glIsRenderbuffer := load('glIsRenderbuffer');
  glBindRenderbuffer := load('glBindRenderbuffer');
  glDeleteRenderbuffers := load('glDeleteRenderbuffers');
  glGenRenderbuffers := load('glGenRenderbuffers');
  glRenderbufferStorage := load('glRenderbufferStorage');
  glGetRenderbufferParameteriv := load('glGetRenderbufferParameteriv');
  glIsFramebuffer := load('glIsFramebuffer');
  glBindFramebuffer := load('glBindFramebuffer');
  glDeleteFramebuffers := load('glDeleteFramebuffers');
  glGenFramebuffers := load('glGenFramebuffers');
  glCheckFramebufferStatus := load('glCheckFramebufferStatus');
  glFramebufferTexture1D := load('glFramebufferTexture1D');
  glFramebufferTexture2D := load('glFramebufferTexture2D');
  glFramebufferTexture3D := load('glFramebufferTexture3D');
  glFramebufferRenderbuffer := load('glFramebufferRenderbuffer');
  glGetFramebufferAttachmentParameteriv := load('glGetFramebufferAttachmentParameteriv');
  glGenerateMipmap := load('glGenerateMipmap');
  glBlitFramebuffer := load('glBlitFramebuffer');
  glRenderbufferStorageMultisample := load('glRenderbufferStorageMultisample');
  glFramebufferTextureLayer := load('glFramebufferTextureLayer');
end;

procedure load_GL_ARB_geometry_shader4(load: TLoadProc);
begin
  if not GLAD_GL_ARB_geometry_shader4 then exit;
  glProgramParameteriARB := load('glProgramParameteriARB');
  glFramebufferTextureARB := load('glFramebufferTextureARB');
  glFramebufferTextureLayerARB := load('glFramebufferTextureLayerARB');
  glFramebufferTextureFaceARB := load('glFramebufferTextureFaceARB');
end;

procedure load_GL_ARB_get_program_binary(load: TLoadProc);
begin
  if not GLAD_GL_ARB_get_program_binary then exit;
  glGetProgramBinary := load('glGetProgramBinary');
  glProgramBinary := load('glProgramBinary');
  glProgramParameteri := load('glProgramParameteri');
end;

procedure load_GL_ARB_get_texture_sub_image(load: TLoadProc);
begin
  if not GLAD_GL_ARB_get_texture_sub_image then exit;
  glGetTextureSubImage := load('glGetTextureSubImage');
  glGetCompressedTextureSubImage := load('glGetCompressedTextureSubImage');
end;

procedure load_GL_ARB_gl_spirv(load: TLoadProc);
begin
  if not GLAD_GL_ARB_gl_spirv then exit;
  glSpecializeShaderARB := load('glSpecializeShaderARB');
end;

procedure load_GL_ARB_gpu_shader_fp64(load: TLoadProc);
begin
  if not GLAD_GL_ARB_gpu_shader_fp64 then exit;
  glUniform1d := load('glUniform1d');
  glUniform2d := load('glUniform2d');
  glUniform3d := load('glUniform3d');
  glUniform4d := load('glUniform4d');
  glUniform1dv := load('glUniform1dv');
  glUniform2dv := load('glUniform2dv');
  glUniform3dv := load('glUniform3dv');
  glUniform4dv := load('glUniform4dv');
  glUniformMatrix2dv := load('glUniformMatrix2dv');
  glUniformMatrix3dv := load('glUniformMatrix3dv');
  glUniformMatrix4dv := load('glUniformMatrix4dv');
  glUniformMatrix2x3dv := load('glUniformMatrix2x3dv');
  glUniformMatrix2x4dv := load('glUniformMatrix2x4dv');
  glUniformMatrix3x2dv := load('glUniformMatrix3x2dv');
  glUniformMatrix3x4dv := load('glUniformMatrix3x4dv');
  glUniformMatrix4x2dv := load('glUniformMatrix4x2dv');
  glUniformMatrix4x3dv := load('glUniformMatrix4x3dv');
  glGetUniformdv := load('glGetUniformdv');
end;

procedure load_GL_ARB_gpu_shader_int64(load: TLoadProc);
begin
  if not GLAD_GL_ARB_gpu_shader_int64 then exit;
  glUniform1i64ARB := load('glUniform1i64ARB');
  glUniform2i64ARB := load('glUniform2i64ARB');
  glUniform3i64ARB := load('glUniform3i64ARB');
  glUniform4i64ARB := load('glUniform4i64ARB');
  glUniform1i64vARB := load('glUniform1i64vARB');
  glUniform2i64vARB := load('glUniform2i64vARB');
  glUniform3i64vARB := load('glUniform3i64vARB');
  glUniform4i64vARB := load('glUniform4i64vARB');
  glUniform1ui64ARB := load('glUniform1ui64ARB');
  glUniform2ui64ARB := load('glUniform2ui64ARB');
  glUniform3ui64ARB := load('glUniform3ui64ARB');
  glUniform4ui64ARB := load('glUniform4ui64ARB');
  glUniform1ui64vARB := load('glUniform1ui64vARB');
  glUniform2ui64vARB := load('glUniform2ui64vARB');
  glUniform3ui64vARB := load('glUniform3ui64vARB');
  glUniform4ui64vARB := load('glUniform4ui64vARB');
  glGetUniformi64vARB := load('glGetUniformi64vARB');
  glGetUniformui64vARB := load('glGetUniformui64vARB');
  glGetnUniformi64vARB := load('glGetnUniformi64vARB');
  glGetnUniformui64vARB := load('glGetnUniformui64vARB');
  glProgramUniform1i64ARB := load('glProgramUniform1i64ARB');
  glProgramUniform2i64ARB := load('glProgramUniform2i64ARB');
  glProgramUniform3i64ARB := load('glProgramUniform3i64ARB');
  glProgramUniform4i64ARB := load('glProgramUniform4i64ARB');
  glProgramUniform1i64vARB := load('glProgramUniform1i64vARB');
  glProgramUniform2i64vARB := load('glProgramUniform2i64vARB');
  glProgramUniform3i64vARB := load('glProgramUniform3i64vARB');
  glProgramUniform4i64vARB := load('glProgramUniform4i64vARB');
  glProgramUniform1ui64ARB := load('glProgramUniform1ui64ARB');
  glProgramUniform2ui64ARB := load('glProgramUniform2ui64ARB');
  glProgramUniform3ui64ARB := load('glProgramUniform3ui64ARB');
  glProgramUniform4ui64ARB := load('glProgramUniform4ui64ARB');
  glProgramUniform1ui64vARB := load('glProgramUniform1ui64vARB');
  glProgramUniform2ui64vARB := load('glProgramUniform2ui64vARB');
  glProgramUniform3ui64vARB := load('glProgramUniform3ui64vARB');
  glProgramUniform4ui64vARB := load('glProgramUniform4ui64vARB');
end;

procedure load_GL_ARB_imaging(load: TLoadProc);
begin
  if not GLAD_GL_ARB_imaging then exit;
  glBlendColor := load('glBlendColor');
  glBlendEquation := load('glBlendEquation');
  glColorTable := load('glColorTable');
  glColorTableParameterfv := load('glColorTableParameterfv');
  glColorTableParameteriv := load('glColorTableParameteriv');
  glCopyColorTable := load('glCopyColorTable');
  glGetColorTable := load('glGetColorTable');
  glGetColorTableParameterfv := load('glGetColorTableParameterfv');
  glGetColorTableParameteriv := load('glGetColorTableParameteriv');
  glColorSubTable := load('glColorSubTable');
  glCopyColorSubTable := load('glCopyColorSubTable');
  glConvolutionFilter1D := load('glConvolutionFilter1D');
  glConvolutionFilter2D := load('glConvolutionFilter2D');
  glConvolutionParameterf := load('glConvolutionParameterf');
  glConvolutionParameterfv := load('glConvolutionParameterfv');
  glConvolutionParameteri := load('glConvolutionParameteri');
  glConvolutionParameteriv := load('glConvolutionParameteriv');
  glCopyConvolutionFilter1D := load('glCopyConvolutionFilter1D');
  glCopyConvolutionFilter2D := load('glCopyConvolutionFilter2D');
  glGetConvolutionFilter := load('glGetConvolutionFilter');
  glGetConvolutionParameterfv := load('glGetConvolutionParameterfv');
  glGetConvolutionParameteriv := load('glGetConvolutionParameteriv');
  glGetSeparableFilter := load('glGetSeparableFilter');
  glSeparableFilter2D := load('glSeparableFilter2D');
  glGetHistogram := load('glGetHistogram');
  glGetHistogramParameterfv := load('glGetHistogramParameterfv');
  glGetHistogramParameteriv := load('glGetHistogramParameteriv');
  glGetMinmax := load('glGetMinmax');
  glGetMinmaxParameterfv := load('glGetMinmaxParameterfv');
  glGetMinmaxParameteriv := load('glGetMinmaxParameteriv');
  glHistogram := load('glHistogram');
  glMinmax := load('glMinmax');
  glResetHistogram := load('glResetHistogram');
  glResetMinmax := load('glResetMinmax');
end;

procedure load_GL_ARB_indirect_parameters(load: TLoadProc);
begin
  if not GLAD_GL_ARB_indirect_parameters then exit;
  glMultiDrawArraysIndirectCountARB := load('glMultiDrawArraysIndirectCountARB');
  glMultiDrawElementsIndirectCountARB := load('glMultiDrawElementsIndirectCountARB');
end;

procedure load_GL_ARB_instanced_arrays(load: TLoadProc);
begin
  if not GLAD_GL_ARB_instanced_arrays then exit;
  glVertexAttribDivisorARB := load('glVertexAttribDivisorARB');
end;

procedure load_GL_ARB_internalformat_query(load: TLoadProc);
begin
  if not GLAD_GL_ARB_internalformat_query then exit;
  glGetInternalformativ := load('glGetInternalformativ');
end;

procedure load_GL_ARB_internalformat_query2(load: TLoadProc);
begin
  if not GLAD_GL_ARB_internalformat_query2 then exit;
  glGetInternalformati64v := load('glGetInternalformati64v');
end;

procedure load_GL_ARB_invalidate_subdata(load: TLoadProc);
begin
  if not GLAD_GL_ARB_invalidate_subdata then exit;
  glInvalidateTexSubImage := load('glInvalidateTexSubImage');
  glInvalidateTexImage := load('glInvalidateTexImage');
  glInvalidateBufferSubData := load('glInvalidateBufferSubData');
  glInvalidateBufferData := load('glInvalidateBufferData');
  glInvalidateFramebuffer := load('glInvalidateFramebuffer');
  glInvalidateSubFramebuffer := load('glInvalidateSubFramebuffer');
end;

procedure load_GL_ARB_map_buffer_range(load: TLoadProc);
begin
  if not GLAD_GL_ARB_map_buffer_range then exit;
  glMapBufferRange := load('glMapBufferRange');
  glFlushMappedBufferRange := load('glFlushMappedBufferRange');
end;

procedure load_GL_ARB_matrix_palette(load: TLoadProc);
begin
  if not GLAD_GL_ARB_matrix_palette then exit;
  glCurrentPaletteMatrixARB := load('glCurrentPaletteMatrixARB');
  glMatrixIndexubvARB := load('glMatrixIndexubvARB');
  glMatrixIndexusvARB := load('glMatrixIndexusvARB');
  glMatrixIndexuivARB := load('glMatrixIndexuivARB');
  glMatrixIndexPointerARB := load('glMatrixIndexPointerARB');
end;

procedure load_GL_ARB_multi_bind(load: TLoadProc);
begin
  if not GLAD_GL_ARB_multi_bind then exit;
  glBindBuffersBase := load('glBindBuffersBase');
  glBindBuffersRange := load('glBindBuffersRange');
  glBindTextures := load('glBindTextures');
  glBindSamplers := load('glBindSamplers');
  glBindImageTextures := load('glBindImageTextures');
  glBindVertexBuffers := load('glBindVertexBuffers');
end;

procedure load_GL_ARB_multi_draw_indirect(load: TLoadProc);
begin
  if not GLAD_GL_ARB_multi_draw_indirect then exit;
  glMultiDrawArraysIndirect := load('glMultiDrawArraysIndirect');
  glMultiDrawElementsIndirect := load('glMultiDrawElementsIndirect');
end;

procedure load_GL_ARB_multisample(load: TLoadProc);
begin
  if not GLAD_GL_ARB_multisample then exit;
  glSampleCoverageARB := load('glSampleCoverageARB');
end;

procedure load_GL_ARB_multitexture(load: TLoadProc);
begin
  if not GLAD_GL_ARB_multitexture then exit;
  glActiveTextureARB := load('glActiveTextureARB');
  glClientActiveTextureARB := load('glClientActiveTextureARB');
  glMultiTexCoord1dARB := load('glMultiTexCoord1dARB');
  glMultiTexCoord1dvARB := load('glMultiTexCoord1dvARB');
  glMultiTexCoord1fARB := load('glMultiTexCoord1fARB');
  glMultiTexCoord1fvARB := load('glMultiTexCoord1fvARB');
  glMultiTexCoord1iARB := load('glMultiTexCoord1iARB');
  glMultiTexCoord1ivARB := load('glMultiTexCoord1ivARB');
  glMultiTexCoord1sARB := load('glMultiTexCoord1sARB');
  glMultiTexCoord1svARB := load('glMultiTexCoord1svARB');
  glMultiTexCoord2dARB := load('glMultiTexCoord2dARB');
  glMultiTexCoord2dvARB := load('glMultiTexCoord2dvARB');
  glMultiTexCoord2fARB := load('glMultiTexCoord2fARB');
  glMultiTexCoord2fvARB := load('glMultiTexCoord2fvARB');
  glMultiTexCoord2iARB := load('glMultiTexCoord2iARB');
  glMultiTexCoord2ivARB := load('glMultiTexCoord2ivARB');
  glMultiTexCoord2sARB := load('glMultiTexCoord2sARB');
  glMultiTexCoord2svARB := load('glMultiTexCoord2svARB');
  glMultiTexCoord3dARB := load('glMultiTexCoord3dARB');
  glMultiTexCoord3dvARB := load('glMultiTexCoord3dvARB');
  glMultiTexCoord3fARB := load('glMultiTexCoord3fARB');
  glMultiTexCoord3fvARB := load('glMultiTexCoord3fvARB');
  glMultiTexCoord3iARB := load('glMultiTexCoord3iARB');
  glMultiTexCoord3ivARB := load('glMultiTexCoord3ivARB');
  glMultiTexCoord3sARB := load('glMultiTexCoord3sARB');
  glMultiTexCoord3svARB := load('glMultiTexCoord3svARB');
  glMultiTexCoord4dARB := load('glMultiTexCoord4dARB');
  glMultiTexCoord4dvARB := load('glMultiTexCoord4dvARB');
  glMultiTexCoord4fARB := load('glMultiTexCoord4fARB');
  glMultiTexCoord4fvARB := load('glMultiTexCoord4fvARB');
  glMultiTexCoord4iARB := load('glMultiTexCoord4iARB');
  glMultiTexCoord4ivARB := load('glMultiTexCoord4ivARB');
  glMultiTexCoord4sARB := load('glMultiTexCoord4sARB');
  glMultiTexCoord4svARB := load('glMultiTexCoord4svARB');
end;

procedure load_GL_ARB_occlusion_query(load: TLoadProc);
begin
  if not GLAD_GL_ARB_occlusion_query then exit;
  glGenQueriesARB := load('glGenQueriesARB');
  glDeleteQueriesARB := load('glDeleteQueriesARB');
  glIsQueryARB := load('glIsQueryARB');
  glBeginQueryARB := load('glBeginQueryARB');
  glEndQueryARB := load('glEndQueryARB');
  glGetQueryivARB := load('glGetQueryivARB');
  glGetQueryObjectivARB := load('glGetQueryObjectivARB');
  glGetQueryObjectuivARB := load('glGetQueryObjectuivARB');
end;

procedure load_GL_ARB_parallel_shader_compile(load: TLoadProc);
begin
  if not GLAD_GL_ARB_parallel_shader_compile then exit;
  glMaxShaderCompilerThreadsARB := load('glMaxShaderCompilerThreadsARB');
end;

procedure load_GL_ARB_point_parameters(load: TLoadProc);
begin
  if not GLAD_GL_ARB_point_parameters then exit;
  glPointParameterfARB := load('glPointParameterfARB');
  glPointParameterfvARB := load('glPointParameterfvARB');
end;

procedure load_GL_ARB_polygon_offset_clamp(load: TLoadProc);
begin
  if not GLAD_GL_ARB_polygon_offset_clamp then exit;
  glPolygonOffsetClamp := load('glPolygonOffsetClamp');
end;

procedure load_GL_ARB_program_interface_query(load: TLoadProc);
begin
  if not GLAD_GL_ARB_program_interface_query then exit;
  glGetProgramInterfaceiv := load('glGetProgramInterfaceiv');
  glGetProgramResourceIndex := load('glGetProgramResourceIndex');
  glGetProgramResourceName := load('glGetProgramResourceName');
  glGetProgramResourceiv := load('glGetProgramResourceiv');
  glGetProgramResourceLocation := load('glGetProgramResourceLocation');
  glGetProgramResourceLocationIndex := load('glGetProgramResourceLocationIndex');
end;

procedure load_GL_ARB_provoking_vertex(load: TLoadProc);
begin
  if not GLAD_GL_ARB_provoking_vertex then exit;
  glProvokingVertex := load('glProvokingVertex');
end;

procedure load_GL_ARB_robustness(load: TLoadProc);
begin
  if not GLAD_GL_ARB_robustness then exit;
  glGetGraphicsResetStatusARB := load('glGetGraphicsResetStatusARB');
  glGetnTexImageARB := load('glGetnTexImageARB');
  glReadnPixelsARB := load('glReadnPixelsARB');
  glGetnCompressedTexImageARB := load('glGetnCompressedTexImageARB');
  glGetnUniformfvARB := load('glGetnUniformfvARB');
  glGetnUniformivARB := load('glGetnUniformivARB');
  glGetnUniformuivARB := load('glGetnUniformuivARB');
  glGetnUniformdvARB := load('glGetnUniformdvARB');
  glGetnMapdvARB := load('glGetnMapdvARB');
  glGetnMapfvARB := load('glGetnMapfvARB');
  glGetnMapivARB := load('glGetnMapivARB');
  glGetnPixelMapfvARB := load('glGetnPixelMapfvARB');
  glGetnPixelMapuivARB := load('glGetnPixelMapuivARB');
  glGetnPixelMapusvARB := load('glGetnPixelMapusvARB');
  glGetnPolygonStippleARB := load('glGetnPolygonStippleARB');
  glGetnColorTableARB := load('glGetnColorTableARB');
  glGetnConvolutionFilterARB := load('glGetnConvolutionFilterARB');
  glGetnSeparableFilterARB := load('glGetnSeparableFilterARB');
  glGetnHistogramARB := load('glGetnHistogramARB');
  glGetnMinmaxARB := load('glGetnMinmaxARB');
end;

procedure load_GL_ARB_sample_locations(load: TLoadProc);
begin
  if not GLAD_GL_ARB_sample_locations then exit;
  glFramebufferSampleLocationsfvARB := load('glFramebufferSampleLocationsfvARB');
  glNamedFramebufferSampleLocationsfvARB := load('glNamedFramebufferSampleLocationsfvARB');
  glEvaluateDepthValuesARB := load('glEvaluateDepthValuesARB');
end;

procedure load_GL_ARB_sample_shading(load: TLoadProc);
begin
  if not GLAD_GL_ARB_sample_shading then exit;
  glMinSampleShadingARB := load('glMinSampleShadingARB');
end;

procedure load_GL_ARB_sampler_objects(load: TLoadProc);
begin
  if not GLAD_GL_ARB_sampler_objects then exit;
  glGenSamplers := load('glGenSamplers');
  glDeleteSamplers := load('glDeleteSamplers');
  glIsSampler := load('glIsSampler');
  glBindSampler := load('glBindSampler');
  glSamplerParameteri := load('glSamplerParameteri');
  glSamplerParameteriv := load('glSamplerParameteriv');
  glSamplerParameterf := load('glSamplerParameterf');
  glSamplerParameterfv := load('glSamplerParameterfv');
  glSamplerParameterIiv := load('glSamplerParameterIiv');
  glSamplerParameterIuiv := load('glSamplerParameterIuiv');
  glGetSamplerParameteriv := load('glGetSamplerParameteriv');
  glGetSamplerParameterIiv := load('glGetSamplerParameterIiv');
  glGetSamplerParameterfv := load('glGetSamplerParameterfv');
  glGetSamplerParameterIuiv := load('glGetSamplerParameterIuiv');
end;

procedure load_GL_ARB_separate_shader_objects(load: TLoadProc);
begin
  if not GLAD_GL_ARB_separate_shader_objects then exit;
  glUseProgramStages := load('glUseProgramStages');
  glActiveShaderProgram := load('glActiveShaderProgram');
  glCreateShaderProgramv := load('glCreateShaderProgramv');
  glBindProgramPipeline := load('glBindProgramPipeline');
  glDeleteProgramPipelines := load('glDeleteProgramPipelines');
  glGenProgramPipelines := load('glGenProgramPipelines');
  glIsProgramPipeline := load('glIsProgramPipeline');
  glGetProgramPipelineiv := load('glGetProgramPipelineiv');
  glProgramParameteri := load('glProgramParameteri');
  glProgramUniform1i := load('glProgramUniform1i');
  glProgramUniform1iv := load('glProgramUniform1iv');
  glProgramUniform1f := load('glProgramUniform1f');
  glProgramUniform1fv := load('glProgramUniform1fv');
  glProgramUniform1d := load('glProgramUniform1d');
  glProgramUniform1dv := load('glProgramUniform1dv');
  glProgramUniform1ui := load('glProgramUniform1ui');
  glProgramUniform1uiv := load('glProgramUniform1uiv');
  glProgramUniform2i := load('glProgramUniform2i');
  glProgramUniform2iv := load('glProgramUniform2iv');
  glProgramUniform2f := load('glProgramUniform2f');
  glProgramUniform2fv := load('glProgramUniform2fv');
  glProgramUniform2d := load('glProgramUniform2d');
  glProgramUniform2dv := load('glProgramUniform2dv');
  glProgramUniform2ui := load('glProgramUniform2ui');
  glProgramUniform2uiv := load('glProgramUniform2uiv');
  glProgramUniform3i := load('glProgramUniform3i');
  glProgramUniform3iv := load('glProgramUniform3iv');
  glProgramUniform3f := load('glProgramUniform3f');
  glProgramUniform3fv := load('glProgramUniform3fv');
  glProgramUniform3d := load('glProgramUniform3d');
  glProgramUniform3dv := load('glProgramUniform3dv');
  glProgramUniform3ui := load('glProgramUniform3ui');
  glProgramUniform3uiv := load('glProgramUniform3uiv');
  glProgramUniform4i := load('glProgramUniform4i');
  glProgramUniform4iv := load('glProgramUniform4iv');
  glProgramUniform4f := load('glProgramUniform4f');
  glProgramUniform4fv := load('glProgramUniform4fv');
  glProgramUniform4d := load('glProgramUniform4d');
  glProgramUniform4dv := load('glProgramUniform4dv');
  glProgramUniform4ui := load('glProgramUniform4ui');
  glProgramUniform4uiv := load('glProgramUniform4uiv');
  glProgramUniformMatrix2fv := load('glProgramUniformMatrix2fv');
  glProgramUniformMatrix3fv := load('glProgramUniformMatrix3fv');
  glProgramUniformMatrix4fv := load('glProgramUniformMatrix4fv');
  glProgramUniformMatrix2dv := load('glProgramUniformMatrix2dv');
  glProgramUniformMatrix3dv := load('glProgramUniformMatrix3dv');
  glProgramUniformMatrix4dv := load('glProgramUniformMatrix4dv');
  glProgramUniformMatrix2x3fv := load('glProgramUniformMatrix2x3fv');
  glProgramUniformMatrix3x2fv := load('glProgramUniformMatrix3x2fv');
  glProgramUniformMatrix2x4fv := load('glProgramUniformMatrix2x4fv');
  glProgramUniformMatrix4x2fv := load('glProgramUniformMatrix4x2fv');
  glProgramUniformMatrix3x4fv := load('glProgramUniformMatrix3x4fv');
  glProgramUniformMatrix4x3fv := load('glProgramUniformMatrix4x3fv');
  glProgramUniformMatrix2x3dv := load('glProgramUniformMatrix2x3dv');
  glProgramUniformMatrix3x2dv := load('glProgramUniformMatrix3x2dv');
  glProgramUniformMatrix2x4dv := load('glProgramUniformMatrix2x4dv');
  glProgramUniformMatrix4x2dv := load('glProgramUniformMatrix4x2dv');
  glProgramUniformMatrix3x4dv := load('glProgramUniformMatrix3x4dv');
  glProgramUniformMatrix4x3dv := load('glProgramUniformMatrix4x3dv');
  glValidateProgramPipeline := load('glValidateProgramPipeline');
  glGetProgramPipelineInfoLog := load('glGetProgramPipelineInfoLog');
end;

procedure load_GL_ARB_shader_atomic_counters(load: TLoadProc);
begin
  if not GLAD_GL_ARB_shader_atomic_counters then exit;
  glGetActiveAtomicCounterBufferiv := load('glGetActiveAtomicCounterBufferiv');
end;

procedure load_GL_ARB_shader_image_load_store(load: TLoadProc);
begin
  if not GLAD_GL_ARB_shader_image_load_store then exit;
  glBindImageTexture := load('glBindImageTexture');
  glMemoryBarrier := load('glMemoryBarrier');
end;

procedure load_GL_ARB_shader_objects(load: TLoadProc);
begin
  if not GLAD_GL_ARB_shader_objects then exit;
  glDeleteObjectARB := load('glDeleteObjectARB');
  glGetHandleARB := load('glGetHandleARB');
  glDetachObjectARB := load('glDetachObjectARB');
  glCreateShaderObjectARB := load('glCreateShaderObjectARB');
  glShaderSourceARB := load('glShaderSourceARB');
  glCompileShaderARB := load('glCompileShaderARB');
  glCreateProgramObjectARB := load('glCreateProgramObjectARB');
  glAttachObjectARB := load('glAttachObjectARB');
  glLinkProgramARB := load('glLinkProgramARB');
  glUseProgramObjectARB := load('glUseProgramObjectARB');
  glValidateProgramARB := load('glValidateProgramARB');
  glUniform1fARB := load('glUniform1fARB');
  glUniform2fARB := load('glUniform2fARB');
  glUniform3fARB := load('glUniform3fARB');
  glUniform4fARB := load('glUniform4fARB');
  glUniform1iARB := load('glUniform1iARB');
  glUniform2iARB := load('glUniform2iARB');
  glUniform3iARB := load('glUniform3iARB');
  glUniform4iARB := load('glUniform4iARB');
  glUniform1fvARB := load('glUniform1fvARB');
  glUniform2fvARB := load('glUniform2fvARB');
  glUniform3fvARB := load('glUniform3fvARB');
  glUniform4fvARB := load('glUniform4fvARB');
  glUniform1ivARB := load('glUniform1ivARB');
  glUniform2ivARB := load('glUniform2ivARB');
  glUniform3ivARB := load('glUniform3ivARB');
  glUniform4ivARB := load('glUniform4ivARB');
  glUniformMatrix2fvARB := load('glUniformMatrix2fvARB');
  glUniformMatrix3fvARB := load('glUniformMatrix3fvARB');
  glUniformMatrix4fvARB := load('glUniformMatrix4fvARB');
  glGetObjectParameterfvARB := load('glGetObjectParameterfvARB');
  glGetObjectParameterivARB := load('glGetObjectParameterivARB');
  glGetInfoLogARB := load('glGetInfoLogARB');
  glGetAttachedObjectsARB := load('glGetAttachedObjectsARB');
  glGetUniformLocationARB := load('glGetUniformLocationARB');
  glGetActiveUniformARB := load('glGetActiveUniformARB');
  glGetUniformfvARB := load('glGetUniformfvARB');
  glGetUniformivARB := load('glGetUniformivARB');
  glGetShaderSourceARB := load('glGetShaderSourceARB');
end;

procedure load_GL_ARB_shader_storage_buffer_object(load: TLoadProc);
begin
  if not GLAD_GL_ARB_shader_storage_buffer_object then exit;
  glShaderStorageBlockBinding := load('glShaderStorageBlockBinding');
end;

procedure load_GL_ARB_shader_subroutine(load: TLoadProc);
begin
  if not GLAD_GL_ARB_shader_subroutine then exit;
  glGetSubroutineUniformLocation := load('glGetSubroutineUniformLocation');
  glGetSubroutineIndex := load('glGetSubroutineIndex');
  glGetActiveSubroutineUniformiv := load('glGetActiveSubroutineUniformiv');
  glGetActiveSubroutineUniformName := load('glGetActiveSubroutineUniformName');
  glGetActiveSubroutineName := load('glGetActiveSubroutineName');
  glUniformSubroutinesuiv := load('glUniformSubroutinesuiv');
  glGetUniformSubroutineuiv := load('glGetUniformSubroutineuiv');
  glGetProgramStageiv := load('glGetProgramStageiv');
end;

procedure load_GL_ARB_shading_language_include(load: TLoadProc);
begin
  if not GLAD_GL_ARB_shading_language_include then exit;
  glNamedStringARB := load('glNamedStringARB');
  glDeleteNamedStringARB := load('glDeleteNamedStringARB');
  glCompileShaderIncludeARB := load('glCompileShaderIncludeARB');
  glIsNamedStringARB := load('glIsNamedStringARB');
  glGetNamedStringARB := load('glGetNamedStringARB');
  glGetNamedStringivARB := load('glGetNamedStringivARB');
end;

procedure load_GL_ARB_sparse_buffer(load: TLoadProc);
begin
  if not GLAD_GL_ARB_sparse_buffer then exit;
  glBufferPageCommitmentARB := load('glBufferPageCommitmentARB');
  glNamedBufferPageCommitmentEXT := load('glNamedBufferPageCommitmentEXT');
  glNamedBufferPageCommitmentARB := load('glNamedBufferPageCommitmentARB');
end;

procedure load_GL_ARB_sparse_texture(load: TLoadProc);
begin
  if not GLAD_GL_ARB_sparse_texture then exit;
  glTexPageCommitmentARB := load('glTexPageCommitmentARB');
end;

procedure load_GL_ARB_sync(load: TLoadProc);
begin
  if not GLAD_GL_ARB_sync then exit;
  glFenceSync := load('glFenceSync');
  glIsSync := load('glIsSync');
  glDeleteSync := load('glDeleteSync');
  glClientWaitSync := load('glClientWaitSync');
  glWaitSync := load('glWaitSync');
  glGetInteger64v := load('glGetInteger64v');
  glGetSynciv := load('glGetSynciv');
end;

procedure load_GL_ARB_tessellation_shader(load: TLoadProc);
begin
  if not GLAD_GL_ARB_tessellation_shader then exit;
  glPatchParameteri := load('glPatchParameteri');
  glPatchParameterfv := load('glPatchParameterfv');
end;

procedure load_GL_ARB_texture_barrier(load: TLoadProc);
begin
  if not GLAD_GL_ARB_texture_barrier then exit;
  glTextureBarrier := load('glTextureBarrier');
end;

procedure load_GL_ARB_texture_buffer_object(load: TLoadProc);
begin
  if not GLAD_GL_ARB_texture_buffer_object then exit;
  glTexBufferARB := load('glTexBufferARB');
end;

procedure load_GL_ARB_texture_buffer_range(load: TLoadProc);
begin
  if not GLAD_GL_ARB_texture_buffer_range then exit;
  glTexBufferRange := load('glTexBufferRange');
end;

procedure load_GL_ARB_texture_compression(load: TLoadProc);
begin
  if not GLAD_GL_ARB_texture_compression then exit;
  glCompressedTexImage3DARB := load('glCompressedTexImage3DARB');
  glCompressedTexImage2DARB := load('glCompressedTexImage2DARB');
  glCompressedTexImage1DARB := load('glCompressedTexImage1DARB');
  glCompressedTexSubImage3DARB := load('glCompressedTexSubImage3DARB');
  glCompressedTexSubImage2DARB := load('glCompressedTexSubImage2DARB');
  glCompressedTexSubImage1DARB := load('glCompressedTexSubImage1DARB');
  glGetCompressedTexImageARB := load('glGetCompressedTexImageARB');
end;

procedure load_GL_ARB_texture_multisample(load: TLoadProc);
begin
  if not GLAD_GL_ARB_texture_multisample then exit;
  glTexImage2DMultisample := load('glTexImage2DMultisample');
  glTexImage3DMultisample := load('glTexImage3DMultisample');
  glGetMultisamplefv := load('glGetMultisamplefv');
  glSampleMaski := load('glSampleMaski');
end;

procedure load_GL_ARB_texture_storage(load: TLoadProc);
begin
  if not GLAD_GL_ARB_texture_storage then exit;
  glTexStorage1D := load('glTexStorage1D');
  glTexStorage2D := load('glTexStorage2D');
  glTexStorage3D := load('glTexStorage3D');
end;

procedure load_GL_ARB_texture_storage_multisample(load: TLoadProc);
begin
  if not GLAD_GL_ARB_texture_storage_multisample then exit;
  glTexStorage2DMultisample := load('glTexStorage2DMultisample');
  glTexStorage3DMultisample := load('glTexStorage3DMultisample');
end;

procedure load_GL_ARB_texture_view(load: TLoadProc);
begin
  if not GLAD_GL_ARB_texture_view then exit;
  glTextureView := load('glTextureView');
end;

procedure load_GL_ARB_timer_query(load: TLoadProc);
begin
  if not GLAD_GL_ARB_timer_query then exit;
  glQueryCounter := load('glQueryCounter');
  glGetQueryObjecti64v := load('glGetQueryObjecti64v');
  glGetQueryObjectui64v := load('glGetQueryObjectui64v');
end;

procedure load_GL_ARB_transform_feedback2(load: TLoadProc);
begin
  if not GLAD_GL_ARB_transform_feedback2 then exit;
  glBindTransformFeedback := load('glBindTransformFeedback');
  glDeleteTransformFeedbacks := load('glDeleteTransformFeedbacks');
  glGenTransformFeedbacks := load('glGenTransformFeedbacks');
  glIsTransformFeedback := load('glIsTransformFeedback');
  glPauseTransformFeedback := load('glPauseTransformFeedback');
  glResumeTransformFeedback := load('glResumeTransformFeedback');
  glDrawTransformFeedback := load('glDrawTransformFeedback');
end;

procedure load_GL_ARB_transform_feedback3(load: TLoadProc);
begin
  if not GLAD_GL_ARB_transform_feedback3 then exit;
  glDrawTransformFeedbackStream := load('glDrawTransformFeedbackStream');
  glBeginQueryIndexed := load('glBeginQueryIndexed');
  glEndQueryIndexed := load('glEndQueryIndexed');
  glGetQueryIndexediv := load('glGetQueryIndexediv');
end;

procedure load_GL_ARB_transform_feedback_instanced(load: TLoadProc);
begin
  if not GLAD_GL_ARB_transform_feedback_instanced then exit;
  glDrawTransformFeedbackInstanced := load('glDrawTransformFeedbackInstanced');
  glDrawTransformFeedbackStreamInstanced := load('glDrawTransformFeedbackStreamInstanced');
end;

procedure load_GL_ARB_transpose_matrix(load: TLoadProc);
begin
  if not GLAD_GL_ARB_transpose_matrix then exit;
  glLoadTransposeMatrixfARB := load('glLoadTransposeMatrixfARB');
  glLoadTransposeMatrixdARB := load('glLoadTransposeMatrixdARB');
  glMultTransposeMatrixfARB := load('glMultTransposeMatrixfARB');
  glMultTransposeMatrixdARB := load('glMultTransposeMatrixdARB');
end;

procedure load_GL_ARB_uniform_buffer_object(load: TLoadProc);
begin
  if not GLAD_GL_ARB_uniform_buffer_object then exit;
  glGetUniformIndices := load('glGetUniformIndices');
  glGetActiveUniformsiv := load('glGetActiveUniformsiv');
  glGetActiveUniformName := load('glGetActiveUniformName');
  glGetUniformBlockIndex := load('glGetUniformBlockIndex');
  glGetActiveUniformBlockiv := load('glGetActiveUniformBlockiv');
  glGetActiveUniformBlockName := load('glGetActiveUniformBlockName');
  glUniformBlockBinding := load('glUniformBlockBinding');
  glBindBufferRange := load('glBindBufferRange');
  glBindBufferBase := load('glBindBufferBase');
  glGetIntegeri_v := load('glGetIntegeri_v');
end;

procedure load_GL_ARB_vertex_array_object(load: TLoadProc);
begin
  if not GLAD_GL_ARB_vertex_array_object then exit;
  glBindVertexArray := load('glBindVertexArray');
  glDeleteVertexArrays := load('glDeleteVertexArrays');
  glGenVertexArrays := load('glGenVertexArrays');
  glIsVertexArray := load('glIsVertexArray');
end;

procedure load_GL_ARB_vertex_attrib_64bit(load: TLoadProc);
begin
  if not GLAD_GL_ARB_vertex_attrib_64bit then exit;
  glVertexAttribL1d := load('glVertexAttribL1d');
  glVertexAttribL2d := load('glVertexAttribL2d');
  glVertexAttribL3d := load('glVertexAttribL3d');
  glVertexAttribL4d := load('glVertexAttribL4d');
  glVertexAttribL1dv := load('glVertexAttribL1dv');
  glVertexAttribL2dv := load('glVertexAttribL2dv');
  glVertexAttribL3dv := load('glVertexAttribL3dv');
  glVertexAttribL4dv := load('glVertexAttribL4dv');
  glVertexAttribLPointer := load('glVertexAttribLPointer');
  glGetVertexAttribLdv := load('glGetVertexAttribLdv');
end;

procedure load_GL_ARB_vertex_attrib_binding(load: TLoadProc);
begin
  if not GLAD_GL_ARB_vertex_attrib_binding then exit;
  glBindVertexBuffer := load('glBindVertexBuffer');
  glVertexAttribFormat := load('glVertexAttribFormat');
  glVertexAttribIFormat := load('glVertexAttribIFormat');
  glVertexAttribLFormat := load('glVertexAttribLFormat');
  glVertexAttribBinding := load('glVertexAttribBinding');
  glVertexBindingDivisor := load('glVertexBindingDivisor');
end;

procedure load_GL_ARB_vertex_blend(load: TLoadProc);
begin
  if not GLAD_GL_ARB_vertex_blend then exit;
  glWeightbvARB := load('glWeightbvARB');
  glWeightsvARB := load('glWeightsvARB');
  glWeightivARB := load('glWeightivARB');
  glWeightfvARB := load('glWeightfvARB');
  glWeightdvARB := load('glWeightdvARB');
  glWeightubvARB := load('glWeightubvARB');
  glWeightusvARB := load('glWeightusvARB');
  glWeightuivARB := load('glWeightuivARB');
  glWeightPointerARB := load('glWeightPointerARB');
  glVertexBlendARB := load('glVertexBlendARB');
end;

procedure load_GL_ARB_vertex_buffer_object(load: TLoadProc);
begin
  if not GLAD_GL_ARB_vertex_buffer_object then exit;
  glBindBufferARB := load('glBindBufferARB');
  glDeleteBuffersARB := load('glDeleteBuffersARB');
  glGenBuffersARB := load('glGenBuffersARB');
  glIsBufferARB := load('glIsBufferARB');
  glBufferDataARB := load('glBufferDataARB');
  glBufferSubDataARB := load('glBufferSubDataARB');
  glGetBufferSubDataARB := load('glGetBufferSubDataARB');
  glMapBufferARB := load('glMapBufferARB');
  glUnmapBufferARB := load('glUnmapBufferARB');
  glGetBufferParameterivARB := load('glGetBufferParameterivARB');
  glGetBufferPointervARB := load('glGetBufferPointervARB');
end;

procedure load_GL_ARB_vertex_program(load: TLoadProc);
begin
  if not GLAD_GL_ARB_vertex_program then exit;
  glVertexAttrib1dARB := load('glVertexAttrib1dARB');
  glVertexAttrib1dvARB := load('glVertexAttrib1dvARB');
  glVertexAttrib1fARB := load('glVertexAttrib1fARB');
  glVertexAttrib1fvARB := load('glVertexAttrib1fvARB');
  glVertexAttrib1sARB := load('glVertexAttrib1sARB');
  glVertexAttrib1svARB := load('glVertexAttrib1svARB');
  glVertexAttrib2dARB := load('glVertexAttrib2dARB');
  glVertexAttrib2dvARB := load('glVertexAttrib2dvARB');
  glVertexAttrib2fARB := load('glVertexAttrib2fARB');
  glVertexAttrib2fvARB := load('glVertexAttrib2fvARB');
  glVertexAttrib2sARB := load('glVertexAttrib2sARB');
  glVertexAttrib2svARB := load('glVertexAttrib2svARB');
  glVertexAttrib3dARB := load('glVertexAttrib3dARB');
  glVertexAttrib3dvARB := load('glVertexAttrib3dvARB');
  glVertexAttrib3fARB := load('glVertexAttrib3fARB');
  glVertexAttrib3fvARB := load('glVertexAttrib3fvARB');
  glVertexAttrib3sARB := load('glVertexAttrib3sARB');
  glVertexAttrib3svARB := load('glVertexAttrib3svARB');
  glVertexAttrib4NbvARB := load('glVertexAttrib4NbvARB');
  glVertexAttrib4NivARB := load('glVertexAttrib4NivARB');
  glVertexAttrib4NsvARB := load('glVertexAttrib4NsvARB');
  glVertexAttrib4NubARB := load('glVertexAttrib4NubARB');
  glVertexAttrib4NubvARB := load('glVertexAttrib4NubvARB');
  glVertexAttrib4NuivARB := load('glVertexAttrib4NuivARB');
  glVertexAttrib4NusvARB := load('glVertexAttrib4NusvARB');
  glVertexAttrib4bvARB := load('glVertexAttrib4bvARB');
  glVertexAttrib4dARB := load('glVertexAttrib4dARB');
  glVertexAttrib4dvARB := load('glVertexAttrib4dvARB');
  glVertexAttrib4fARB := load('glVertexAttrib4fARB');
  glVertexAttrib4fvARB := load('glVertexAttrib4fvARB');
  glVertexAttrib4ivARB := load('glVertexAttrib4ivARB');
  glVertexAttrib4sARB := load('glVertexAttrib4sARB');
  glVertexAttrib4svARB := load('glVertexAttrib4svARB');
  glVertexAttrib4ubvARB := load('glVertexAttrib4ubvARB');
  glVertexAttrib4uivARB := load('glVertexAttrib4uivARB');
  glVertexAttrib4usvARB := load('glVertexAttrib4usvARB');
  glVertexAttribPointerARB := load('glVertexAttribPointerARB');
  glEnableVertexAttribArrayARB := load('glEnableVertexAttribArrayARB');
  glDisableVertexAttribArrayARB := load('glDisableVertexAttribArrayARB');
  glProgramStringARB := load('glProgramStringARB');
  glBindProgramARB := load('glBindProgramARB');
  glDeleteProgramsARB := load('glDeleteProgramsARB');
  glGenProgramsARB := load('glGenProgramsARB');
  glProgramEnvParameter4dARB := load('glProgramEnvParameter4dARB');
  glProgramEnvParameter4dvARB := load('glProgramEnvParameter4dvARB');
  glProgramEnvParameter4fARB := load('glProgramEnvParameter4fARB');
  glProgramEnvParameter4fvARB := load('glProgramEnvParameter4fvARB');
  glProgramLocalParameter4dARB := load('glProgramLocalParameter4dARB');
  glProgramLocalParameter4dvARB := load('glProgramLocalParameter4dvARB');
  glProgramLocalParameter4fARB := load('glProgramLocalParameter4fARB');
  glProgramLocalParameter4fvARB := load('glProgramLocalParameter4fvARB');
  glGetProgramEnvParameterdvARB := load('glGetProgramEnvParameterdvARB');
  glGetProgramEnvParameterfvARB := load('glGetProgramEnvParameterfvARB');
  glGetProgramLocalParameterdvARB := load('glGetProgramLocalParameterdvARB');
  glGetProgramLocalParameterfvARB := load('glGetProgramLocalParameterfvARB');
  glGetProgramivARB := load('glGetProgramivARB');
  glGetProgramStringARB := load('glGetProgramStringARB');
  glGetVertexAttribdvARB := load('glGetVertexAttribdvARB');
  glGetVertexAttribfvARB := load('glGetVertexAttribfvARB');
  glGetVertexAttribivARB := load('glGetVertexAttribivARB');
  glGetVertexAttribPointervARB := load('glGetVertexAttribPointervARB');
  glIsProgramARB := load('glIsProgramARB');
end;

procedure load_GL_ARB_vertex_shader(load: TLoadProc);
begin
  if not GLAD_GL_ARB_vertex_shader then exit;
  glVertexAttrib1fARB := load('glVertexAttrib1fARB');
  glVertexAttrib1sARB := load('glVertexAttrib1sARB');
  glVertexAttrib1dARB := load('glVertexAttrib1dARB');
  glVertexAttrib2fARB := load('glVertexAttrib2fARB');
  glVertexAttrib2sARB := load('glVertexAttrib2sARB');
  glVertexAttrib2dARB := load('glVertexAttrib2dARB');
  glVertexAttrib3fARB := load('glVertexAttrib3fARB');
  glVertexAttrib3sARB := load('glVertexAttrib3sARB');
  glVertexAttrib3dARB := load('glVertexAttrib3dARB');
  glVertexAttrib4fARB := load('glVertexAttrib4fARB');
  glVertexAttrib4sARB := load('glVertexAttrib4sARB');
  glVertexAttrib4dARB := load('glVertexAttrib4dARB');
  glVertexAttrib4NubARB := load('glVertexAttrib4NubARB');
  glVertexAttrib1fvARB := load('glVertexAttrib1fvARB');
  glVertexAttrib1svARB := load('glVertexAttrib1svARB');
  glVertexAttrib1dvARB := load('glVertexAttrib1dvARB');
  glVertexAttrib2fvARB := load('glVertexAttrib2fvARB');
  glVertexAttrib2svARB := load('glVertexAttrib2svARB');
  glVertexAttrib2dvARB := load('glVertexAttrib2dvARB');
  glVertexAttrib3fvARB := load('glVertexAttrib3fvARB');
  glVertexAttrib3svARB := load('glVertexAttrib3svARB');
  glVertexAttrib3dvARB := load('glVertexAttrib3dvARB');
  glVertexAttrib4fvARB := load('glVertexAttrib4fvARB');
  glVertexAttrib4svARB := load('glVertexAttrib4svARB');
  glVertexAttrib4dvARB := load('glVertexAttrib4dvARB');
  glVertexAttrib4ivARB := load('glVertexAttrib4ivARB');
  glVertexAttrib4bvARB := load('glVertexAttrib4bvARB');
  glVertexAttrib4ubvARB := load('glVertexAttrib4ubvARB');
  glVertexAttrib4usvARB := load('glVertexAttrib4usvARB');
  glVertexAttrib4uivARB := load('glVertexAttrib4uivARB');
  glVertexAttrib4NbvARB := load('glVertexAttrib4NbvARB');
  glVertexAttrib4NsvARB := load('glVertexAttrib4NsvARB');
  glVertexAttrib4NivARB := load('glVertexAttrib4NivARB');
  glVertexAttrib4NubvARB := load('glVertexAttrib4NubvARB');
  glVertexAttrib4NusvARB := load('glVertexAttrib4NusvARB');
  glVertexAttrib4NuivARB := load('glVertexAttrib4NuivARB');
  glVertexAttribPointerARB := load('glVertexAttribPointerARB');
  glEnableVertexAttribArrayARB := load('glEnableVertexAttribArrayARB');
  glDisableVertexAttribArrayARB := load('glDisableVertexAttribArrayARB');
  glBindAttribLocationARB := load('glBindAttribLocationARB');
  glGetActiveAttribARB := load('glGetActiveAttribARB');
  glGetAttribLocationARB := load('glGetAttribLocationARB');
  glGetVertexAttribdvARB := load('glGetVertexAttribdvARB');
  glGetVertexAttribfvARB := load('glGetVertexAttribfvARB');
  glGetVertexAttribivARB := load('glGetVertexAttribivARB');
  glGetVertexAttribPointervARB := load('glGetVertexAttribPointervARB');
end;

procedure load_GL_ARB_vertex_type_2_10_10_10_rev(load: TLoadProc);
begin
  if not GLAD_GL_ARB_vertex_type_2_10_10_10_rev then exit;
  glVertexAttribP1ui := load('glVertexAttribP1ui');
  glVertexAttribP1uiv := load('glVertexAttribP1uiv');
  glVertexAttribP2ui := load('glVertexAttribP2ui');
  glVertexAttribP2uiv := load('glVertexAttribP2uiv');
  glVertexAttribP3ui := load('glVertexAttribP3ui');
  glVertexAttribP3uiv := load('glVertexAttribP3uiv');
  glVertexAttribP4ui := load('glVertexAttribP4ui');
  glVertexAttribP4uiv := load('glVertexAttribP4uiv');
  glVertexP2ui := load('glVertexP2ui');
  glVertexP2uiv := load('glVertexP2uiv');
  glVertexP3ui := load('glVertexP3ui');
  glVertexP3uiv := load('glVertexP3uiv');
  glVertexP4ui := load('glVertexP4ui');
  glVertexP4uiv := load('glVertexP4uiv');
  glTexCoordP1ui := load('glTexCoordP1ui');
  glTexCoordP1uiv := load('glTexCoordP1uiv');
  glTexCoordP2ui := load('glTexCoordP2ui');
  glTexCoordP2uiv := load('glTexCoordP2uiv');
  glTexCoordP3ui := load('glTexCoordP3ui');
  glTexCoordP3uiv := load('glTexCoordP3uiv');
  glTexCoordP4ui := load('glTexCoordP4ui');
  glTexCoordP4uiv := load('glTexCoordP4uiv');
  glMultiTexCoordP1ui := load('glMultiTexCoordP1ui');
  glMultiTexCoordP1uiv := load('glMultiTexCoordP1uiv');
  glMultiTexCoordP2ui := load('glMultiTexCoordP2ui');
  glMultiTexCoordP2uiv := load('glMultiTexCoordP2uiv');
  glMultiTexCoordP3ui := load('glMultiTexCoordP3ui');
  glMultiTexCoordP3uiv := load('glMultiTexCoordP3uiv');
  glMultiTexCoordP4ui := load('glMultiTexCoordP4ui');
  glMultiTexCoordP4uiv := load('glMultiTexCoordP4uiv');
  glNormalP3ui := load('glNormalP3ui');
  glNormalP3uiv := load('glNormalP3uiv');
  glColorP3ui := load('glColorP3ui');
  glColorP3uiv := load('glColorP3uiv');
  glColorP4ui := load('glColorP4ui');
  glColorP4uiv := load('glColorP4uiv');
  glSecondaryColorP3ui := load('glSecondaryColorP3ui');
  glSecondaryColorP3uiv := load('glSecondaryColorP3uiv');
end;

procedure load_GL_ARB_viewport_array(load: TLoadProc);
begin
  if not GLAD_GL_ARB_viewport_array then exit;
  glViewportArrayv := load('glViewportArrayv');
  glViewportIndexedf := load('glViewportIndexedf');
  glViewportIndexedfv := load('glViewportIndexedfv');
  glScissorArrayv := load('glScissorArrayv');
  glScissorIndexed := load('glScissorIndexed');
  glScissorIndexedv := load('glScissorIndexedv');
  glDepthRangeArrayv := load('glDepthRangeArrayv');
  glDepthRangeIndexed := load('glDepthRangeIndexed');
  glGetFloati_v := load('glGetFloati_v');
  glGetDoublei_v := load('glGetDoublei_v');
  glDepthRangeArraydvNV := load('glDepthRangeArraydvNV');
  glDepthRangeIndexeddNV := load('glDepthRangeIndexeddNV');
end;

procedure load_GL_ARB_window_pos(load: TLoadProc);
begin
  if not GLAD_GL_ARB_window_pos then exit;
  glWindowPos2dARB := load('glWindowPos2dARB');
  glWindowPos2dvARB := load('glWindowPos2dvARB');
  glWindowPos2fARB := load('glWindowPos2fARB');
  glWindowPos2fvARB := load('glWindowPos2fvARB');
  glWindowPos2iARB := load('glWindowPos2iARB');
  glWindowPos2ivARB := load('glWindowPos2ivARB');
  glWindowPos2sARB := load('glWindowPos2sARB');
  glWindowPos2svARB := load('glWindowPos2svARB');
  glWindowPos3dARB := load('glWindowPos3dARB');
  glWindowPos3dvARB := load('glWindowPos3dvARB');
  glWindowPos3fARB := load('glWindowPos3fARB');
  glWindowPos3fvARB := load('glWindowPos3fvARB');
  glWindowPos3iARB := load('glWindowPos3iARB');
  glWindowPos3ivARB := load('glWindowPos3ivARB');
  glWindowPos3sARB := load('glWindowPos3sARB');
  glWindowPos3svARB := load('glWindowPos3svARB');
end;

procedure load_GL_ATI_draw_buffers(load: TLoadProc);
begin
  if not GLAD_GL_ATI_draw_buffers then exit;
  glDrawBuffersATI := load('glDrawBuffersATI');
end;

procedure load_GL_ATI_element_array(load: TLoadProc);
begin
  if not GLAD_GL_ATI_element_array then exit;
  glElementPointerATI := load('glElementPointerATI');
  glDrawElementArrayATI := load('glDrawElementArrayATI');
  glDrawRangeElementArrayATI := load('glDrawRangeElementArrayATI');
end;

procedure load_GL_ATI_envmap_bumpmap(load: TLoadProc);
begin
  if not GLAD_GL_ATI_envmap_bumpmap then exit;
  glTexBumpParameterivATI := load('glTexBumpParameterivATI');
  glTexBumpParameterfvATI := load('glTexBumpParameterfvATI');
  glGetTexBumpParameterivATI := load('glGetTexBumpParameterivATI');
  glGetTexBumpParameterfvATI := load('glGetTexBumpParameterfvATI');
end;

procedure load_GL_ATI_fragment_shader(load: TLoadProc);
begin
  if not GLAD_GL_ATI_fragment_shader then exit;
  glGenFragmentShadersATI := load('glGenFragmentShadersATI');
  glBindFragmentShaderATI := load('glBindFragmentShaderATI');
  glDeleteFragmentShaderATI := load('glDeleteFragmentShaderATI');
  glBeginFragmentShaderATI := load('glBeginFragmentShaderATI');
  glEndFragmentShaderATI := load('glEndFragmentShaderATI');
  glPassTexCoordATI := load('glPassTexCoordATI');
  glSampleMapATI := load('glSampleMapATI');
  glColorFragmentOp1ATI := load('glColorFragmentOp1ATI');
  glColorFragmentOp2ATI := load('glColorFragmentOp2ATI');
  glColorFragmentOp3ATI := load('glColorFragmentOp3ATI');
  glAlphaFragmentOp1ATI := load('glAlphaFragmentOp1ATI');
  glAlphaFragmentOp2ATI := load('glAlphaFragmentOp2ATI');
  glAlphaFragmentOp3ATI := load('glAlphaFragmentOp3ATI');
  glSetFragmentShaderConstantATI := load('glSetFragmentShaderConstantATI');
end;

procedure load_GL_ATI_map_object_buffer(load: TLoadProc);
begin
  if not GLAD_GL_ATI_map_object_buffer then exit;
  glMapObjectBufferATI := load('glMapObjectBufferATI');
  glUnmapObjectBufferATI := load('glUnmapObjectBufferATI');
end;

procedure load_GL_ATI_pn_triangles(load: TLoadProc);
begin
  if not GLAD_GL_ATI_pn_triangles then exit;
  glPNTrianglesiATI := load('glPNTrianglesiATI');
  glPNTrianglesfATI := load('glPNTrianglesfATI');
end;

procedure load_GL_ATI_separate_stencil(load: TLoadProc);
begin
  if not GLAD_GL_ATI_separate_stencil then exit;
  glStencilOpSeparateATI := load('glStencilOpSeparateATI');
  glStencilFuncSeparateATI := load('glStencilFuncSeparateATI');
end;

procedure load_GL_ATI_vertex_array_object(load: TLoadProc);
begin
  if not GLAD_GL_ATI_vertex_array_object then exit;
  glNewObjectBufferATI := load('glNewObjectBufferATI');
  glIsObjectBufferATI := load('glIsObjectBufferATI');
  glUpdateObjectBufferATI := load('glUpdateObjectBufferATI');
  glGetObjectBufferfvATI := load('glGetObjectBufferfvATI');
  glGetObjectBufferivATI := load('glGetObjectBufferivATI');
  glFreeObjectBufferATI := load('glFreeObjectBufferATI');
  glArrayObjectATI := load('glArrayObjectATI');
  glGetArrayObjectfvATI := load('glGetArrayObjectfvATI');
  glGetArrayObjectivATI := load('glGetArrayObjectivATI');
  glVariantArrayObjectATI := load('glVariantArrayObjectATI');
  glGetVariantArrayObjectfvATI := load('glGetVariantArrayObjectfvATI');
  glGetVariantArrayObjectivATI := load('glGetVariantArrayObjectivATI');
end;

procedure load_GL_ATI_vertex_attrib_array_object(load: TLoadProc);
begin
  if not GLAD_GL_ATI_vertex_attrib_array_object then exit;
  glVertexAttribArrayObjectATI := load('glVertexAttribArrayObjectATI');
  glGetVertexAttribArrayObjectfvATI := load('glGetVertexAttribArrayObjectfvATI');
  glGetVertexAttribArrayObjectivATI := load('glGetVertexAttribArrayObjectivATI');
end;

procedure load_GL_ATI_vertex_streams(load: TLoadProc);
begin
  if not GLAD_GL_ATI_vertex_streams then exit;
  glVertexStream1sATI := load('glVertexStream1sATI');
  glVertexStream1svATI := load('glVertexStream1svATI');
  glVertexStream1iATI := load('glVertexStream1iATI');
  glVertexStream1ivATI := load('glVertexStream1ivATI');
  glVertexStream1fATI := load('glVertexStream1fATI');
  glVertexStream1fvATI := load('glVertexStream1fvATI');
  glVertexStream1dATI := load('glVertexStream1dATI');
  glVertexStream1dvATI := load('glVertexStream1dvATI');
  glVertexStream2sATI := load('glVertexStream2sATI');
  glVertexStream2svATI := load('glVertexStream2svATI');
  glVertexStream2iATI := load('glVertexStream2iATI');
  glVertexStream2ivATI := load('glVertexStream2ivATI');
  glVertexStream2fATI := load('glVertexStream2fATI');
  glVertexStream2fvATI := load('glVertexStream2fvATI');
  glVertexStream2dATI := load('glVertexStream2dATI');
  glVertexStream2dvATI := load('glVertexStream2dvATI');
  glVertexStream3sATI := load('glVertexStream3sATI');
  glVertexStream3svATI := load('glVertexStream3svATI');
  glVertexStream3iATI := load('glVertexStream3iATI');
  glVertexStream3ivATI := load('glVertexStream3ivATI');
  glVertexStream3fATI := load('glVertexStream3fATI');
  glVertexStream3fvATI := load('glVertexStream3fvATI');
  glVertexStream3dATI := load('glVertexStream3dATI');
  glVertexStream3dvATI := load('glVertexStream3dvATI');
  glVertexStream4sATI := load('glVertexStream4sATI');
  glVertexStream4svATI := load('glVertexStream4svATI');
  glVertexStream4iATI := load('glVertexStream4iATI');
  glVertexStream4ivATI := load('glVertexStream4ivATI');
  glVertexStream4fATI := load('glVertexStream4fATI');
  glVertexStream4fvATI := load('glVertexStream4fvATI');
  glVertexStream4dATI := load('glVertexStream4dATI');
  glVertexStream4dvATI := load('glVertexStream4dvATI');
  glNormalStream3bATI := load('glNormalStream3bATI');
  glNormalStream3bvATI := load('glNormalStream3bvATI');
  glNormalStream3sATI := load('glNormalStream3sATI');
  glNormalStream3svATI := load('glNormalStream3svATI');
  glNormalStream3iATI := load('glNormalStream3iATI');
  glNormalStream3ivATI := load('glNormalStream3ivATI');
  glNormalStream3fATI := load('glNormalStream3fATI');
  glNormalStream3fvATI := load('glNormalStream3fvATI');
  glNormalStream3dATI := load('glNormalStream3dATI');
  glNormalStream3dvATI := load('glNormalStream3dvATI');
  glClientActiveVertexStreamATI := load('glClientActiveVertexStreamATI');
  glVertexBlendEnviATI := load('glVertexBlendEnviATI');
  glVertexBlendEnvfATI := load('glVertexBlendEnvfATI');
end;

procedure load_GL_EXT_EGL_image_storage(load: TLoadProc);
begin
  if not GLAD_GL_EXT_EGL_image_storage then exit;
  glEGLImageTargetTexStorageEXT := load('glEGLImageTargetTexStorageEXT');
  glEGLImageTargetTextureStorageEXT := load('glEGLImageTargetTextureStorageEXT');
end;

procedure load_GL_EXT_bindable_uniform(load: TLoadProc);
begin
  if not GLAD_GL_EXT_bindable_uniform then exit;
  glUniformBufferEXT := load('glUniformBufferEXT');
  glGetUniformBufferSizeEXT := load('glGetUniformBufferSizeEXT');
  glGetUniformOffsetEXT := load('glGetUniformOffsetEXT');
end;

procedure load_GL_EXT_blend_color(load: TLoadProc);
begin
  if not GLAD_GL_EXT_blend_color then exit;
  glBlendColorEXT := load('glBlendColorEXT');
end;

procedure load_GL_EXT_blend_equation_separate(load: TLoadProc);
begin
  if not GLAD_GL_EXT_blend_equation_separate then exit;
  glBlendEquationSeparateEXT := load('glBlendEquationSeparateEXT');
end;

procedure load_GL_EXT_blend_func_separate(load: TLoadProc);
begin
  if not GLAD_GL_EXT_blend_func_separate then exit;
  glBlendFuncSeparateEXT := load('glBlendFuncSeparateEXT');
end;

procedure load_GL_EXT_blend_minmax(load: TLoadProc);
begin
  if not GLAD_GL_EXT_blend_minmax then exit;
  glBlendEquationEXT := load('glBlendEquationEXT');
end;

procedure load_GL_EXT_color_subtable(load: TLoadProc);
begin
  if not GLAD_GL_EXT_color_subtable then exit;
  glColorSubTableEXT := load('glColorSubTableEXT');
  glCopyColorSubTableEXT := load('glCopyColorSubTableEXT');
end;

procedure load_GL_EXT_compiled_vertex_array(load: TLoadProc);
begin
  if not GLAD_GL_EXT_compiled_vertex_array then exit;
  glLockArraysEXT := load('glLockArraysEXT');
  glUnlockArraysEXT := load('glUnlockArraysEXT');
end;

procedure load_GL_EXT_convolution(load: TLoadProc);
begin
  if not GLAD_GL_EXT_convolution then exit;
  glConvolutionFilter1DEXT := load('glConvolutionFilter1DEXT');
  glConvolutionFilter2DEXT := load('glConvolutionFilter2DEXT');
  glConvolutionParameterfEXT := load('glConvolutionParameterfEXT');
  glConvolutionParameterfvEXT := load('glConvolutionParameterfvEXT');
  glConvolutionParameteriEXT := load('glConvolutionParameteriEXT');
  glConvolutionParameterivEXT := load('glConvolutionParameterivEXT');
  glCopyConvolutionFilter1DEXT := load('glCopyConvolutionFilter1DEXT');
  glCopyConvolutionFilter2DEXT := load('glCopyConvolutionFilter2DEXT');
  glGetConvolutionFilterEXT := load('glGetConvolutionFilterEXT');
  glGetConvolutionParameterfvEXT := load('glGetConvolutionParameterfvEXT');
  glGetConvolutionParameterivEXT := load('glGetConvolutionParameterivEXT');
  glGetSeparableFilterEXT := load('glGetSeparableFilterEXT');
  glSeparableFilter2DEXT := load('glSeparableFilter2DEXT');
end;

procedure load_GL_EXT_coordinate_frame(load: TLoadProc);
begin
  if not GLAD_GL_EXT_coordinate_frame then exit;
  glTangent3bEXT := load('glTangent3bEXT');
  glTangent3bvEXT := load('glTangent3bvEXT');
  glTangent3dEXT := load('glTangent3dEXT');
  glTangent3dvEXT := load('glTangent3dvEXT');
  glTangent3fEXT := load('glTangent3fEXT');
  glTangent3fvEXT := load('glTangent3fvEXT');
  glTangent3iEXT := load('glTangent3iEXT');
  glTangent3ivEXT := load('glTangent3ivEXT');
  glTangent3sEXT := load('glTangent3sEXT');
  glTangent3svEXT := load('glTangent3svEXT');
  glBinormal3bEXT := load('glBinormal3bEXT');
  glBinormal3bvEXT := load('glBinormal3bvEXT');
  glBinormal3dEXT := load('glBinormal3dEXT');
  glBinormal3dvEXT := load('glBinormal3dvEXT');
  glBinormal3fEXT := load('glBinormal3fEXT');
  glBinormal3fvEXT := load('glBinormal3fvEXT');
  glBinormal3iEXT := load('glBinormal3iEXT');
  glBinormal3ivEXT := load('glBinormal3ivEXT');
  glBinormal3sEXT := load('glBinormal3sEXT');
  glBinormal3svEXT := load('glBinormal3svEXT');
  glTangentPointerEXT := load('glTangentPointerEXT');
  glBinormalPointerEXT := load('glBinormalPointerEXT');
end;

procedure load_GL_EXT_copy_texture(load: TLoadProc);
begin
  if not GLAD_GL_EXT_copy_texture then exit;
  glCopyTexImage1DEXT := load('glCopyTexImage1DEXT');
  glCopyTexImage2DEXT := load('glCopyTexImage2DEXT');
  glCopyTexSubImage1DEXT := load('glCopyTexSubImage1DEXT');
  glCopyTexSubImage2DEXT := load('glCopyTexSubImage2DEXT');
  glCopyTexSubImage3DEXT := load('glCopyTexSubImage3DEXT');
end;

procedure load_GL_EXT_cull_vertex(load: TLoadProc);
begin
  if not GLAD_GL_EXT_cull_vertex then exit;
  glCullParameterdvEXT := load('glCullParameterdvEXT');
  glCullParameterfvEXT := load('glCullParameterfvEXT');
end;

procedure load_GL_EXT_debug_label(load: TLoadProc);
begin
  if not GLAD_GL_EXT_debug_label then exit;
  glLabelObjectEXT := load('glLabelObjectEXT');
  glGetObjectLabelEXT := load('glGetObjectLabelEXT');
end;

procedure load_GL_EXT_debug_marker(load: TLoadProc);
begin
  if not GLAD_GL_EXT_debug_marker then exit;
  glInsertEventMarkerEXT := load('glInsertEventMarkerEXT');
  glPushGroupMarkerEXT := load('glPushGroupMarkerEXT');
  glPopGroupMarkerEXT := load('glPopGroupMarkerEXT');
end;

procedure load_GL_EXT_depth_bounds_test(load: TLoadProc);
begin
  if not GLAD_GL_EXT_depth_bounds_test then exit;
  glDepthBoundsEXT := load('glDepthBoundsEXT');
end;

procedure load_GL_EXT_direct_state_access(load: TLoadProc);
begin
  if not GLAD_GL_EXT_direct_state_access then exit;
  glMatrixLoadfEXT := load('glMatrixLoadfEXT');
  glMatrixLoaddEXT := load('glMatrixLoaddEXT');
  glMatrixMultfEXT := load('glMatrixMultfEXT');
  glMatrixMultdEXT := load('glMatrixMultdEXT');
  glMatrixLoadIdentityEXT := load('glMatrixLoadIdentityEXT');
  glMatrixRotatefEXT := load('glMatrixRotatefEXT');
  glMatrixRotatedEXT := load('glMatrixRotatedEXT');
  glMatrixScalefEXT := load('glMatrixScalefEXT');
  glMatrixScaledEXT := load('glMatrixScaledEXT');
  glMatrixTranslatefEXT := load('glMatrixTranslatefEXT');
  glMatrixTranslatedEXT := load('glMatrixTranslatedEXT');
  glMatrixFrustumEXT := load('glMatrixFrustumEXT');
  glMatrixOrthoEXT := load('glMatrixOrthoEXT');
  glMatrixPopEXT := load('glMatrixPopEXT');
  glMatrixPushEXT := load('glMatrixPushEXT');
  glClientAttribDefaultEXT := load('glClientAttribDefaultEXT');
  glPushClientAttribDefaultEXT := load('glPushClientAttribDefaultEXT');
  glTextureParameterfEXT := load('glTextureParameterfEXT');
  glTextureParameterfvEXT := load('glTextureParameterfvEXT');
  glTextureParameteriEXT := load('glTextureParameteriEXT');
  glTextureParameterivEXT := load('glTextureParameterivEXT');
  glTextureImage1DEXT := load('glTextureImage1DEXT');
  glTextureImage2DEXT := load('glTextureImage2DEXT');
  glTextureSubImage1DEXT := load('glTextureSubImage1DEXT');
  glTextureSubImage2DEXT := load('glTextureSubImage2DEXT');
  glCopyTextureImage1DEXT := load('glCopyTextureImage1DEXT');
  glCopyTextureImage2DEXT := load('glCopyTextureImage2DEXT');
  glCopyTextureSubImage1DEXT := load('glCopyTextureSubImage1DEXT');
  glCopyTextureSubImage2DEXT := load('glCopyTextureSubImage2DEXT');
  glGetTextureImageEXT := load('glGetTextureImageEXT');
  glGetTextureParameterfvEXT := load('glGetTextureParameterfvEXT');
  glGetTextureParameterivEXT := load('glGetTextureParameterivEXT');
  glGetTextureLevelParameterfvEXT := load('glGetTextureLevelParameterfvEXT');
  glGetTextureLevelParameterivEXT := load('glGetTextureLevelParameterivEXT');
  glTextureImage3DEXT := load('glTextureImage3DEXT');
  glTextureSubImage3DEXT := load('glTextureSubImage3DEXT');
  glCopyTextureSubImage3DEXT := load('glCopyTextureSubImage3DEXT');
  glBindMultiTextureEXT := load('glBindMultiTextureEXT');
  glMultiTexCoordPointerEXT := load('glMultiTexCoordPointerEXT');
  glMultiTexEnvfEXT := load('glMultiTexEnvfEXT');
  glMultiTexEnvfvEXT := load('glMultiTexEnvfvEXT');
  glMultiTexEnviEXT := load('glMultiTexEnviEXT');
  glMultiTexEnvivEXT := load('glMultiTexEnvivEXT');
  glMultiTexGendEXT := load('glMultiTexGendEXT');
  glMultiTexGendvEXT := load('glMultiTexGendvEXT');
  glMultiTexGenfEXT := load('glMultiTexGenfEXT');
  glMultiTexGenfvEXT := load('glMultiTexGenfvEXT');
  glMultiTexGeniEXT := load('glMultiTexGeniEXT');
  glMultiTexGenivEXT := load('glMultiTexGenivEXT');
  glGetMultiTexEnvfvEXT := load('glGetMultiTexEnvfvEXT');
  glGetMultiTexEnvivEXT := load('glGetMultiTexEnvivEXT');
  glGetMultiTexGendvEXT := load('glGetMultiTexGendvEXT');
  glGetMultiTexGenfvEXT := load('glGetMultiTexGenfvEXT');
  glGetMultiTexGenivEXT := load('glGetMultiTexGenivEXT');
  glMultiTexParameteriEXT := load('glMultiTexParameteriEXT');
  glMultiTexParameterivEXT := load('glMultiTexParameterivEXT');
  glMultiTexParameterfEXT := load('glMultiTexParameterfEXT');
  glMultiTexParameterfvEXT := load('glMultiTexParameterfvEXT');
  glMultiTexImage1DEXT := load('glMultiTexImage1DEXT');
  glMultiTexImage2DEXT := load('glMultiTexImage2DEXT');
  glMultiTexSubImage1DEXT := load('glMultiTexSubImage1DEXT');
  glMultiTexSubImage2DEXT := load('glMultiTexSubImage2DEXT');
  glCopyMultiTexImage1DEXT := load('glCopyMultiTexImage1DEXT');
  glCopyMultiTexImage2DEXT := load('glCopyMultiTexImage2DEXT');
  glCopyMultiTexSubImage1DEXT := load('glCopyMultiTexSubImage1DEXT');
  glCopyMultiTexSubImage2DEXT := load('glCopyMultiTexSubImage2DEXT');
  glGetMultiTexImageEXT := load('glGetMultiTexImageEXT');
  glGetMultiTexParameterfvEXT := load('glGetMultiTexParameterfvEXT');
  glGetMultiTexParameterivEXT := load('glGetMultiTexParameterivEXT');
  glGetMultiTexLevelParameterfvEXT := load('glGetMultiTexLevelParameterfvEXT');
  glGetMultiTexLevelParameterivEXT := load('glGetMultiTexLevelParameterivEXT');
  glMultiTexImage3DEXT := load('glMultiTexImage3DEXT');
  glMultiTexSubImage3DEXT := load('glMultiTexSubImage3DEXT');
  glCopyMultiTexSubImage3DEXT := load('glCopyMultiTexSubImage3DEXT');
  glEnableClientStateIndexedEXT := load('glEnableClientStateIndexedEXT');
  glDisableClientStateIndexedEXT := load('glDisableClientStateIndexedEXT');
  glGetFloatIndexedvEXT := load('glGetFloatIndexedvEXT');
  glGetDoubleIndexedvEXT := load('glGetDoubleIndexedvEXT');
  glGetPointerIndexedvEXT := load('glGetPointerIndexedvEXT');
  glEnableIndexedEXT := load('glEnableIndexedEXT');
  glDisableIndexedEXT := load('glDisableIndexedEXT');
  glIsEnabledIndexedEXT := load('glIsEnabledIndexedEXT');
  glGetIntegerIndexedvEXT := load('glGetIntegerIndexedvEXT');
  glGetBooleanIndexedvEXT := load('glGetBooleanIndexedvEXT');
  glCompressedTextureImage3DEXT := load('glCompressedTextureImage3DEXT');
  glCompressedTextureImage2DEXT := load('glCompressedTextureImage2DEXT');
  glCompressedTextureImage1DEXT := load('glCompressedTextureImage1DEXT');
  glCompressedTextureSubImage3DEXT := load('glCompressedTextureSubImage3DEXT');
  glCompressedTextureSubImage2DEXT := load('glCompressedTextureSubImage2DEXT');
  glCompressedTextureSubImage1DEXT := load('glCompressedTextureSubImage1DEXT');
  glGetCompressedTextureImageEXT := load('glGetCompressedTextureImageEXT');
  glCompressedMultiTexImage3DEXT := load('glCompressedMultiTexImage3DEXT');
  glCompressedMultiTexImage2DEXT := load('glCompressedMultiTexImage2DEXT');
  glCompressedMultiTexImage1DEXT := load('glCompressedMultiTexImage1DEXT');
  glCompressedMultiTexSubImage3DEXT := load('glCompressedMultiTexSubImage3DEXT');
  glCompressedMultiTexSubImage2DEXT := load('glCompressedMultiTexSubImage2DEXT');
  glCompressedMultiTexSubImage1DEXT := load('glCompressedMultiTexSubImage1DEXT');
  glGetCompressedMultiTexImageEXT := load('glGetCompressedMultiTexImageEXT');
  glMatrixLoadTransposefEXT := load('glMatrixLoadTransposefEXT');
  glMatrixLoadTransposedEXT := load('glMatrixLoadTransposedEXT');
  glMatrixMultTransposefEXT := load('glMatrixMultTransposefEXT');
  glMatrixMultTransposedEXT := load('glMatrixMultTransposedEXT');
  glNamedBufferDataEXT := load('glNamedBufferDataEXT');
  glNamedBufferSubDataEXT := load('glNamedBufferSubDataEXT');
  glMapNamedBufferEXT := load('glMapNamedBufferEXT');
  glUnmapNamedBufferEXT := load('glUnmapNamedBufferEXT');
  glGetNamedBufferParameterivEXT := load('glGetNamedBufferParameterivEXT');
  glGetNamedBufferPointervEXT := load('glGetNamedBufferPointervEXT');
  glGetNamedBufferSubDataEXT := load('glGetNamedBufferSubDataEXT');
  glProgramUniform1fEXT := load('glProgramUniform1fEXT');
  glProgramUniform2fEXT := load('glProgramUniform2fEXT');
  glProgramUniform3fEXT := load('glProgramUniform3fEXT');
  glProgramUniform4fEXT := load('glProgramUniform4fEXT');
  glProgramUniform1iEXT := load('glProgramUniform1iEXT');
  glProgramUniform2iEXT := load('glProgramUniform2iEXT');
  glProgramUniform3iEXT := load('glProgramUniform3iEXT');
  glProgramUniform4iEXT := load('glProgramUniform4iEXT');
  glProgramUniform1fvEXT := load('glProgramUniform1fvEXT');
  glProgramUniform2fvEXT := load('glProgramUniform2fvEXT');
  glProgramUniform3fvEXT := load('glProgramUniform3fvEXT');
  glProgramUniform4fvEXT := load('glProgramUniform4fvEXT');
  glProgramUniform1ivEXT := load('glProgramUniform1ivEXT');
  glProgramUniform2ivEXT := load('glProgramUniform2ivEXT');
  glProgramUniform3ivEXT := load('glProgramUniform3ivEXT');
  glProgramUniform4ivEXT := load('glProgramUniform4ivEXT');
  glProgramUniformMatrix2fvEXT := load('glProgramUniformMatrix2fvEXT');
  glProgramUniformMatrix3fvEXT := load('glProgramUniformMatrix3fvEXT');
  glProgramUniformMatrix4fvEXT := load('glProgramUniformMatrix4fvEXT');
  glProgramUniformMatrix2x3fvEXT := load('glProgramUniformMatrix2x3fvEXT');
  glProgramUniformMatrix3x2fvEXT := load('glProgramUniformMatrix3x2fvEXT');
  glProgramUniformMatrix2x4fvEXT := load('glProgramUniformMatrix2x4fvEXT');
  glProgramUniformMatrix4x2fvEXT := load('glProgramUniformMatrix4x2fvEXT');
  glProgramUniformMatrix3x4fvEXT := load('glProgramUniformMatrix3x4fvEXT');
  glProgramUniformMatrix4x3fvEXT := load('glProgramUniformMatrix4x3fvEXT');
  glTextureBufferEXT := load('glTextureBufferEXT');
  glMultiTexBufferEXT := load('glMultiTexBufferEXT');
  glTextureParameterIivEXT := load('glTextureParameterIivEXT');
  glTextureParameterIuivEXT := load('glTextureParameterIuivEXT');
  glGetTextureParameterIivEXT := load('glGetTextureParameterIivEXT');
  glGetTextureParameterIuivEXT := load('glGetTextureParameterIuivEXT');
  glMultiTexParameterIivEXT := load('glMultiTexParameterIivEXT');
  glMultiTexParameterIuivEXT := load('glMultiTexParameterIuivEXT');
  glGetMultiTexParameterIivEXT := load('glGetMultiTexParameterIivEXT');
  glGetMultiTexParameterIuivEXT := load('glGetMultiTexParameterIuivEXT');
  glProgramUniform1uiEXT := load('glProgramUniform1uiEXT');
  glProgramUniform2uiEXT := load('glProgramUniform2uiEXT');
  glProgramUniform3uiEXT := load('glProgramUniform3uiEXT');
  glProgramUniform4uiEXT := load('glProgramUniform4uiEXT');
  glProgramUniform1uivEXT := load('glProgramUniform1uivEXT');
  glProgramUniform2uivEXT := load('glProgramUniform2uivEXT');
  glProgramUniform3uivEXT := load('glProgramUniform3uivEXT');
  glProgramUniform4uivEXT := load('glProgramUniform4uivEXT');
  glNamedProgramLocalParameters4fvEXT := load('glNamedProgramLocalParameters4fvEXT');
  glNamedProgramLocalParameterI4iEXT := load('glNamedProgramLocalParameterI4iEXT');
  glNamedProgramLocalParameterI4ivEXT := load('glNamedProgramLocalParameterI4ivEXT');
  glNamedProgramLocalParametersI4ivEXT := load('glNamedProgramLocalParametersI4ivEXT');
  glNamedProgramLocalParameterI4uiEXT := load('glNamedProgramLocalParameterI4uiEXT');
  glNamedProgramLocalParameterI4uivEXT := load('glNamedProgramLocalParameterI4uivEXT');
  glNamedProgramLocalParametersI4uivEXT := load('glNamedProgramLocalParametersI4uivEXT');
  glGetNamedProgramLocalParameterIivEXT := load('glGetNamedProgramLocalParameterIivEXT');
  glGetNamedProgramLocalParameterIuivEXT := load('glGetNamedProgramLocalParameterIuivEXT');
  glEnableClientStateiEXT := load('glEnableClientStateiEXT');
  glDisableClientStateiEXT := load('glDisableClientStateiEXT');
  glGetFloati_vEXT := load('glGetFloati_vEXT');
  glGetDoublei_vEXT := load('glGetDoublei_vEXT');
  glGetPointeri_vEXT := load('glGetPointeri_vEXT');
  glNamedProgramStringEXT := load('glNamedProgramStringEXT');
  glNamedProgramLocalParameter4dEXT := load('glNamedProgramLocalParameter4dEXT');
  glNamedProgramLocalParameter4dvEXT := load('glNamedProgramLocalParameter4dvEXT');
  glNamedProgramLocalParameter4fEXT := load('glNamedProgramLocalParameter4fEXT');
  glNamedProgramLocalParameter4fvEXT := load('glNamedProgramLocalParameter4fvEXT');
  glGetNamedProgramLocalParameterdvEXT := load('glGetNamedProgramLocalParameterdvEXT');
  glGetNamedProgramLocalParameterfvEXT := load('glGetNamedProgramLocalParameterfvEXT');
  glGetNamedProgramivEXT := load('glGetNamedProgramivEXT');
  glGetNamedProgramStringEXT := load('glGetNamedProgramStringEXT');
  glNamedRenderbufferStorageEXT := load('glNamedRenderbufferStorageEXT');
  glGetNamedRenderbufferParameterivEXT := load('glGetNamedRenderbufferParameterivEXT');
  glNamedRenderbufferStorageMultisampleEXT := load('glNamedRenderbufferStorageMultisampleEXT');
  glNamedRenderbufferStorageMultisampleCoverageEXT := load('glNamedRenderbufferStorageMultisampleCoverageEXT');
  glCheckNamedFramebufferStatusEXT := load('glCheckNamedFramebufferStatusEXT');
  glNamedFramebufferTexture1DEXT := load('glNamedFramebufferTexture1DEXT');
  glNamedFramebufferTexture2DEXT := load('glNamedFramebufferTexture2DEXT');
  glNamedFramebufferTexture3DEXT := load('glNamedFramebufferTexture3DEXT');
  glNamedFramebufferRenderbufferEXT := load('glNamedFramebufferRenderbufferEXT');
  glGetNamedFramebufferAttachmentParameterivEXT := load('glGetNamedFramebufferAttachmentParameterivEXT');
  glGenerateTextureMipmapEXT := load('glGenerateTextureMipmapEXT');
  glGenerateMultiTexMipmapEXT := load('glGenerateMultiTexMipmapEXT');
  glFramebufferDrawBufferEXT := load('glFramebufferDrawBufferEXT');
  glFramebufferDrawBuffersEXT := load('glFramebufferDrawBuffersEXT');
  glFramebufferReadBufferEXT := load('glFramebufferReadBufferEXT');
  glGetFramebufferParameterivEXT := load('glGetFramebufferParameterivEXT');
  glNamedCopyBufferSubDataEXT := load('glNamedCopyBufferSubDataEXT');
  glNamedFramebufferTextureEXT := load('glNamedFramebufferTextureEXT');
  glNamedFramebufferTextureLayerEXT := load('glNamedFramebufferTextureLayerEXT');
  glNamedFramebufferTextureFaceEXT := load('glNamedFramebufferTextureFaceEXT');
  glTextureRenderbufferEXT := load('glTextureRenderbufferEXT');
  glMultiTexRenderbufferEXT := load('glMultiTexRenderbufferEXT');
  glVertexArrayVertexOffsetEXT := load('glVertexArrayVertexOffsetEXT');
  glVertexArrayColorOffsetEXT := load('glVertexArrayColorOffsetEXT');
  glVertexArrayEdgeFlagOffsetEXT := load('glVertexArrayEdgeFlagOffsetEXT');
  glVertexArrayIndexOffsetEXT := load('glVertexArrayIndexOffsetEXT');
  glVertexArrayNormalOffsetEXT := load('glVertexArrayNormalOffsetEXT');
  glVertexArrayTexCoordOffsetEXT := load('glVertexArrayTexCoordOffsetEXT');
  glVertexArrayMultiTexCoordOffsetEXT := load('glVertexArrayMultiTexCoordOffsetEXT');
  glVertexArrayFogCoordOffsetEXT := load('glVertexArrayFogCoordOffsetEXT');
  glVertexArraySecondaryColorOffsetEXT := load('glVertexArraySecondaryColorOffsetEXT');
  glVertexArrayVertexAttribOffsetEXT := load('glVertexArrayVertexAttribOffsetEXT');
  glVertexArrayVertexAttribIOffsetEXT := load('glVertexArrayVertexAttribIOffsetEXT');
  glEnableVertexArrayEXT := load('glEnableVertexArrayEXT');
  glDisableVertexArrayEXT := load('glDisableVertexArrayEXT');
  glEnableVertexArrayAttribEXT := load('glEnableVertexArrayAttribEXT');
  glDisableVertexArrayAttribEXT := load('glDisableVertexArrayAttribEXT');
  glGetVertexArrayIntegervEXT := load('glGetVertexArrayIntegervEXT');
  glGetVertexArrayPointervEXT := load('glGetVertexArrayPointervEXT');
  glGetVertexArrayIntegeri_vEXT := load('glGetVertexArrayIntegeri_vEXT');
  glGetVertexArrayPointeri_vEXT := load('glGetVertexArrayPointeri_vEXT');
  glMapNamedBufferRangeEXT := load('glMapNamedBufferRangeEXT');
  glFlushMappedNamedBufferRangeEXT := load('glFlushMappedNamedBufferRangeEXT');
  glNamedBufferStorageEXT := load('glNamedBufferStorageEXT');
  glClearNamedBufferDataEXT := load('glClearNamedBufferDataEXT');
  glClearNamedBufferSubDataEXT := load('glClearNamedBufferSubDataEXT');
  glNamedFramebufferParameteriEXT := load('glNamedFramebufferParameteriEXT');
  glGetNamedFramebufferParameterivEXT := load('glGetNamedFramebufferParameterivEXT');
  glProgramUniform1dEXT := load('glProgramUniform1dEXT');
  glProgramUniform2dEXT := load('glProgramUniform2dEXT');
  glProgramUniform3dEXT := load('glProgramUniform3dEXT');
  glProgramUniform4dEXT := load('glProgramUniform4dEXT');
  glProgramUniform1dvEXT := load('glProgramUniform1dvEXT');
  glProgramUniform2dvEXT := load('glProgramUniform2dvEXT');
  glProgramUniform3dvEXT := load('glProgramUniform3dvEXT');
  glProgramUniform4dvEXT := load('glProgramUniform4dvEXT');
  glProgramUniformMatrix2dvEXT := load('glProgramUniformMatrix2dvEXT');
  glProgramUniformMatrix3dvEXT := load('glProgramUniformMatrix3dvEXT');
  glProgramUniformMatrix4dvEXT := load('glProgramUniformMatrix4dvEXT');
  glProgramUniformMatrix2x3dvEXT := load('glProgramUniformMatrix2x3dvEXT');
  glProgramUniformMatrix2x4dvEXT := load('glProgramUniformMatrix2x4dvEXT');
  glProgramUniformMatrix3x2dvEXT := load('glProgramUniformMatrix3x2dvEXT');
  glProgramUniformMatrix3x4dvEXT := load('glProgramUniformMatrix3x4dvEXT');
  glProgramUniformMatrix4x2dvEXT := load('glProgramUniformMatrix4x2dvEXT');
  glProgramUniformMatrix4x3dvEXT := load('glProgramUniformMatrix4x3dvEXT');
  glTextureBufferRangeEXT := load('glTextureBufferRangeEXT');
  glTextureStorage1DEXT := load('glTextureStorage1DEXT');
  glTextureStorage2DEXT := load('glTextureStorage2DEXT');
  glTextureStorage3DEXT := load('glTextureStorage3DEXT');
  glTextureStorage2DMultisampleEXT := load('glTextureStorage2DMultisampleEXT');
  glTextureStorage3DMultisampleEXT := load('glTextureStorage3DMultisampleEXT');
  glVertexArrayBindVertexBufferEXT := load('glVertexArrayBindVertexBufferEXT');
  glVertexArrayVertexAttribFormatEXT := load('glVertexArrayVertexAttribFormatEXT');
  glVertexArrayVertexAttribIFormatEXT := load('glVertexArrayVertexAttribIFormatEXT');
  glVertexArrayVertexAttribLFormatEXT := load('glVertexArrayVertexAttribLFormatEXT');
  glVertexArrayVertexAttribBindingEXT := load('glVertexArrayVertexAttribBindingEXT');
  glVertexArrayVertexBindingDivisorEXT := load('glVertexArrayVertexBindingDivisorEXT');
  glVertexArrayVertexAttribLOffsetEXT := load('glVertexArrayVertexAttribLOffsetEXT');
  glTexturePageCommitmentEXT := load('glTexturePageCommitmentEXT');
  glVertexArrayVertexAttribDivisorEXT := load('glVertexArrayVertexAttribDivisorEXT');
end;

procedure load_GL_EXT_draw_buffers2(load: TLoadProc);
begin
  if not GLAD_GL_EXT_draw_buffers2 then exit;
  glColorMaskIndexedEXT := load('glColorMaskIndexedEXT');
  glGetBooleanIndexedvEXT := load('glGetBooleanIndexedvEXT');
  glGetIntegerIndexedvEXT := load('glGetIntegerIndexedvEXT');
  glEnableIndexedEXT := load('glEnableIndexedEXT');
  glDisableIndexedEXT := load('glDisableIndexedEXT');
  glIsEnabledIndexedEXT := load('glIsEnabledIndexedEXT');
end;

procedure load_GL_EXT_draw_instanced(load: TLoadProc);
begin
  if not GLAD_GL_EXT_draw_instanced then exit;
  glDrawArraysInstancedEXT := load('glDrawArraysInstancedEXT');
  glDrawElementsInstancedEXT := load('glDrawElementsInstancedEXT');
end;

procedure load_GL_EXT_draw_range_elements(load: TLoadProc);
begin
  if not GLAD_GL_EXT_draw_range_elements then exit;
  glDrawRangeElementsEXT := load('glDrawRangeElementsEXT');
end;

procedure load_GL_EXT_external_buffer(load: TLoadProc);
begin
  if not GLAD_GL_EXT_external_buffer then exit;
  glBufferStorageExternalEXT := load('glBufferStorageExternalEXT');
  glNamedBufferStorageExternalEXT := load('glNamedBufferStorageExternalEXT');
end;

procedure load_GL_EXT_fog_coord(load: TLoadProc);
begin
  if not GLAD_GL_EXT_fog_coord then exit;
  glFogCoordfEXT := load('glFogCoordfEXT');
  glFogCoordfvEXT := load('glFogCoordfvEXT');
  glFogCoorddEXT := load('glFogCoorddEXT');
  glFogCoorddvEXT := load('glFogCoorddvEXT');
  glFogCoordPointerEXT := load('glFogCoordPointerEXT');
end;

procedure load_GL_EXT_framebuffer_blit(load: TLoadProc);
begin
  if not GLAD_GL_EXT_framebuffer_blit then exit;
  glBlitFramebufferEXT := load('glBlitFramebufferEXT');
end;

procedure load_GL_EXT_framebuffer_blit_layers(load: TLoadProc);
begin
  if not GLAD_GL_EXT_framebuffer_blit_layers then exit;
  glBlitFramebufferLayersEXT := load('glBlitFramebufferLayersEXT');
  glBlitFramebufferLayerEXT := load('glBlitFramebufferLayerEXT');
end;

procedure load_GL_EXT_framebuffer_multisample(load: TLoadProc);
begin
  if not GLAD_GL_EXT_framebuffer_multisample then exit;
  glRenderbufferStorageMultisampleEXT := load('glRenderbufferStorageMultisampleEXT');
end;

procedure load_GL_EXT_framebuffer_object(load: TLoadProc);
begin
  if not GLAD_GL_EXT_framebuffer_object then exit;
  glIsRenderbufferEXT := load('glIsRenderbufferEXT');
  glBindRenderbufferEXT := load('glBindRenderbufferEXT');
  glDeleteRenderbuffersEXT := load('glDeleteRenderbuffersEXT');
  glGenRenderbuffersEXT := load('glGenRenderbuffersEXT');
  glRenderbufferStorageEXT := load('glRenderbufferStorageEXT');
  glGetRenderbufferParameterivEXT := load('glGetRenderbufferParameterivEXT');
  glIsFramebufferEXT := load('glIsFramebufferEXT');
  glBindFramebufferEXT := load('glBindFramebufferEXT');
  glDeleteFramebuffersEXT := load('glDeleteFramebuffersEXT');
  glGenFramebuffersEXT := load('glGenFramebuffersEXT');
  glCheckFramebufferStatusEXT := load('glCheckFramebufferStatusEXT');
  glFramebufferTexture1DEXT := load('glFramebufferTexture1DEXT');
  glFramebufferTexture2DEXT := load('glFramebufferTexture2DEXT');
  glFramebufferTexture3DEXT := load('glFramebufferTexture3DEXT');
  glFramebufferRenderbufferEXT := load('glFramebufferRenderbufferEXT');
  glGetFramebufferAttachmentParameterivEXT := load('glGetFramebufferAttachmentParameterivEXT');
  glGenerateMipmapEXT := load('glGenerateMipmapEXT');
end;

procedure load_GL_EXT_geometry_shader4(load: TLoadProc);
begin
  if not GLAD_GL_EXT_geometry_shader4 then exit;
  glProgramParameteriEXT := load('glProgramParameteriEXT');
end;

procedure load_GL_EXT_gpu_program_parameters(load: TLoadProc);
begin
  if not GLAD_GL_EXT_gpu_program_parameters then exit;
  glProgramEnvParameters4fvEXT := load('glProgramEnvParameters4fvEXT');
  glProgramLocalParameters4fvEXT := load('glProgramLocalParameters4fvEXT');
end;

procedure load_GL_EXT_gpu_shader4(load: TLoadProc);
begin
  if not GLAD_GL_EXT_gpu_shader4 then exit;
  glGetUniformuivEXT := load('glGetUniformuivEXT');
  glBindFragDataLocationEXT := load('glBindFragDataLocationEXT');
  glGetFragDataLocationEXT := load('glGetFragDataLocationEXT');
  glUniform1uiEXT := load('glUniform1uiEXT');
  glUniform2uiEXT := load('glUniform2uiEXT');
  glUniform3uiEXT := load('glUniform3uiEXT');
  glUniform4uiEXT := load('glUniform4uiEXT');
  glUniform1uivEXT := load('glUniform1uivEXT');
  glUniform2uivEXT := load('glUniform2uivEXT');
  glUniform3uivEXT := load('glUniform3uivEXT');
  glUniform4uivEXT := load('glUniform4uivEXT');
  glVertexAttribI1iEXT := load('glVertexAttribI1iEXT');
  glVertexAttribI2iEXT := load('glVertexAttribI2iEXT');
  glVertexAttribI3iEXT := load('glVertexAttribI3iEXT');
  glVertexAttribI4iEXT := load('glVertexAttribI4iEXT');
  glVertexAttribI1uiEXT := load('glVertexAttribI1uiEXT');
  glVertexAttribI2uiEXT := load('glVertexAttribI2uiEXT');
  glVertexAttribI3uiEXT := load('glVertexAttribI3uiEXT');
  glVertexAttribI4uiEXT := load('glVertexAttribI4uiEXT');
  glVertexAttribI1ivEXT := load('glVertexAttribI1ivEXT');
  glVertexAttribI2ivEXT := load('glVertexAttribI2ivEXT');
  glVertexAttribI3ivEXT := load('glVertexAttribI3ivEXT');
  glVertexAttribI4ivEXT := load('glVertexAttribI4ivEXT');
  glVertexAttribI1uivEXT := load('glVertexAttribI1uivEXT');
  glVertexAttribI2uivEXT := load('glVertexAttribI2uivEXT');
  glVertexAttribI3uivEXT := load('glVertexAttribI3uivEXT');
  glVertexAttribI4uivEXT := load('glVertexAttribI4uivEXT');
  glVertexAttribI4bvEXT := load('glVertexAttribI4bvEXT');
  glVertexAttribI4svEXT := load('glVertexAttribI4svEXT');
  glVertexAttribI4ubvEXT := load('glVertexAttribI4ubvEXT');
  glVertexAttribI4usvEXT := load('glVertexAttribI4usvEXT');
  glVertexAttribIPointerEXT := load('glVertexAttribIPointerEXT');
  glGetVertexAttribIivEXT := load('glGetVertexAttribIivEXT');
  glGetVertexAttribIuivEXT := load('glGetVertexAttribIuivEXT');
end;

procedure load_GL_EXT_histogram(load: TLoadProc);
begin
  if not GLAD_GL_EXT_histogram then exit;
  glGetHistogramEXT := load('glGetHistogramEXT');
  glGetHistogramParameterfvEXT := load('glGetHistogramParameterfvEXT');
  glGetHistogramParameterivEXT := load('glGetHistogramParameterivEXT');
  glGetMinmaxEXT := load('glGetMinmaxEXT');
  glGetMinmaxParameterfvEXT := load('glGetMinmaxParameterfvEXT');
  glGetMinmaxParameterivEXT := load('glGetMinmaxParameterivEXT');
  glHistogramEXT := load('glHistogramEXT');
  glMinmaxEXT := load('glMinmaxEXT');
  glResetHistogramEXT := load('glResetHistogramEXT');
  glResetMinmaxEXT := load('glResetMinmaxEXT');
end;

procedure load_GL_EXT_index_func(load: TLoadProc);
begin
  if not GLAD_GL_EXT_index_func then exit;
  glIndexFuncEXT := load('glIndexFuncEXT');
end;

procedure load_GL_EXT_index_material(load: TLoadProc);
begin
  if not GLAD_GL_EXT_index_material then exit;
  glIndexMaterialEXT := load('glIndexMaterialEXT');
end;

procedure load_GL_EXT_light_texture(load: TLoadProc);
begin
  if not GLAD_GL_EXT_light_texture then exit;
  glApplyTextureEXT := load('glApplyTextureEXT');
  glTextureLightEXT := load('glTextureLightEXT');
  glTextureMaterialEXT := load('glTextureMaterialEXT');
end;

procedure load_GL_EXT_memory_object(load: TLoadProc);
begin
  if not GLAD_GL_EXT_memory_object then exit;
  glGetUnsignedBytevEXT := load('glGetUnsignedBytevEXT');
  glGetUnsignedBytei_vEXT := load('glGetUnsignedBytei_vEXT');
  glDeleteMemoryObjectsEXT := load('glDeleteMemoryObjectsEXT');
  glIsMemoryObjectEXT := load('glIsMemoryObjectEXT');
  glCreateMemoryObjectsEXT := load('glCreateMemoryObjectsEXT');
  glMemoryObjectParameterivEXT := load('glMemoryObjectParameterivEXT');
  glGetMemoryObjectParameterivEXT := load('glGetMemoryObjectParameterivEXT');
  glTexStorageMem2DEXT := load('glTexStorageMem2DEXT');
  glTexStorageMem2DMultisampleEXT := load('glTexStorageMem2DMultisampleEXT');
  glTexStorageMem3DEXT := load('glTexStorageMem3DEXT');
  glTexStorageMem3DMultisampleEXT := load('glTexStorageMem3DMultisampleEXT');
  glBufferStorageMemEXT := load('glBufferStorageMemEXT');
  glTextureStorageMem2DEXT := load('glTextureStorageMem2DEXT');
  glTextureStorageMem2DMultisampleEXT := load('glTextureStorageMem2DMultisampleEXT');
  glTextureStorageMem3DEXT := load('glTextureStorageMem3DEXT');
  glTextureStorageMem3DMultisampleEXT := load('glTextureStorageMem3DMultisampleEXT');
  glNamedBufferStorageMemEXT := load('glNamedBufferStorageMemEXT');
  glTexStorageMem1DEXT := load('glTexStorageMem1DEXT');
  glTextureStorageMem1DEXT := load('glTextureStorageMem1DEXT');
end;

procedure load_GL_EXT_memory_object_fd(load: TLoadProc);
begin
  if not GLAD_GL_EXT_memory_object_fd then exit;
  glImportMemoryFdEXT := load('glImportMemoryFdEXT');
end;

procedure load_GL_EXT_memory_object_win32(load: TLoadProc);
begin
  if not GLAD_GL_EXT_memory_object_win32 then exit;
  glImportMemoryWin32HandleEXT := load('glImportMemoryWin32HandleEXT');
  glImportMemoryWin32NameEXT := load('glImportMemoryWin32NameEXT');
end;

procedure load_GL_EXT_multi_draw_arrays(load: TLoadProc);
begin
  if not GLAD_GL_EXT_multi_draw_arrays then exit;
  glMultiDrawArraysEXT := load('glMultiDrawArraysEXT');
  glMultiDrawElementsEXT := load('glMultiDrawElementsEXT');
end;

procedure load_GL_EXT_multisample(load: TLoadProc);
begin
  if not GLAD_GL_EXT_multisample then exit;
  glSampleMaskEXT := load('glSampleMaskEXT');
  glSamplePatternEXT := load('glSamplePatternEXT');
end;

procedure load_GL_EXT_paletted_texture(load: TLoadProc);
begin
  if not GLAD_GL_EXT_paletted_texture then exit;
  glColorTableEXT := load('glColorTableEXT');
  glGetColorTableEXT := load('glGetColorTableEXT');
  glGetColorTableParameterivEXT := load('glGetColorTableParameterivEXT');
  glGetColorTableParameterfvEXT := load('glGetColorTableParameterfvEXT');
end;

procedure load_GL_EXT_pixel_transform(load: TLoadProc);
begin
  if not GLAD_GL_EXT_pixel_transform then exit;
  glPixelTransformParameteriEXT := load('glPixelTransformParameteriEXT');
  glPixelTransformParameterfEXT := load('glPixelTransformParameterfEXT');
  glPixelTransformParameterivEXT := load('glPixelTransformParameterivEXT');
  glPixelTransformParameterfvEXT := load('glPixelTransformParameterfvEXT');
  glGetPixelTransformParameterivEXT := load('glGetPixelTransformParameterivEXT');
  glGetPixelTransformParameterfvEXT := load('glGetPixelTransformParameterfvEXT');
end;

procedure load_GL_EXT_point_parameters(load: TLoadProc);
begin
  if not GLAD_GL_EXT_point_parameters then exit;
  glPointParameterfEXT := load('glPointParameterfEXT');
  glPointParameterfvEXT := load('glPointParameterfvEXT');
end;

procedure load_GL_EXT_polygon_offset(load: TLoadProc);
begin
  if not GLAD_GL_EXT_polygon_offset then exit;
  glPolygonOffsetEXT := load('glPolygonOffsetEXT');
end;

procedure load_GL_EXT_polygon_offset_clamp(load: TLoadProc);
begin
  if not GLAD_GL_EXT_polygon_offset_clamp then exit;
  glPolygonOffsetClampEXT := load('glPolygonOffsetClampEXT');
end;

procedure load_GL_EXT_provoking_vertex(load: TLoadProc);
begin
  if not GLAD_GL_EXT_provoking_vertex then exit;
  glProvokingVertexEXT := load('glProvokingVertexEXT');
end;

procedure load_GL_EXT_raster_multisample(load: TLoadProc);
begin
  if not GLAD_GL_EXT_raster_multisample then exit;
  glRasterSamplesEXT := load('glRasterSamplesEXT');
end;

procedure load_GL_EXT_secondary_color(load: TLoadProc);
begin
  if not GLAD_GL_EXT_secondary_color then exit;
  glSecondaryColor3bEXT := load('glSecondaryColor3bEXT');
  glSecondaryColor3bvEXT := load('glSecondaryColor3bvEXT');
  glSecondaryColor3dEXT := load('glSecondaryColor3dEXT');
  glSecondaryColor3dvEXT := load('glSecondaryColor3dvEXT');
  glSecondaryColor3fEXT := load('glSecondaryColor3fEXT');
  glSecondaryColor3fvEXT := load('glSecondaryColor3fvEXT');
  glSecondaryColor3iEXT := load('glSecondaryColor3iEXT');
  glSecondaryColor3ivEXT := load('glSecondaryColor3ivEXT');
  glSecondaryColor3sEXT := load('glSecondaryColor3sEXT');
  glSecondaryColor3svEXT := load('glSecondaryColor3svEXT');
  glSecondaryColor3ubEXT := load('glSecondaryColor3ubEXT');
  glSecondaryColor3ubvEXT := load('glSecondaryColor3ubvEXT');
  glSecondaryColor3uiEXT := load('glSecondaryColor3uiEXT');
  glSecondaryColor3uivEXT := load('glSecondaryColor3uivEXT');
  glSecondaryColor3usEXT := load('glSecondaryColor3usEXT');
  glSecondaryColor3usvEXT := load('glSecondaryColor3usvEXT');
  glSecondaryColorPointerEXT := load('glSecondaryColorPointerEXT');
end;

procedure load_GL_EXT_semaphore(load: TLoadProc);
begin
  if not GLAD_GL_EXT_semaphore then exit;
  glGetUnsignedBytevEXT := load('glGetUnsignedBytevEXT');
  glGetUnsignedBytei_vEXT := load('glGetUnsignedBytei_vEXT');
  glGenSemaphoresEXT := load('glGenSemaphoresEXT');
  glDeleteSemaphoresEXT := load('glDeleteSemaphoresEXT');
  glIsSemaphoreEXT := load('glIsSemaphoreEXT');
  glSemaphoreParameterui64vEXT := load('glSemaphoreParameterui64vEXT');
  glGetSemaphoreParameterui64vEXT := load('glGetSemaphoreParameterui64vEXT');
  glWaitSemaphoreEXT := load('glWaitSemaphoreEXT');
  glSignalSemaphoreEXT := load('glSignalSemaphoreEXT');
end;

procedure load_GL_EXT_semaphore_fd(load: TLoadProc);
begin
  if not GLAD_GL_EXT_semaphore_fd then exit;
  glImportSemaphoreFdEXT := load('glImportSemaphoreFdEXT');
end;

procedure load_GL_EXT_semaphore_win32(load: TLoadProc);
begin
  if not GLAD_GL_EXT_semaphore_win32 then exit;
  glImportSemaphoreWin32HandleEXT := load('glImportSemaphoreWin32HandleEXT');
  glImportSemaphoreWin32NameEXT := load('glImportSemaphoreWin32NameEXT');
end;

procedure load_GL_EXT_separate_shader_objects(load: TLoadProc);
begin
  if not GLAD_GL_EXT_separate_shader_objects then exit;
  glUseShaderProgramEXT := load('glUseShaderProgramEXT');
  glActiveProgramEXT := load('glActiveProgramEXT');
  glCreateShaderProgramEXT := load('glCreateShaderProgramEXT');
  glActiveShaderProgramEXT := load('glActiveShaderProgramEXT');
  glBindProgramPipelineEXT := load('glBindProgramPipelineEXT');
  glCreateShaderProgramvEXT := load('glCreateShaderProgramvEXT');
  glDeleteProgramPipelinesEXT := load('glDeleteProgramPipelinesEXT');
  glGenProgramPipelinesEXT := load('glGenProgramPipelinesEXT');
  glGetProgramPipelineInfoLogEXT := load('glGetProgramPipelineInfoLogEXT');
  glGetProgramPipelineivEXT := load('glGetProgramPipelineivEXT');
  glIsProgramPipelineEXT := load('glIsProgramPipelineEXT');
  glProgramParameteriEXT := load('glProgramParameteriEXT');
  glProgramUniform1fEXT := load('glProgramUniform1fEXT');
  glProgramUniform1fvEXT := load('glProgramUniform1fvEXT');
  glProgramUniform1iEXT := load('glProgramUniform1iEXT');
  glProgramUniform1ivEXT := load('glProgramUniform1ivEXT');
  glProgramUniform2fEXT := load('glProgramUniform2fEXT');
  glProgramUniform2fvEXT := load('glProgramUniform2fvEXT');
  glProgramUniform2iEXT := load('glProgramUniform2iEXT');
  glProgramUniform2ivEXT := load('glProgramUniform2ivEXT');
  glProgramUniform3fEXT := load('glProgramUniform3fEXT');
  glProgramUniform3fvEXT := load('glProgramUniform3fvEXT');
  glProgramUniform3iEXT := load('glProgramUniform3iEXT');
  glProgramUniform3ivEXT := load('glProgramUniform3ivEXT');
  glProgramUniform4fEXT := load('glProgramUniform4fEXT');
  glProgramUniform4fvEXT := load('glProgramUniform4fvEXT');
  glProgramUniform4iEXT := load('glProgramUniform4iEXT');
  glProgramUniform4ivEXT := load('glProgramUniform4ivEXT');
  glProgramUniformMatrix2fvEXT := load('glProgramUniformMatrix2fvEXT');
  glProgramUniformMatrix3fvEXT := load('glProgramUniformMatrix3fvEXT');
  glProgramUniformMatrix4fvEXT := load('glProgramUniformMatrix4fvEXT');
  glUseProgramStagesEXT := load('glUseProgramStagesEXT');
  glValidateProgramPipelineEXT := load('glValidateProgramPipelineEXT');
  glProgramUniform1uiEXT := load('glProgramUniform1uiEXT');
  glProgramUniform2uiEXT := load('glProgramUniform2uiEXT');
  glProgramUniform3uiEXT := load('glProgramUniform3uiEXT');
  glProgramUniform4uiEXT := load('glProgramUniform4uiEXT');
  glProgramUniform1uivEXT := load('glProgramUniform1uivEXT');
  glProgramUniform2uivEXT := load('glProgramUniform2uivEXT');
  glProgramUniform3uivEXT := load('glProgramUniform3uivEXT');
  glProgramUniform4uivEXT := load('glProgramUniform4uivEXT');
  glProgramUniformMatrix2x3fvEXT := load('glProgramUniformMatrix2x3fvEXT');
  glProgramUniformMatrix3x2fvEXT := load('glProgramUniformMatrix3x2fvEXT');
  glProgramUniformMatrix2x4fvEXT := load('glProgramUniformMatrix2x4fvEXT');
  glProgramUniformMatrix4x2fvEXT := load('glProgramUniformMatrix4x2fvEXT');
  glProgramUniformMatrix3x4fvEXT := load('glProgramUniformMatrix3x4fvEXT');
  glProgramUniformMatrix4x3fvEXT := load('glProgramUniformMatrix4x3fvEXT');
end;

procedure load_GL_EXT_shader_framebuffer_fetch_non_coherent(load: TLoadProc);
begin
  if not GLAD_GL_EXT_shader_framebuffer_fetch_non_coherent then exit;
  glFramebufferFetchBarrierEXT := load('glFramebufferFetchBarrierEXT');
end;

procedure load_GL_EXT_shader_image_load_store(load: TLoadProc);
begin
  if not GLAD_GL_EXT_shader_image_load_store then exit;
  glBindImageTextureEXT := load('glBindImageTextureEXT');
  glMemoryBarrierEXT := load('glMemoryBarrierEXT');
end;

procedure load_GL_EXT_stencil_clear_tag(load: TLoadProc);
begin
  if not GLAD_GL_EXT_stencil_clear_tag then exit;
  glStencilClearTagEXT := load('glStencilClearTagEXT');
end;

procedure load_GL_EXT_stencil_two_side(load: TLoadProc);
begin
  if not GLAD_GL_EXT_stencil_two_side then exit;
  glActiveStencilFaceEXT := load('glActiveStencilFaceEXT');
end;

procedure load_GL_EXT_subtexture(load: TLoadProc);
begin
  if not GLAD_GL_EXT_subtexture then exit;
  glTexSubImage1DEXT := load('glTexSubImage1DEXT');
  glTexSubImage2DEXT := load('glTexSubImage2DEXT');
end;

procedure load_GL_EXT_texture3D(load: TLoadProc);
begin
  if not GLAD_GL_EXT_texture3D then exit;
  glTexImage3DEXT := load('glTexImage3DEXT');
  glTexSubImage3DEXT := load('glTexSubImage3DEXT');
end;

procedure load_GL_EXT_texture_array(load: TLoadProc);
begin
  if not GLAD_GL_EXT_texture_array then exit;
  glFramebufferTextureLayerEXT := load('glFramebufferTextureLayerEXT');
end;

procedure load_GL_EXT_texture_buffer_object(load: TLoadProc);
begin
  if not GLAD_GL_EXT_texture_buffer_object then exit;
  glTexBufferEXT := load('glTexBufferEXT');
end;

procedure load_GL_EXT_texture_integer(load: TLoadProc);
begin
  if not GLAD_GL_EXT_texture_integer then exit;
  glTexParameterIivEXT := load('glTexParameterIivEXT');
  glTexParameterIuivEXT := load('glTexParameterIuivEXT');
  glGetTexParameterIivEXT := load('glGetTexParameterIivEXT');
  glGetTexParameterIuivEXT := load('glGetTexParameterIuivEXT');
  glClearColorIiEXT := load('glClearColorIiEXT');
  glClearColorIuiEXT := load('glClearColorIuiEXT');
end;

procedure load_GL_EXT_texture_object(load: TLoadProc);
begin
  if not GLAD_GL_EXT_texture_object then exit;
  glAreTexturesResidentEXT := load('glAreTexturesResidentEXT');
  glBindTextureEXT := load('glBindTextureEXT');
  glDeleteTexturesEXT := load('glDeleteTexturesEXT');
  glGenTexturesEXT := load('glGenTexturesEXT');
  glIsTextureEXT := load('glIsTextureEXT');
  glPrioritizeTexturesEXT := load('glPrioritizeTexturesEXT');
end;

procedure load_GL_EXT_texture_perturb_normal(load: TLoadProc);
begin
  if not GLAD_GL_EXT_texture_perturb_normal then exit;
  glTextureNormalEXT := load('glTextureNormalEXT');
end;

procedure load_GL_EXT_texture_storage(load: TLoadProc);
begin
  if not GLAD_GL_EXT_texture_storage then exit;
  glTexStorage1DEXT := load('glTexStorage1DEXT');
  glTexStorage2DEXT := load('glTexStorage2DEXT');
  glTexStorage3DEXT := load('glTexStorage3DEXT');
  glTextureStorage1DEXT := load('glTextureStorage1DEXT');
  glTextureStorage2DEXT := load('glTextureStorage2DEXT');
  glTextureStorage3DEXT := load('glTextureStorage3DEXT');
end;

procedure load_GL_EXT_timer_query(load: TLoadProc);
begin
  if not GLAD_GL_EXT_timer_query then exit;
  glGetQueryObjecti64vEXT := load('glGetQueryObjecti64vEXT');
  glGetQueryObjectui64vEXT := load('glGetQueryObjectui64vEXT');
end;

procedure load_GL_EXT_transform_feedback(load: TLoadProc);
begin
  if not GLAD_GL_EXT_transform_feedback then exit;
  glBeginTransformFeedbackEXT := load('glBeginTransformFeedbackEXT');
  glEndTransformFeedbackEXT := load('glEndTransformFeedbackEXT');
  glBindBufferRangeEXT := load('glBindBufferRangeEXT');
  glBindBufferOffsetEXT := load('glBindBufferOffsetEXT');
  glBindBufferBaseEXT := load('glBindBufferBaseEXT');
  glTransformFeedbackVaryingsEXT := load('glTransformFeedbackVaryingsEXT');
  glGetTransformFeedbackVaryingEXT := load('glGetTransformFeedbackVaryingEXT');
end;

procedure load_GL_EXT_vertex_array(load: TLoadProc);
begin
  if not GLAD_GL_EXT_vertex_array then exit;
  glArrayElementEXT := load('glArrayElementEXT');
  glColorPointerEXT := load('glColorPointerEXT');
  glDrawArraysEXT := load('glDrawArraysEXT');
  glEdgeFlagPointerEXT := load('glEdgeFlagPointerEXT');
  glGetPointervEXT := load('glGetPointervEXT');
  glIndexPointerEXT := load('glIndexPointerEXT');
  glNormalPointerEXT := load('glNormalPointerEXT');
  glTexCoordPointerEXT := load('glTexCoordPointerEXT');
  glVertexPointerEXT := load('glVertexPointerEXT');
end;

procedure load_GL_EXT_vertex_attrib_64bit(load: TLoadProc);
begin
  if not GLAD_GL_EXT_vertex_attrib_64bit then exit;
  glVertexAttribL1dEXT := load('glVertexAttribL1dEXT');
  glVertexAttribL2dEXT := load('glVertexAttribL2dEXT');
  glVertexAttribL3dEXT := load('glVertexAttribL3dEXT');
  glVertexAttribL4dEXT := load('glVertexAttribL4dEXT');
  glVertexAttribL1dvEXT := load('glVertexAttribL1dvEXT');
  glVertexAttribL2dvEXT := load('glVertexAttribL2dvEXT');
  glVertexAttribL3dvEXT := load('glVertexAttribL3dvEXT');
  glVertexAttribL4dvEXT := load('glVertexAttribL4dvEXT');
  glVertexAttribLPointerEXT := load('glVertexAttribLPointerEXT');
  glGetVertexAttribLdvEXT := load('glGetVertexAttribLdvEXT');
end;

procedure load_GL_EXT_vertex_shader(load: TLoadProc);
begin
  if not GLAD_GL_EXT_vertex_shader then exit;
  glBeginVertexShaderEXT := load('glBeginVertexShaderEXT');
  glEndVertexShaderEXT := load('glEndVertexShaderEXT');
  glBindVertexShaderEXT := load('glBindVertexShaderEXT');
  glGenVertexShadersEXT := load('glGenVertexShadersEXT');
  glDeleteVertexShaderEXT := load('glDeleteVertexShaderEXT');
  glShaderOp1EXT := load('glShaderOp1EXT');
  glShaderOp2EXT := load('glShaderOp2EXT');
  glShaderOp3EXT := load('glShaderOp3EXT');
  glSwizzleEXT := load('glSwizzleEXT');
  glWriteMaskEXT := load('glWriteMaskEXT');
  glInsertComponentEXT := load('glInsertComponentEXT');
  glExtractComponentEXT := load('glExtractComponentEXT');
  glGenSymbolsEXT := load('glGenSymbolsEXT');
  glSetInvariantEXT := load('glSetInvariantEXT');
  glSetLocalConstantEXT := load('glSetLocalConstantEXT');
  glVariantbvEXT := load('glVariantbvEXT');
  glVariantsvEXT := load('glVariantsvEXT');
  glVariantivEXT := load('glVariantivEXT');
  glVariantfvEXT := load('glVariantfvEXT');
  glVariantdvEXT := load('glVariantdvEXT');
  glVariantubvEXT := load('glVariantubvEXT');
  glVariantusvEXT := load('glVariantusvEXT');
  glVariantuivEXT := load('glVariantuivEXT');
  glVariantPointerEXT := load('glVariantPointerEXT');
  glEnableVariantClientStateEXT := load('glEnableVariantClientStateEXT');
  glDisableVariantClientStateEXT := load('glDisableVariantClientStateEXT');
  glBindLightParameterEXT := load('glBindLightParameterEXT');
  glBindMaterialParameterEXT := load('glBindMaterialParameterEXT');
  glBindTexGenParameterEXT := load('glBindTexGenParameterEXT');
  glBindTextureUnitParameterEXT := load('glBindTextureUnitParameterEXT');
  glBindParameterEXT := load('glBindParameterEXT');
  glIsVariantEnabledEXT := load('glIsVariantEnabledEXT');
  glGetVariantBooleanvEXT := load('glGetVariantBooleanvEXT');
  glGetVariantIntegervEXT := load('glGetVariantIntegervEXT');
  glGetVariantFloatvEXT := load('glGetVariantFloatvEXT');
  glGetVariantPointervEXT := load('glGetVariantPointervEXT');
  glGetInvariantBooleanvEXT := load('glGetInvariantBooleanvEXT');
  glGetInvariantIntegervEXT := load('glGetInvariantIntegervEXT');
  glGetInvariantFloatvEXT := load('glGetInvariantFloatvEXT');
  glGetLocalConstantBooleanvEXT := load('glGetLocalConstantBooleanvEXT');
  glGetLocalConstantIntegervEXT := load('glGetLocalConstantIntegervEXT');
  glGetLocalConstantFloatvEXT := load('glGetLocalConstantFloatvEXT');
end;

procedure load_GL_EXT_vertex_weighting(load: TLoadProc);
begin
  if not GLAD_GL_EXT_vertex_weighting then exit;
  glVertexWeightfEXT := load('glVertexWeightfEXT');
  glVertexWeightfvEXT := load('glVertexWeightfvEXT');
  glVertexWeightPointerEXT := load('glVertexWeightPointerEXT');
end;

procedure load_GL_EXT_win32_keyed_mutex(load: TLoadProc);
begin
  if not GLAD_GL_EXT_win32_keyed_mutex then exit;
  glAcquireKeyedMutexWin32EXT := load('glAcquireKeyedMutexWin32EXT');
  glReleaseKeyedMutexWin32EXT := load('glReleaseKeyedMutexWin32EXT');
end;

procedure load_GL_EXT_window_rectangles(load: TLoadProc);
begin
  if not GLAD_GL_EXT_window_rectangles then exit;
  glWindowRectanglesEXT := load('glWindowRectanglesEXT');
end;

procedure load_GL_EXT_x11_sync_object(load: TLoadProc);
begin
  if not GLAD_GL_EXT_x11_sync_object then exit;
  glImportSyncEXT := load('glImportSyncEXT');
end;

procedure load_GL_GREMEDY_frame_terminator(load: TLoadProc);
begin
  if not GLAD_GL_GREMEDY_frame_terminator then exit;
  glFrameTerminatorGREMEDY := load('glFrameTerminatorGREMEDY');
end;

procedure load_GL_GREMEDY_string_marker(load: TLoadProc);
begin
  if not GLAD_GL_GREMEDY_string_marker then exit;
  glStringMarkerGREMEDY := load('glStringMarkerGREMEDY');
end;

procedure load_GL_HP_image_transform(load: TLoadProc);
begin
  if not GLAD_GL_HP_image_transform then exit;
  glImageTransformParameteriHP := load('glImageTransformParameteriHP');
  glImageTransformParameterfHP := load('glImageTransformParameterfHP');
  glImageTransformParameterivHP := load('glImageTransformParameterivHP');
  glImageTransformParameterfvHP := load('glImageTransformParameterfvHP');
  glGetImageTransformParameterivHP := load('glGetImageTransformParameterivHP');
  glGetImageTransformParameterfvHP := load('glGetImageTransformParameterfvHP');
end;

procedure load_GL_IBM_multimode_draw_arrays(load: TLoadProc);
begin
  if not GLAD_GL_IBM_multimode_draw_arrays then exit;
  glMultiModeDrawArraysIBM := load('glMultiModeDrawArraysIBM');
  glMultiModeDrawElementsIBM := load('glMultiModeDrawElementsIBM');
end;

procedure load_GL_IBM_static_data(load: TLoadProc);
begin
  if not GLAD_GL_IBM_static_data then exit;
  glFlushStaticDataIBM := load('glFlushStaticDataIBM');
end;

procedure load_GL_IBM_vertex_array_lists(load: TLoadProc);
begin
  if not GLAD_GL_IBM_vertex_array_lists then exit;
  glColorPointerListIBM := load('glColorPointerListIBM');
  glSecondaryColorPointerListIBM := load('glSecondaryColorPointerListIBM');
  glEdgeFlagPointerListIBM := load('glEdgeFlagPointerListIBM');
  glFogCoordPointerListIBM := load('glFogCoordPointerListIBM');
  glIndexPointerListIBM := load('glIndexPointerListIBM');
  glNormalPointerListIBM := load('glNormalPointerListIBM');
  glTexCoordPointerListIBM := load('glTexCoordPointerListIBM');
  glVertexPointerListIBM := load('glVertexPointerListIBM');
end;

procedure load_GL_INGR_blend_func_separate(load: TLoadProc);
begin
  if not GLAD_GL_INGR_blend_func_separate then exit;
  glBlendFuncSeparateINGR := load('glBlendFuncSeparateINGR');
end;

procedure load_GL_INTEL_framebuffer_CMAA(load: TLoadProc);
begin
  if not GLAD_GL_INTEL_framebuffer_CMAA then exit;
  glApplyFramebufferAttachmentCMAAINTEL := load('glApplyFramebufferAttachmentCMAAINTEL');
end;

procedure load_GL_INTEL_map_texture(load: TLoadProc);
begin
  if not GLAD_GL_INTEL_map_texture then exit;
  glSyncTextureINTEL := load('glSyncTextureINTEL');
  glUnmapTexture2DINTEL := load('glUnmapTexture2DINTEL');
  glMapTexture2DINTEL := load('glMapTexture2DINTEL');
end;

procedure load_GL_INTEL_parallel_arrays(load: TLoadProc);
begin
  if not GLAD_GL_INTEL_parallel_arrays then exit;
  glVertexPointervINTEL := load('glVertexPointervINTEL');
  glNormalPointervINTEL := load('glNormalPointervINTEL');
  glColorPointervINTEL := load('glColorPointervINTEL');
  glTexCoordPointervINTEL := load('glTexCoordPointervINTEL');
end;

procedure load_GL_INTEL_performance_query(load: TLoadProc);
begin
  if not GLAD_GL_INTEL_performance_query then exit;
  glBeginPerfQueryINTEL := load('glBeginPerfQueryINTEL');
  glCreatePerfQueryINTEL := load('glCreatePerfQueryINTEL');
  glDeletePerfQueryINTEL := load('glDeletePerfQueryINTEL');
  glEndPerfQueryINTEL := load('glEndPerfQueryINTEL');
  glGetFirstPerfQueryIdINTEL := load('glGetFirstPerfQueryIdINTEL');
  glGetNextPerfQueryIdINTEL := load('glGetNextPerfQueryIdINTEL');
  glGetPerfCounterInfoINTEL := load('glGetPerfCounterInfoINTEL');
  glGetPerfQueryDataINTEL := load('glGetPerfQueryDataINTEL');
  glGetPerfQueryIdByNameINTEL := load('glGetPerfQueryIdByNameINTEL');
  glGetPerfQueryInfoINTEL := load('glGetPerfQueryInfoINTEL');
end;

procedure load_GL_KHR_blend_equation_advanced(load: TLoadProc);
begin
  if not GLAD_GL_KHR_blend_equation_advanced then exit;
  glBlendBarrierKHR := load('glBlendBarrierKHR');
end;

procedure load_GL_KHR_debug(load: TLoadProc);
begin
  if not GLAD_GL_KHR_debug then exit;
  glDebugMessageControl := load('glDebugMessageControl');
  glDebugMessageInsert := load('glDebugMessageInsert');
  glDebugMessageCallback := load('glDebugMessageCallback');
  glGetDebugMessageLog := load('glGetDebugMessageLog');
  glPushDebugGroup := load('glPushDebugGroup');
  glPopDebugGroup := load('glPopDebugGroup');
  glObjectLabel := load('glObjectLabel');
  glGetObjectLabel := load('glGetObjectLabel');
  glObjectPtrLabel := load('glObjectPtrLabel');
  glGetObjectPtrLabel := load('glGetObjectPtrLabel');
  glGetPointerv := load('glGetPointerv');
  glDebugMessageControlKHR := load('glDebugMessageControlKHR');
  glDebugMessageInsertKHR := load('glDebugMessageInsertKHR');
  glDebugMessageCallbackKHR := load('glDebugMessageCallbackKHR');
  glGetDebugMessageLogKHR := load('glGetDebugMessageLogKHR');
  glPushDebugGroupKHR := load('glPushDebugGroupKHR');
  glPopDebugGroupKHR := load('glPopDebugGroupKHR');
  glObjectLabelKHR := load('glObjectLabelKHR');
  glGetObjectLabelKHR := load('glGetObjectLabelKHR');
  glObjectPtrLabelKHR := load('glObjectPtrLabelKHR');
  glGetObjectPtrLabelKHR := load('glGetObjectPtrLabelKHR');
  glGetPointervKHR := load('glGetPointervKHR');
end;

procedure load_GL_KHR_parallel_shader_compile(load: TLoadProc);
begin
  if not GLAD_GL_KHR_parallel_shader_compile then exit;
  glMaxShaderCompilerThreadsKHR := load('glMaxShaderCompilerThreadsKHR');
end;

procedure load_GL_KHR_robustness(load: TLoadProc);
begin
  if not GLAD_GL_KHR_robustness then exit;
  glGetGraphicsResetStatus := load('glGetGraphicsResetStatus');
  glReadnPixels := load('glReadnPixels');
  glGetnUniformfv := load('glGetnUniformfv');
  glGetnUniformiv := load('glGetnUniformiv');
  glGetnUniformuiv := load('glGetnUniformuiv');
  glGetGraphicsResetStatusKHR := load('glGetGraphicsResetStatusKHR');
  glReadnPixelsKHR := load('glReadnPixelsKHR');
  glGetnUniformfvKHR := load('glGetnUniformfvKHR');
  glGetnUniformivKHR := load('glGetnUniformivKHR');
  glGetnUniformuivKHR := load('glGetnUniformuivKHR');
end;

procedure load_GL_MESA_framebuffer_flip_y(load: TLoadProc);
begin
  if not GLAD_GL_MESA_framebuffer_flip_y then exit;
  glFramebufferParameteriMESA := load('glFramebufferParameteriMESA');
  glGetFramebufferParameterivMESA := load('glGetFramebufferParameterivMESA');
end;

procedure load_GL_MESA_resize_buffers(load: TLoadProc);
begin
  if not GLAD_GL_MESA_resize_buffers then exit;
  glResizeBuffersMESA := load('glResizeBuffersMESA');
end;

procedure load_GL_MESA_window_pos(load: TLoadProc);
begin
  if not GLAD_GL_MESA_window_pos then exit;
  glWindowPos2dMESA := load('glWindowPos2dMESA');
  glWindowPos2dvMESA := load('glWindowPos2dvMESA');
  glWindowPos2fMESA := load('glWindowPos2fMESA');
  glWindowPos2fvMESA := load('glWindowPos2fvMESA');
  glWindowPos2iMESA := load('glWindowPos2iMESA');
  glWindowPos2ivMESA := load('glWindowPos2ivMESA');
  glWindowPos2sMESA := load('glWindowPos2sMESA');
  glWindowPos2svMESA := load('glWindowPos2svMESA');
  glWindowPos3dMESA := load('glWindowPos3dMESA');
  glWindowPos3dvMESA := load('glWindowPos3dvMESA');
  glWindowPos3fMESA := load('glWindowPos3fMESA');
  glWindowPos3fvMESA := load('glWindowPos3fvMESA');
  glWindowPos3iMESA := load('glWindowPos3iMESA');
  glWindowPos3ivMESA := load('glWindowPos3ivMESA');
  glWindowPos3sMESA := load('glWindowPos3sMESA');
  glWindowPos3svMESA := load('glWindowPos3svMESA');
  glWindowPos4dMESA := load('glWindowPos4dMESA');
  glWindowPos4dvMESA := load('glWindowPos4dvMESA');
  glWindowPos4fMESA := load('glWindowPos4fMESA');
  glWindowPos4fvMESA := load('glWindowPos4fvMESA');
  glWindowPos4iMESA := load('glWindowPos4iMESA');
  glWindowPos4ivMESA := load('glWindowPos4ivMESA');
  glWindowPos4sMESA := load('glWindowPos4sMESA');
  glWindowPos4svMESA := load('glWindowPos4svMESA');
end;

procedure load_GL_NVX_conditional_render(load: TLoadProc);
begin
  if not GLAD_GL_NVX_conditional_render then exit;
  glBeginConditionalRenderNVX := load('glBeginConditionalRenderNVX');
  glEndConditionalRenderNVX := load('glEndConditionalRenderNVX');
end;

procedure load_GL_NVX_gpu_multicast2(load: TLoadProc);
begin
  if not GLAD_GL_NVX_gpu_multicast2 then exit;
  glUploadGpuMaskNVX := load('glUploadGpuMaskNVX');
  glMulticastViewportArrayvNVX := load('glMulticastViewportArrayvNVX');
  glMulticastViewportPositionWScaleNVX := load('glMulticastViewportPositionWScaleNVX');
  glMulticastScissorArrayvNVX := load('glMulticastScissorArrayvNVX');
  glAsyncCopyBufferSubDataNVX := load('glAsyncCopyBufferSubDataNVX');
  glAsyncCopyImageSubDataNVX := load('glAsyncCopyImageSubDataNVX');
end;

procedure load_GL_NVX_linked_gpu_multicast(load: TLoadProc);
begin
  if not GLAD_GL_NVX_linked_gpu_multicast then exit;
  glLGPUNamedBufferSubDataNVX := load('glLGPUNamedBufferSubDataNVX');
  glLGPUCopyImageSubDataNVX := load('glLGPUCopyImageSubDataNVX');
  glLGPUInterlockNVX := load('glLGPUInterlockNVX');
end;

procedure load_GL_NVX_progress_fence(load: TLoadProc);
begin
  if not GLAD_GL_NVX_progress_fence then exit;
  glCreateProgressFenceNVX := load('glCreateProgressFenceNVX');
  glSignalSemaphoreui64NVX := load('glSignalSemaphoreui64NVX');
  glWaitSemaphoreui64NVX := load('glWaitSemaphoreui64NVX');
  glClientWaitSemaphoreui64NVX := load('glClientWaitSemaphoreui64NVX');
end;

procedure load_GL_NV_alpha_to_coverage_dither_control(load: TLoadProc);
begin
  if not GLAD_GL_NV_alpha_to_coverage_dither_control then exit;
  glAlphaToCoverageDitherControlNV := load('glAlphaToCoverageDitherControlNV');
end;

procedure load_GL_NV_bindless_multi_draw_indirect(load: TLoadProc);
begin
  if not GLAD_GL_NV_bindless_multi_draw_indirect then exit;
  glMultiDrawArraysIndirectBindlessNV := load('glMultiDrawArraysIndirectBindlessNV');
  glMultiDrawElementsIndirectBindlessNV := load('glMultiDrawElementsIndirectBindlessNV');
end;

procedure load_GL_NV_bindless_multi_draw_indirect_count(load: TLoadProc);
begin
  if not GLAD_GL_NV_bindless_multi_draw_indirect_count then exit;
  glMultiDrawArraysIndirectBindlessCountNV := load('glMultiDrawArraysIndirectBindlessCountNV');
  glMultiDrawElementsIndirectBindlessCountNV := load('glMultiDrawElementsIndirectBindlessCountNV');
end;

procedure load_GL_NV_bindless_texture(load: TLoadProc);
begin
  if not GLAD_GL_NV_bindless_texture then exit;
  glGetTextureHandleNV := load('glGetTextureHandleNV');
  glGetTextureSamplerHandleNV := load('glGetTextureSamplerHandleNV');
  glMakeTextureHandleResidentNV := load('glMakeTextureHandleResidentNV');
  glMakeTextureHandleNonResidentNV := load('glMakeTextureHandleNonResidentNV');
  glGetImageHandleNV := load('glGetImageHandleNV');
  glMakeImageHandleResidentNV := load('glMakeImageHandleResidentNV');
  glMakeImageHandleNonResidentNV := load('glMakeImageHandleNonResidentNV');
  glUniformHandleui64NV := load('glUniformHandleui64NV');
  glUniformHandleui64vNV := load('glUniformHandleui64vNV');
  glProgramUniformHandleui64NV := load('glProgramUniformHandleui64NV');
  glProgramUniformHandleui64vNV := load('glProgramUniformHandleui64vNV');
  glIsTextureHandleResidentNV := load('glIsTextureHandleResidentNV');
  glIsImageHandleResidentNV := load('glIsImageHandleResidentNV');
end;

procedure load_GL_NV_blend_equation_advanced(load: TLoadProc);
begin
  if not GLAD_GL_NV_blend_equation_advanced then exit;
  glBlendParameteriNV := load('glBlendParameteriNV');
  glBlendBarrierNV := load('glBlendBarrierNV');
end;

procedure load_GL_NV_clip_space_w_scaling(load: TLoadProc);
begin
  if not GLAD_GL_NV_clip_space_w_scaling then exit;
  glViewportPositionWScaleNV := load('glViewportPositionWScaleNV');
end;

procedure load_GL_NV_command_list(load: TLoadProc);
begin
  if not GLAD_GL_NV_command_list then exit;
  glCreateStatesNV := load('glCreateStatesNV');
  glDeleteStatesNV := load('glDeleteStatesNV');
  glIsStateNV := load('glIsStateNV');
  glStateCaptureNV := load('glStateCaptureNV');
  glGetCommandHeaderNV := load('glGetCommandHeaderNV');
  glGetStageIndexNV := load('glGetStageIndexNV');
  glDrawCommandsNV := load('glDrawCommandsNV');
  glDrawCommandsAddressNV := load('glDrawCommandsAddressNV');
  glDrawCommandsStatesNV := load('glDrawCommandsStatesNV');
  glDrawCommandsStatesAddressNV := load('glDrawCommandsStatesAddressNV');
  glCreateCommandListsNV := load('glCreateCommandListsNV');
  glDeleteCommandListsNV := load('glDeleteCommandListsNV');
  glIsCommandListNV := load('glIsCommandListNV');
  glListDrawCommandsStatesClientNV := load('glListDrawCommandsStatesClientNV');
  glCommandListSegmentsNV := load('glCommandListSegmentsNV');
  glCompileCommandListNV := load('glCompileCommandListNV');
  glCallCommandListNV := load('glCallCommandListNV');
end;

procedure load_GL_NV_conditional_render(load: TLoadProc);
begin
  if not GLAD_GL_NV_conditional_render then exit;
  glBeginConditionalRenderNV := load('glBeginConditionalRenderNV');
  glEndConditionalRenderNV := load('glEndConditionalRenderNV');
end;

procedure load_GL_NV_conservative_raster(load: TLoadProc);
begin
  if not GLAD_GL_NV_conservative_raster then exit;
  glSubpixelPrecisionBiasNV := load('glSubpixelPrecisionBiasNV');
end;

procedure load_GL_NV_conservative_raster_dilate(load: TLoadProc);
begin
  if not GLAD_GL_NV_conservative_raster_dilate then exit;
  glConservativeRasterParameterfNV := load('glConservativeRasterParameterfNV');
end;

procedure load_GL_NV_conservative_raster_pre_snap_triangles(load: TLoadProc);
begin
  if not GLAD_GL_NV_conservative_raster_pre_snap_triangles then exit;
  glConservativeRasterParameteriNV := load('glConservativeRasterParameteriNV');
end;

procedure load_GL_NV_copy_image(load: TLoadProc);
begin
  if not GLAD_GL_NV_copy_image then exit;
  glCopyImageSubDataNV := load('glCopyImageSubDataNV');
end;

procedure load_GL_NV_depth_buffer_float(load: TLoadProc);
begin
  if not GLAD_GL_NV_depth_buffer_float then exit;
  glDepthRangedNV := load('glDepthRangedNV');
  glClearDepthdNV := load('glClearDepthdNV');
  glDepthBoundsdNV := load('glDepthBoundsdNV');
end;

procedure load_GL_NV_draw_texture(load: TLoadProc);
begin
  if not GLAD_GL_NV_draw_texture then exit;
  glDrawTextureNV := load('glDrawTextureNV');
end;

procedure load_GL_NV_draw_vulkan_image(load: TLoadProc);
begin
  if not GLAD_GL_NV_draw_vulkan_image then exit;
  glDrawVkImageNV := load('glDrawVkImageNV');
  glGetVkProcAddrNV := load('glGetVkProcAddrNV');
  glWaitVkSemaphoreNV := load('glWaitVkSemaphoreNV');
  glSignalVkSemaphoreNV := load('glSignalVkSemaphoreNV');
  glSignalVkFenceNV := load('glSignalVkFenceNV');
end;

procedure load_GL_NV_evaluators(load: TLoadProc);
begin
  if not GLAD_GL_NV_evaluators then exit;
  glMapControlPointsNV := load('glMapControlPointsNV');
  glMapParameterivNV := load('glMapParameterivNV');
  glMapParameterfvNV := load('glMapParameterfvNV');
  glGetMapControlPointsNV := load('glGetMapControlPointsNV');
  glGetMapParameterivNV := load('glGetMapParameterivNV');
  glGetMapParameterfvNV := load('glGetMapParameterfvNV');
  glGetMapAttribParameterivNV := load('glGetMapAttribParameterivNV');
  glGetMapAttribParameterfvNV := load('glGetMapAttribParameterfvNV');
  glEvalMapsNV := load('glEvalMapsNV');
end;

procedure load_GL_NV_explicit_multisample(load: TLoadProc);
begin
  if not GLAD_GL_NV_explicit_multisample then exit;
  glGetMultisamplefvNV := load('glGetMultisamplefvNV');
  glSampleMaskIndexedNV := load('glSampleMaskIndexedNV');
  glTexRenderbufferNV := load('glTexRenderbufferNV');
end;

procedure load_GL_NV_fence(load: TLoadProc);
begin
  if not GLAD_GL_NV_fence then exit;
  glDeleteFencesNV := load('glDeleteFencesNV');
  glGenFencesNV := load('glGenFencesNV');
  glIsFenceNV := load('glIsFenceNV');
  glTestFenceNV := load('glTestFenceNV');
  glGetFenceivNV := load('glGetFenceivNV');
  glFinishFenceNV := load('glFinishFenceNV');
  glSetFenceNV := load('glSetFenceNV');
end;

procedure load_GL_NV_fragment_coverage_to_color(load: TLoadProc);
begin
  if not GLAD_GL_NV_fragment_coverage_to_color then exit;
  glFragmentCoverageColorNV := load('glFragmentCoverageColorNV');
end;

procedure load_GL_NV_fragment_program(load: TLoadProc);
begin
  if not GLAD_GL_NV_fragment_program then exit;
  glProgramNamedParameter4fNV := load('glProgramNamedParameter4fNV');
  glProgramNamedParameter4fvNV := load('glProgramNamedParameter4fvNV');
  glProgramNamedParameter4dNV := load('glProgramNamedParameter4dNV');
  glProgramNamedParameter4dvNV := load('glProgramNamedParameter4dvNV');
  glGetProgramNamedParameterfvNV := load('glGetProgramNamedParameterfvNV');
  glGetProgramNamedParameterdvNV := load('glGetProgramNamedParameterdvNV');
end;

procedure load_GL_NV_framebuffer_mixed_samples(load: TLoadProc);
begin
  if not GLAD_GL_NV_framebuffer_mixed_samples then exit;
  glRasterSamplesEXT := load('glRasterSamplesEXT');
  glCoverageModulationTableNV := load('glCoverageModulationTableNV');
  glGetCoverageModulationTableNV := load('glGetCoverageModulationTableNV');
  glCoverageModulationNV := load('glCoverageModulationNV');
end;

procedure load_GL_NV_framebuffer_multisample_coverage(load: TLoadProc);
begin
  if not GLAD_GL_NV_framebuffer_multisample_coverage then exit;
  glRenderbufferStorageMultisampleCoverageNV := load('glRenderbufferStorageMultisampleCoverageNV');
end;

procedure load_GL_NV_geometry_program4(load: TLoadProc);
begin
  if not GLAD_GL_NV_geometry_program4 then exit;
  glProgramVertexLimitNV := load('glProgramVertexLimitNV');
  glFramebufferTextureEXT := load('glFramebufferTextureEXT');
  glFramebufferTextureLayerEXT := load('glFramebufferTextureLayerEXT');
  glFramebufferTextureFaceEXT := load('glFramebufferTextureFaceEXT');
end;

procedure load_GL_NV_gpu_multicast(load: TLoadProc);
begin
  if not GLAD_GL_NV_gpu_multicast then exit;
  glRenderGpuMaskNV := load('glRenderGpuMaskNV');
  glMulticastBufferSubDataNV := load('glMulticastBufferSubDataNV');
  glMulticastCopyBufferSubDataNV := load('glMulticastCopyBufferSubDataNV');
  glMulticastCopyImageSubDataNV := load('glMulticastCopyImageSubDataNV');
  glMulticastBlitFramebufferNV := load('glMulticastBlitFramebufferNV');
  glMulticastFramebufferSampleLocationsfvNV := load('glMulticastFramebufferSampleLocationsfvNV');
  glMulticastBarrierNV := load('glMulticastBarrierNV');
  glMulticastWaitSyncNV := load('glMulticastWaitSyncNV');
  glMulticastGetQueryObjectivNV := load('glMulticastGetQueryObjectivNV');
  glMulticastGetQueryObjectuivNV := load('glMulticastGetQueryObjectuivNV');
  glMulticastGetQueryObjecti64vNV := load('glMulticastGetQueryObjecti64vNV');
  glMulticastGetQueryObjectui64vNV := load('glMulticastGetQueryObjectui64vNV');
end;

procedure load_GL_NV_gpu_program4(load: TLoadProc);
begin
  if not GLAD_GL_NV_gpu_program4 then exit;
  glProgramLocalParameterI4iNV := load('glProgramLocalParameterI4iNV');
  glProgramLocalParameterI4ivNV := load('glProgramLocalParameterI4ivNV');
  glProgramLocalParametersI4ivNV := load('glProgramLocalParametersI4ivNV');
  glProgramLocalParameterI4uiNV := load('glProgramLocalParameterI4uiNV');
  glProgramLocalParameterI4uivNV := load('glProgramLocalParameterI4uivNV');
  glProgramLocalParametersI4uivNV := load('glProgramLocalParametersI4uivNV');
  glProgramEnvParameterI4iNV := load('glProgramEnvParameterI4iNV');
  glProgramEnvParameterI4ivNV := load('glProgramEnvParameterI4ivNV');
  glProgramEnvParametersI4ivNV := load('glProgramEnvParametersI4ivNV');
  glProgramEnvParameterI4uiNV := load('glProgramEnvParameterI4uiNV');
  glProgramEnvParameterI4uivNV := load('glProgramEnvParameterI4uivNV');
  glProgramEnvParametersI4uivNV := load('glProgramEnvParametersI4uivNV');
  glGetProgramLocalParameterIivNV := load('glGetProgramLocalParameterIivNV');
  glGetProgramLocalParameterIuivNV := load('glGetProgramLocalParameterIuivNV');
  glGetProgramEnvParameterIivNV := load('glGetProgramEnvParameterIivNV');
  glGetProgramEnvParameterIuivNV := load('glGetProgramEnvParameterIuivNV');
end;

procedure load_GL_NV_gpu_program5(load: TLoadProc);
begin
  if not GLAD_GL_NV_gpu_program5 then exit;
  glProgramSubroutineParametersuivNV := load('glProgramSubroutineParametersuivNV');
  glGetProgramSubroutineParameteruivNV := load('glGetProgramSubroutineParameteruivNV');
end;

procedure load_GL_NV_gpu_shader5(load: TLoadProc);
begin
  if not GLAD_GL_NV_gpu_shader5 then exit;
  glUniform1i64NV := load('glUniform1i64NV');
  glUniform2i64NV := load('glUniform2i64NV');
  glUniform3i64NV := load('glUniform3i64NV');
  glUniform4i64NV := load('glUniform4i64NV');
  glUniform1i64vNV := load('glUniform1i64vNV');
  glUniform2i64vNV := load('glUniform2i64vNV');
  glUniform3i64vNV := load('glUniform3i64vNV');
  glUniform4i64vNV := load('glUniform4i64vNV');
  glUniform1ui64NV := load('glUniform1ui64NV');
  glUniform2ui64NV := load('glUniform2ui64NV');
  glUniform3ui64NV := load('glUniform3ui64NV');
  glUniform4ui64NV := load('glUniform4ui64NV');
  glUniform1ui64vNV := load('glUniform1ui64vNV');
  glUniform2ui64vNV := load('glUniform2ui64vNV');
  glUniform3ui64vNV := load('glUniform3ui64vNV');
  glUniform4ui64vNV := load('glUniform4ui64vNV');
  glGetUniformi64vNV := load('glGetUniformi64vNV');
  glProgramUniform1i64NV := load('glProgramUniform1i64NV');
  glProgramUniform2i64NV := load('glProgramUniform2i64NV');
  glProgramUniform3i64NV := load('glProgramUniform3i64NV');
  glProgramUniform4i64NV := load('glProgramUniform4i64NV');
  glProgramUniform1i64vNV := load('glProgramUniform1i64vNV');
  glProgramUniform2i64vNV := load('glProgramUniform2i64vNV');
  glProgramUniform3i64vNV := load('glProgramUniform3i64vNV');
  glProgramUniform4i64vNV := load('glProgramUniform4i64vNV');
  glProgramUniform1ui64NV := load('glProgramUniform1ui64NV');
  glProgramUniform2ui64NV := load('glProgramUniform2ui64NV');
  glProgramUniform3ui64NV := load('glProgramUniform3ui64NV');
  glProgramUniform4ui64NV := load('glProgramUniform4ui64NV');
  glProgramUniform1ui64vNV := load('glProgramUniform1ui64vNV');
  glProgramUniform2ui64vNV := load('glProgramUniform2ui64vNV');
  glProgramUniform3ui64vNV := load('glProgramUniform3ui64vNV');
  glProgramUniform4ui64vNV := load('glProgramUniform4ui64vNV');
end;

procedure load_GL_NV_half_float(load: TLoadProc);
begin
  if not GLAD_GL_NV_half_float then exit;
  glVertex2hNV := load('glVertex2hNV');
  glVertex2hvNV := load('glVertex2hvNV');
  glVertex3hNV := load('glVertex3hNV');
  glVertex3hvNV := load('glVertex3hvNV');
  glVertex4hNV := load('glVertex4hNV');
  glVertex4hvNV := load('glVertex4hvNV');
  glNormal3hNV := load('glNormal3hNV');
  glNormal3hvNV := load('glNormal3hvNV');
  glColor3hNV := load('glColor3hNV');
  glColor3hvNV := load('glColor3hvNV');
  glColor4hNV := load('glColor4hNV');
  glColor4hvNV := load('glColor4hvNV');
  glTexCoord1hNV := load('glTexCoord1hNV');
  glTexCoord1hvNV := load('glTexCoord1hvNV');
  glTexCoord2hNV := load('glTexCoord2hNV');
  glTexCoord2hvNV := load('glTexCoord2hvNV');
  glTexCoord3hNV := load('glTexCoord3hNV');
  glTexCoord3hvNV := load('glTexCoord3hvNV');
  glTexCoord4hNV := load('glTexCoord4hNV');
  glTexCoord4hvNV := load('glTexCoord4hvNV');
  glMultiTexCoord1hNV := load('glMultiTexCoord1hNV');
  glMultiTexCoord1hvNV := load('glMultiTexCoord1hvNV');
  glMultiTexCoord2hNV := load('glMultiTexCoord2hNV');
  glMultiTexCoord2hvNV := load('glMultiTexCoord2hvNV');
  glMultiTexCoord3hNV := load('glMultiTexCoord3hNV');
  glMultiTexCoord3hvNV := load('glMultiTexCoord3hvNV');
  glMultiTexCoord4hNV := load('glMultiTexCoord4hNV');
  glMultiTexCoord4hvNV := load('glMultiTexCoord4hvNV');
  glVertexAttrib1hNV := load('glVertexAttrib1hNV');
  glVertexAttrib1hvNV := load('glVertexAttrib1hvNV');
  glVertexAttrib2hNV := load('glVertexAttrib2hNV');
  glVertexAttrib2hvNV := load('glVertexAttrib2hvNV');
  glVertexAttrib3hNV := load('glVertexAttrib3hNV');
  glVertexAttrib3hvNV := load('glVertexAttrib3hvNV');
  glVertexAttrib4hNV := load('glVertexAttrib4hNV');
  glVertexAttrib4hvNV := load('glVertexAttrib4hvNV');
  glVertexAttribs1hvNV := load('glVertexAttribs1hvNV');
  glVertexAttribs2hvNV := load('glVertexAttribs2hvNV');
  glVertexAttribs3hvNV := load('glVertexAttribs3hvNV');
  glVertexAttribs4hvNV := load('glVertexAttribs4hvNV');
  glFogCoordhNV := load('glFogCoordhNV');
  glFogCoordhvNV := load('glFogCoordhvNV');
  glSecondaryColor3hNV := load('glSecondaryColor3hNV');
  glSecondaryColor3hvNV := load('glSecondaryColor3hvNV');
  glVertexWeighthNV := load('glVertexWeighthNV');
  glVertexWeighthvNV := load('glVertexWeighthvNV');
end;

procedure load_GL_NV_internalformat_sample_query(load: TLoadProc);
begin
  if not GLAD_GL_NV_internalformat_sample_query then exit;
  glGetInternalformatSampleivNV := load('glGetInternalformatSampleivNV');
end;

procedure load_GL_NV_memory_attachment(load: TLoadProc);
begin
  if not GLAD_GL_NV_memory_attachment then exit;
  glGetMemoryObjectDetachedResourcesuivNV := load('glGetMemoryObjectDetachedResourcesuivNV');
  glResetMemoryObjectParameterNV := load('glResetMemoryObjectParameterNV');
  glTexAttachMemoryNV := load('glTexAttachMemoryNV');
  glBufferAttachMemoryNV := load('glBufferAttachMemoryNV');
  glTextureAttachMemoryNV := load('glTextureAttachMemoryNV');
  glNamedBufferAttachMemoryNV := load('glNamedBufferAttachMemoryNV');
end;

procedure load_GL_NV_memory_object_sparse(load: TLoadProc);
begin
  if not GLAD_GL_NV_memory_object_sparse then exit;
  glBufferPageCommitmentMemNV := load('glBufferPageCommitmentMemNV');
  glTexPageCommitmentMemNV := load('glTexPageCommitmentMemNV');
  glNamedBufferPageCommitmentMemNV := load('glNamedBufferPageCommitmentMemNV');
  glTexturePageCommitmentMemNV := load('glTexturePageCommitmentMemNV');
end;

procedure load_GL_NV_mesh_shader(load: TLoadProc);
begin
  if not GLAD_GL_NV_mesh_shader then exit;
  glDrawMeshTasksNV := load('glDrawMeshTasksNV');
  glDrawMeshTasksIndirectNV := load('glDrawMeshTasksIndirectNV');
  glMultiDrawMeshTasksIndirectNV := load('glMultiDrawMeshTasksIndirectNV');
  glMultiDrawMeshTasksIndirectCountNV := load('glMultiDrawMeshTasksIndirectCountNV');
end;

procedure load_GL_NV_occlusion_query(load: TLoadProc);
begin
  if not GLAD_GL_NV_occlusion_query then exit;
  glGenOcclusionQueriesNV := load('glGenOcclusionQueriesNV');
  glDeleteOcclusionQueriesNV := load('glDeleteOcclusionQueriesNV');
  glIsOcclusionQueryNV := load('glIsOcclusionQueryNV');
  glBeginOcclusionQueryNV := load('glBeginOcclusionQueryNV');
  glEndOcclusionQueryNV := load('glEndOcclusionQueryNV');
  glGetOcclusionQueryivNV := load('glGetOcclusionQueryivNV');
  glGetOcclusionQueryuivNV := load('glGetOcclusionQueryuivNV');
end;

procedure load_GL_NV_parameter_buffer_object(load: TLoadProc);
begin
  if not GLAD_GL_NV_parameter_buffer_object then exit;
  glProgramBufferParametersfvNV := load('glProgramBufferParametersfvNV');
  glProgramBufferParametersIivNV := load('glProgramBufferParametersIivNV');
  glProgramBufferParametersIuivNV := load('glProgramBufferParametersIuivNV');
end;

procedure load_GL_NV_path_rendering(load: TLoadProc);
begin
  if not GLAD_GL_NV_path_rendering then exit;
  glGenPathsNV := load('glGenPathsNV');
  glDeletePathsNV := load('glDeletePathsNV');
  glIsPathNV := load('glIsPathNV');
  glPathCommandsNV := load('glPathCommandsNV');
  glPathCoordsNV := load('glPathCoordsNV');
  glPathSubCommandsNV := load('glPathSubCommandsNV');
  glPathSubCoordsNV := load('glPathSubCoordsNV');
  glPathStringNV := load('glPathStringNV');
  glPathGlyphsNV := load('glPathGlyphsNV');
  glPathGlyphRangeNV := load('glPathGlyphRangeNV');
  glWeightPathsNV := load('glWeightPathsNV');
  glCopyPathNV := load('glCopyPathNV');
  glInterpolatePathsNV := load('glInterpolatePathsNV');
  glTransformPathNV := load('glTransformPathNV');
  glPathParameterivNV := load('glPathParameterivNV');
  glPathParameteriNV := load('glPathParameteriNV');
  glPathParameterfvNV := load('glPathParameterfvNV');
  glPathParameterfNV := load('glPathParameterfNV');
  glPathDashArrayNV := load('glPathDashArrayNV');
  glPathStencilFuncNV := load('glPathStencilFuncNV');
  glPathStencilDepthOffsetNV := load('glPathStencilDepthOffsetNV');
  glStencilFillPathNV := load('glStencilFillPathNV');
  glStencilStrokePathNV := load('glStencilStrokePathNV');
  glStencilFillPathInstancedNV := load('glStencilFillPathInstancedNV');
  glStencilStrokePathInstancedNV := load('glStencilStrokePathInstancedNV');
  glPathCoverDepthFuncNV := load('glPathCoverDepthFuncNV');
  glCoverFillPathNV := load('glCoverFillPathNV');
  glCoverStrokePathNV := load('glCoverStrokePathNV');
  glCoverFillPathInstancedNV := load('glCoverFillPathInstancedNV');
  glCoverStrokePathInstancedNV := load('glCoverStrokePathInstancedNV');
  glGetPathParameterivNV := load('glGetPathParameterivNV');
  glGetPathParameterfvNV := load('glGetPathParameterfvNV');
  glGetPathCommandsNV := load('glGetPathCommandsNV');
  glGetPathCoordsNV := load('glGetPathCoordsNV');
  glGetPathDashArrayNV := load('glGetPathDashArrayNV');
  glGetPathMetricsNV := load('glGetPathMetricsNV');
  glGetPathMetricRangeNV := load('glGetPathMetricRangeNV');
  glGetPathSpacingNV := load('glGetPathSpacingNV');
  glIsPointInFillPathNV := load('glIsPointInFillPathNV');
  glIsPointInStrokePathNV := load('glIsPointInStrokePathNV');
  glGetPathLengthNV := load('glGetPathLengthNV');
  glPointAlongPathNV := load('glPointAlongPathNV');
  glMatrixLoad3x2fNV := load('glMatrixLoad3x2fNV');
  glMatrixLoad3x3fNV := load('glMatrixLoad3x3fNV');
  glMatrixLoadTranspose3x3fNV := load('glMatrixLoadTranspose3x3fNV');
  glMatrixMult3x2fNV := load('glMatrixMult3x2fNV');
  glMatrixMult3x3fNV := load('glMatrixMult3x3fNV');
  glMatrixMultTranspose3x3fNV := load('glMatrixMultTranspose3x3fNV');
  glStencilThenCoverFillPathNV := load('glStencilThenCoverFillPathNV');
  glStencilThenCoverStrokePathNV := load('glStencilThenCoverStrokePathNV');
  glStencilThenCoverFillPathInstancedNV := load('glStencilThenCoverFillPathInstancedNV');
  glStencilThenCoverStrokePathInstancedNV := load('glStencilThenCoverStrokePathInstancedNV');
  glPathGlyphIndexRangeNV := load('glPathGlyphIndexRangeNV');
  glPathGlyphIndexArrayNV := load('glPathGlyphIndexArrayNV');
  glPathMemoryGlyphIndexArrayNV := load('glPathMemoryGlyphIndexArrayNV');
  glProgramPathFragmentInputGenNV := load('glProgramPathFragmentInputGenNV');
  glGetProgramResourcefvNV := load('glGetProgramResourcefvNV');
  glPathColorGenNV := load('glPathColorGenNV');
  glPathTexGenNV := load('glPathTexGenNV');
  glPathFogGenNV := load('glPathFogGenNV');
  glGetPathColorGenivNV := load('glGetPathColorGenivNV');
  glGetPathColorGenfvNV := load('glGetPathColorGenfvNV');
  glGetPathTexGenivNV := load('glGetPathTexGenivNV');
  glGetPathTexGenfvNV := load('glGetPathTexGenfvNV');
  glMatrixFrustumEXT := load('glMatrixFrustumEXT');
  glMatrixLoadIdentityEXT := load('glMatrixLoadIdentityEXT');
  glMatrixLoadTransposefEXT := load('glMatrixLoadTransposefEXT');
  glMatrixLoadTransposedEXT := load('glMatrixLoadTransposedEXT');
  glMatrixLoadfEXT := load('glMatrixLoadfEXT');
  glMatrixLoaddEXT := load('glMatrixLoaddEXT');
  glMatrixMultTransposefEXT := load('glMatrixMultTransposefEXT');
  glMatrixMultTransposedEXT := load('glMatrixMultTransposedEXT');
  glMatrixMultfEXT := load('glMatrixMultfEXT');
  glMatrixMultdEXT := load('glMatrixMultdEXT');
  glMatrixOrthoEXT := load('glMatrixOrthoEXT');
  glMatrixPopEXT := load('glMatrixPopEXT');
  glMatrixPushEXT := load('glMatrixPushEXT');
  glMatrixRotatefEXT := load('glMatrixRotatefEXT');
  glMatrixRotatedEXT := load('glMatrixRotatedEXT');
  glMatrixScalefEXT := load('glMatrixScalefEXT');
  glMatrixScaledEXT := load('glMatrixScaledEXT');
  glMatrixTranslatefEXT := load('glMatrixTranslatefEXT');
  glMatrixTranslatedEXT := load('glMatrixTranslatedEXT');
end;

procedure load_GL_NV_pixel_data_range(load: TLoadProc);
begin
  if not GLAD_GL_NV_pixel_data_range then exit;
  glPixelDataRangeNV := load('glPixelDataRangeNV');
  glFlushPixelDataRangeNV := load('glFlushPixelDataRangeNV');
end;

procedure load_GL_NV_point_sprite(load: TLoadProc);
begin
  if not GLAD_GL_NV_point_sprite then exit;
  glPointParameteriNV := load('glPointParameteriNV');
  glPointParameterivNV := load('glPointParameterivNV');
end;

procedure load_GL_NV_present_video(load: TLoadProc);
begin
  if not GLAD_GL_NV_present_video then exit;
  glPresentFrameKeyedNV := load('glPresentFrameKeyedNV');
  glPresentFrameDualFillNV := load('glPresentFrameDualFillNV');
  glGetVideoivNV := load('glGetVideoivNV');
  glGetVideouivNV := load('glGetVideouivNV');
  glGetVideoi64vNV := load('glGetVideoi64vNV');
  glGetVideoui64vNV := load('glGetVideoui64vNV');
end;

procedure load_GL_NV_primitive_restart(load: TLoadProc);
begin
  if not GLAD_GL_NV_primitive_restart then exit;
  glPrimitiveRestartNV := load('glPrimitiveRestartNV');
  glPrimitiveRestartIndexNV := load('glPrimitiveRestartIndexNV');
end;

procedure load_GL_NV_query_resource(load: TLoadProc);
begin
  if not GLAD_GL_NV_query_resource then exit;
  glQueryResourceNV := load('glQueryResourceNV');
end;

procedure load_GL_NV_query_resource_tag(load: TLoadProc);
begin
  if not GLAD_GL_NV_query_resource_tag then exit;
  glGenQueryResourceTagNV := load('glGenQueryResourceTagNV');
  glDeleteQueryResourceTagNV := load('glDeleteQueryResourceTagNV');
  glQueryResourceTagNV := load('glQueryResourceTagNV');
end;

procedure load_GL_NV_register_combiners(load: TLoadProc);
begin
  if not GLAD_GL_NV_register_combiners then exit;
  glCombinerParameterfvNV := load('glCombinerParameterfvNV');
  glCombinerParameterfNV := load('glCombinerParameterfNV');
  glCombinerParameterivNV := load('glCombinerParameterivNV');
  glCombinerParameteriNV := load('glCombinerParameteriNV');
  glCombinerInputNV := load('glCombinerInputNV');
  glCombinerOutputNV := load('glCombinerOutputNV');
  glFinalCombinerInputNV := load('glFinalCombinerInputNV');
  glGetCombinerInputParameterfvNV := load('glGetCombinerInputParameterfvNV');
  glGetCombinerInputParameterivNV := load('glGetCombinerInputParameterivNV');
  glGetCombinerOutputParameterfvNV := load('glGetCombinerOutputParameterfvNV');
  glGetCombinerOutputParameterivNV := load('glGetCombinerOutputParameterivNV');
  glGetFinalCombinerInputParameterfvNV := load('glGetFinalCombinerInputParameterfvNV');
  glGetFinalCombinerInputParameterivNV := load('glGetFinalCombinerInputParameterivNV');
end;

procedure load_GL_NV_register_combiners2(load: TLoadProc);
begin
  if not GLAD_GL_NV_register_combiners2 then exit;
  glCombinerStageParameterfvNV := load('glCombinerStageParameterfvNV');
  glGetCombinerStageParameterfvNV := load('glGetCombinerStageParameterfvNV');
end;

procedure load_GL_NV_sample_locations(load: TLoadProc);
begin
  if not GLAD_GL_NV_sample_locations then exit;
  glFramebufferSampleLocationsfvNV := load('glFramebufferSampleLocationsfvNV');
  glNamedFramebufferSampleLocationsfvNV := load('glNamedFramebufferSampleLocationsfvNV');
  glResolveDepthValuesNV := load('glResolveDepthValuesNV');
end;

procedure load_GL_NV_scissor_exclusive(load: TLoadProc);
begin
  if not GLAD_GL_NV_scissor_exclusive then exit;
  glScissorExclusiveNV := load('glScissorExclusiveNV');
  glScissorExclusiveArrayvNV := load('glScissorExclusiveArrayvNV');
end;

procedure load_GL_NV_shader_buffer_load(load: TLoadProc);
begin
  if not GLAD_GL_NV_shader_buffer_load then exit;
  glMakeBufferResidentNV := load('glMakeBufferResidentNV');
  glMakeBufferNonResidentNV := load('glMakeBufferNonResidentNV');
  glIsBufferResidentNV := load('glIsBufferResidentNV');
  glMakeNamedBufferResidentNV := load('glMakeNamedBufferResidentNV');
  glMakeNamedBufferNonResidentNV := load('glMakeNamedBufferNonResidentNV');
  glIsNamedBufferResidentNV := load('glIsNamedBufferResidentNV');
  glGetBufferParameterui64vNV := load('glGetBufferParameterui64vNV');
  glGetNamedBufferParameterui64vNV := load('glGetNamedBufferParameterui64vNV');
  glGetIntegerui64vNV := load('glGetIntegerui64vNV');
  glUniformui64NV := load('glUniformui64NV');
  glUniformui64vNV := load('glUniformui64vNV');
  glGetUniformui64vNV := load('glGetUniformui64vNV');
  glProgramUniformui64NV := load('glProgramUniformui64NV');
  glProgramUniformui64vNV := load('glProgramUniformui64vNV');
end;

procedure load_GL_NV_shading_rate_image(load: TLoadProc);
begin
  if not GLAD_GL_NV_shading_rate_image then exit;
  glBindShadingRateImageNV := load('glBindShadingRateImageNV');
  glGetShadingRateImagePaletteNV := load('glGetShadingRateImagePaletteNV');
  glGetShadingRateSampleLocationivNV := load('glGetShadingRateSampleLocationivNV');
  glShadingRateImageBarrierNV := load('glShadingRateImageBarrierNV');
  glShadingRateImagePaletteNV := load('glShadingRateImagePaletteNV');
  glShadingRateSampleOrderNV := load('glShadingRateSampleOrderNV');
  glShadingRateSampleOrderCustomNV := load('glShadingRateSampleOrderCustomNV');
end;

procedure load_GL_NV_texture_barrier(load: TLoadProc);
begin
  if not GLAD_GL_NV_texture_barrier then exit;
  glTextureBarrierNV := load('glTextureBarrierNV');
end;

procedure load_GL_NV_texture_multisample(load: TLoadProc);
begin
  if not GLAD_GL_NV_texture_multisample then exit;
  glTexImage2DMultisampleCoverageNV := load('glTexImage2DMultisampleCoverageNV');
  glTexImage3DMultisampleCoverageNV := load('glTexImage3DMultisampleCoverageNV');
  glTextureImage2DMultisampleNV := load('glTextureImage2DMultisampleNV');
  glTextureImage3DMultisampleNV := load('glTextureImage3DMultisampleNV');
  glTextureImage2DMultisampleCoverageNV := load('glTextureImage2DMultisampleCoverageNV');
  glTextureImage3DMultisampleCoverageNV := load('glTextureImage3DMultisampleCoverageNV');
end;

procedure load_GL_NV_timeline_semaphore(load: TLoadProc);
begin
  if not GLAD_GL_NV_timeline_semaphore then exit;
  glCreateSemaphoresNV := load('glCreateSemaphoresNV');
  glSemaphoreParameterivNV := load('glSemaphoreParameterivNV');
  glGetSemaphoreParameterivNV := load('glGetSemaphoreParameterivNV');
end;

procedure load_GL_NV_transform_feedback(load: TLoadProc);
begin
  if not GLAD_GL_NV_transform_feedback then exit;
  glBeginTransformFeedbackNV := load('glBeginTransformFeedbackNV');
  glEndTransformFeedbackNV := load('glEndTransformFeedbackNV');
  glTransformFeedbackAttribsNV := load('glTransformFeedbackAttribsNV');
  glBindBufferRangeNV := load('glBindBufferRangeNV');
  glBindBufferOffsetNV := load('glBindBufferOffsetNV');
  glBindBufferBaseNV := load('glBindBufferBaseNV');
  glTransformFeedbackVaryingsNV := load('glTransformFeedbackVaryingsNV');
  glActiveVaryingNV := load('glActiveVaryingNV');
  glGetVaryingLocationNV := load('glGetVaryingLocationNV');
  glGetActiveVaryingNV := load('glGetActiveVaryingNV');
  glGetTransformFeedbackVaryingNV := load('glGetTransformFeedbackVaryingNV');
  glTransformFeedbackStreamAttribsNV := load('glTransformFeedbackStreamAttribsNV');
end;

procedure load_GL_NV_transform_feedback2(load: TLoadProc);
begin
  if not GLAD_GL_NV_transform_feedback2 then exit;
  glBindTransformFeedbackNV := load('glBindTransformFeedbackNV');
  glDeleteTransformFeedbacksNV := load('glDeleteTransformFeedbacksNV');
  glGenTransformFeedbacksNV := load('glGenTransformFeedbacksNV');
  glIsTransformFeedbackNV := load('glIsTransformFeedbackNV');
  glPauseTransformFeedbackNV := load('glPauseTransformFeedbackNV');
  glResumeTransformFeedbackNV := load('glResumeTransformFeedbackNV');
  glDrawTransformFeedbackNV := load('glDrawTransformFeedbackNV');
end;

procedure load_GL_NV_vdpau_interop(load: TLoadProc);
begin
  if not GLAD_GL_NV_vdpau_interop then exit;
  glVDPAUInitNV := load('glVDPAUInitNV');
  glVDPAUFiniNV := load('glVDPAUFiniNV');
  glVDPAURegisterVideoSurfaceNV := load('glVDPAURegisterVideoSurfaceNV');
  glVDPAURegisterOutputSurfaceNV := load('glVDPAURegisterOutputSurfaceNV');
  glVDPAUIsSurfaceNV := load('glVDPAUIsSurfaceNV');
  glVDPAUUnregisterSurfaceNV := load('glVDPAUUnregisterSurfaceNV');
  glVDPAUGetSurfaceivNV := load('glVDPAUGetSurfaceivNV');
  glVDPAUSurfaceAccessNV := load('glVDPAUSurfaceAccessNV');
  glVDPAUMapSurfacesNV := load('glVDPAUMapSurfacesNV');
  glVDPAUUnmapSurfacesNV := load('glVDPAUUnmapSurfacesNV');
end;

procedure load_GL_NV_vdpau_interop2(load: TLoadProc);
begin
  if not GLAD_GL_NV_vdpau_interop2 then exit;
  glVDPAURegisterVideoSurfaceWithPictureStructureNV := load('glVDPAURegisterVideoSurfaceWithPictureStructureNV');
end;

procedure load_GL_NV_vertex_array_range(load: TLoadProc);
begin
  if not GLAD_GL_NV_vertex_array_range then exit;
  glFlushVertexArrayRangeNV := load('glFlushVertexArrayRangeNV');
  glVertexArrayRangeNV := load('glVertexArrayRangeNV');
end;

procedure load_GL_NV_vertex_attrib_integer_64bit(load: TLoadProc);
begin
  if not GLAD_GL_NV_vertex_attrib_integer_64bit then exit;
  glVertexAttribL1i64NV := load('glVertexAttribL1i64NV');
  glVertexAttribL2i64NV := load('glVertexAttribL2i64NV');
  glVertexAttribL3i64NV := load('glVertexAttribL3i64NV');
  glVertexAttribL4i64NV := load('glVertexAttribL4i64NV');
  glVertexAttribL1i64vNV := load('glVertexAttribL1i64vNV');
  glVertexAttribL2i64vNV := load('glVertexAttribL2i64vNV');
  glVertexAttribL3i64vNV := load('glVertexAttribL3i64vNV');
  glVertexAttribL4i64vNV := load('glVertexAttribL4i64vNV');
  glVertexAttribL1ui64NV := load('glVertexAttribL1ui64NV');
  glVertexAttribL2ui64NV := load('glVertexAttribL2ui64NV');
  glVertexAttribL3ui64NV := load('glVertexAttribL3ui64NV');
  glVertexAttribL4ui64NV := load('glVertexAttribL4ui64NV');
  glVertexAttribL1ui64vNV := load('glVertexAttribL1ui64vNV');
  glVertexAttribL2ui64vNV := load('glVertexAttribL2ui64vNV');
  glVertexAttribL3ui64vNV := load('glVertexAttribL3ui64vNV');
  glVertexAttribL4ui64vNV := load('glVertexAttribL4ui64vNV');
  glGetVertexAttribLi64vNV := load('glGetVertexAttribLi64vNV');
  glGetVertexAttribLui64vNV := load('glGetVertexAttribLui64vNV');
  glVertexAttribLFormatNV := load('glVertexAttribLFormatNV');
end;

procedure load_GL_NV_vertex_buffer_unified_memory(load: TLoadProc);
begin
  if not GLAD_GL_NV_vertex_buffer_unified_memory then exit;
  glBufferAddressRangeNV := load('glBufferAddressRangeNV');
  glVertexFormatNV := load('glVertexFormatNV');
  glNormalFormatNV := load('glNormalFormatNV');
  glColorFormatNV := load('glColorFormatNV');
  glIndexFormatNV := load('glIndexFormatNV');
  glTexCoordFormatNV := load('glTexCoordFormatNV');
  glEdgeFlagFormatNV := load('glEdgeFlagFormatNV');
  glSecondaryColorFormatNV := load('glSecondaryColorFormatNV');
  glFogCoordFormatNV := load('glFogCoordFormatNV');
  glVertexAttribFormatNV := load('glVertexAttribFormatNV');
  glVertexAttribIFormatNV := load('glVertexAttribIFormatNV');
  glGetIntegerui64i_vNV := load('glGetIntegerui64i_vNV');
end;

procedure load_GL_NV_vertex_program(load: TLoadProc);
begin
  if not GLAD_GL_NV_vertex_program then exit;
  glAreProgramsResidentNV := load('glAreProgramsResidentNV');
  glBindProgramNV := load('glBindProgramNV');
  glDeleteProgramsNV := load('glDeleteProgramsNV');
  glExecuteProgramNV := load('glExecuteProgramNV');
  glGenProgramsNV := load('glGenProgramsNV');
  glGetProgramParameterdvNV := load('glGetProgramParameterdvNV');
  glGetProgramParameterfvNV := load('glGetProgramParameterfvNV');
  glGetProgramivNV := load('glGetProgramivNV');
  glGetProgramStringNV := load('glGetProgramStringNV');
  glGetTrackMatrixivNV := load('glGetTrackMatrixivNV');
  glGetVertexAttribdvNV := load('glGetVertexAttribdvNV');
  glGetVertexAttribfvNV := load('glGetVertexAttribfvNV');
  glGetVertexAttribivNV := load('glGetVertexAttribivNV');
  glGetVertexAttribPointervNV := load('glGetVertexAttribPointervNV');
  glIsProgramNV := load('glIsProgramNV');
  glLoadProgramNV := load('glLoadProgramNV');
  glProgramParameter4dNV := load('glProgramParameter4dNV');
  glProgramParameter4dvNV := load('glProgramParameter4dvNV');
  glProgramParameter4fNV := load('glProgramParameter4fNV');
  glProgramParameter4fvNV := load('glProgramParameter4fvNV');
  glProgramParameters4dvNV := load('glProgramParameters4dvNV');
  glProgramParameters4fvNV := load('glProgramParameters4fvNV');
  glRequestResidentProgramsNV := load('glRequestResidentProgramsNV');
  glTrackMatrixNV := load('glTrackMatrixNV');
  glVertexAttribPointerNV := load('glVertexAttribPointerNV');
  glVertexAttrib1dNV := load('glVertexAttrib1dNV');
  glVertexAttrib1dvNV := load('glVertexAttrib1dvNV');
  glVertexAttrib1fNV := load('glVertexAttrib1fNV');
  glVertexAttrib1fvNV := load('glVertexAttrib1fvNV');
  glVertexAttrib1sNV := load('glVertexAttrib1sNV');
  glVertexAttrib1svNV := load('glVertexAttrib1svNV');
  glVertexAttrib2dNV := load('glVertexAttrib2dNV');
  glVertexAttrib2dvNV := load('glVertexAttrib2dvNV');
  glVertexAttrib2fNV := load('glVertexAttrib2fNV');
  glVertexAttrib2fvNV := load('glVertexAttrib2fvNV');
  glVertexAttrib2sNV := load('glVertexAttrib2sNV');
  glVertexAttrib2svNV := load('glVertexAttrib2svNV');
  glVertexAttrib3dNV := load('glVertexAttrib3dNV');
  glVertexAttrib3dvNV := load('glVertexAttrib3dvNV');
  glVertexAttrib3fNV := load('glVertexAttrib3fNV');
  glVertexAttrib3fvNV := load('glVertexAttrib3fvNV');
  glVertexAttrib3sNV := load('glVertexAttrib3sNV');
  glVertexAttrib3svNV := load('glVertexAttrib3svNV');
  glVertexAttrib4dNV := load('glVertexAttrib4dNV');
  glVertexAttrib4dvNV := load('glVertexAttrib4dvNV');
  glVertexAttrib4fNV := load('glVertexAttrib4fNV');
  glVertexAttrib4fvNV := load('glVertexAttrib4fvNV');
  glVertexAttrib4sNV := load('glVertexAttrib4sNV');
  glVertexAttrib4svNV := load('glVertexAttrib4svNV');
  glVertexAttrib4ubNV := load('glVertexAttrib4ubNV');
  glVertexAttrib4ubvNV := load('glVertexAttrib4ubvNV');
  glVertexAttribs1dvNV := load('glVertexAttribs1dvNV');
  glVertexAttribs1fvNV := load('glVertexAttribs1fvNV');
  glVertexAttribs1svNV := load('glVertexAttribs1svNV');
  glVertexAttribs2dvNV := load('glVertexAttribs2dvNV');
  glVertexAttribs2fvNV := load('glVertexAttribs2fvNV');
  glVertexAttribs2svNV := load('glVertexAttribs2svNV');
  glVertexAttribs3dvNV := load('glVertexAttribs3dvNV');
  glVertexAttribs3fvNV := load('glVertexAttribs3fvNV');
  glVertexAttribs3svNV := load('glVertexAttribs3svNV');
  glVertexAttribs4dvNV := load('glVertexAttribs4dvNV');
  glVertexAttribs4fvNV := load('glVertexAttribs4fvNV');
  glVertexAttribs4svNV := load('glVertexAttribs4svNV');
  glVertexAttribs4ubvNV := load('glVertexAttribs4ubvNV');
end;

procedure load_GL_NV_vertex_program4(load: TLoadProc);
begin
  if not GLAD_GL_NV_vertex_program4 then exit;
  glVertexAttribI1iEXT := load('glVertexAttribI1iEXT');
  glVertexAttribI2iEXT := load('glVertexAttribI2iEXT');
  glVertexAttribI3iEXT := load('glVertexAttribI3iEXT');
  glVertexAttribI4iEXT := load('glVertexAttribI4iEXT');
  glVertexAttribI1uiEXT := load('glVertexAttribI1uiEXT');
  glVertexAttribI2uiEXT := load('glVertexAttribI2uiEXT');
  glVertexAttribI3uiEXT := load('glVertexAttribI3uiEXT');
  glVertexAttribI4uiEXT := load('glVertexAttribI4uiEXT');
  glVertexAttribI1ivEXT := load('glVertexAttribI1ivEXT');
  glVertexAttribI2ivEXT := load('glVertexAttribI2ivEXT');
  glVertexAttribI3ivEXT := load('glVertexAttribI3ivEXT');
  glVertexAttribI4ivEXT := load('glVertexAttribI4ivEXT');
  glVertexAttribI1uivEXT := load('glVertexAttribI1uivEXT');
  glVertexAttribI2uivEXT := load('glVertexAttribI2uivEXT');
  glVertexAttribI3uivEXT := load('glVertexAttribI3uivEXT');
  glVertexAttribI4uivEXT := load('glVertexAttribI4uivEXT');
  glVertexAttribI4bvEXT := load('glVertexAttribI4bvEXT');
  glVertexAttribI4svEXT := load('glVertexAttribI4svEXT');
  glVertexAttribI4ubvEXT := load('glVertexAttribI4ubvEXT');
  glVertexAttribI4usvEXT := load('glVertexAttribI4usvEXT');
  glVertexAttribIPointerEXT := load('glVertexAttribIPointerEXT');
  glGetVertexAttribIivEXT := load('glGetVertexAttribIivEXT');
  glGetVertexAttribIuivEXT := load('glGetVertexAttribIuivEXT');
end;

procedure load_GL_NV_video_capture(load: TLoadProc);
begin
  if not GLAD_GL_NV_video_capture then exit;
  glBeginVideoCaptureNV := load('glBeginVideoCaptureNV');
  glBindVideoCaptureStreamBufferNV := load('glBindVideoCaptureStreamBufferNV');
  glBindVideoCaptureStreamTextureNV := load('glBindVideoCaptureStreamTextureNV');
  glEndVideoCaptureNV := load('glEndVideoCaptureNV');
  glGetVideoCaptureivNV := load('glGetVideoCaptureivNV');
  glGetVideoCaptureStreamivNV := load('glGetVideoCaptureStreamivNV');
  glGetVideoCaptureStreamfvNV := load('glGetVideoCaptureStreamfvNV');
  glGetVideoCaptureStreamdvNV := load('glGetVideoCaptureStreamdvNV');
  glVideoCaptureNV := load('glVideoCaptureNV');
  glVideoCaptureStreamParameterivNV := load('glVideoCaptureStreamParameterivNV');
  glVideoCaptureStreamParameterfvNV := load('glVideoCaptureStreamParameterfvNV');
  glVideoCaptureStreamParameterdvNV := load('glVideoCaptureStreamParameterdvNV');
end;

procedure load_GL_NV_viewport_swizzle(load: TLoadProc);
begin
  if not GLAD_GL_NV_viewport_swizzle then exit;
  glViewportSwizzleNV := load('glViewportSwizzleNV');
end;

procedure load_GL_OES_byte_coordinates(load: TLoadProc);
begin
  if not GLAD_GL_OES_byte_coordinates then exit;
  glMultiTexCoord1bOES := load('glMultiTexCoord1bOES');
  glMultiTexCoord1bvOES := load('glMultiTexCoord1bvOES');
  glMultiTexCoord2bOES := load('glMultiTexCoord2bOES');
  glMultiTexCoord2bvOES := load('glMultiTexCoord2bvOES');
  glMultiTexCoord3bOES := load('glMultiTexCoord3bOES');
  glMultiTexCoord3bvOES := load('glMultiTexCoord3bvOES');
  glMultiTexCoord4bOES := load('glMultiTexCoord4bOES');
  glMultiTexCoord4bvOES := load('glMultiTexCoord4bvOES');
  glTexCoord1bOES := load('glTexCoord1bOES');
  glTexCoord1bvOES := load('glTexCoord1bvOES');
  glTexCoord2bOES := load('glTexCoord2bOES');
  glTexCoord2bvOES := load('glTexCoord2bvOES');
  glTexCoord3bOES := load('glTexCoord3bOES');
  glTexCoord3bvOES := load('glTexCoord3bvOES');
  glTexCoord4bOES := load('glTexCoord4bOES');
  glTexCoord4bvOES := load('glTexCoord4bvOES');
  glVertex2bOES := load('glVertex2bOES');
  glVertex2bvOES := load('glVertex2bvOES');
  glVertex3bOES := load('glVertex3bOES');
  glVertex3bvOES := load('glVertex3bvOES');
  glVertex4bOES := load('glVertex4bOES');
  glVertex4bvOES := load('glVertex4bvOES');
end;

procedure load_GL_OES_fixed_point(load: TLoadProc);
begin
  if not GLAD_GL_OES_fixed_point then exit;
  glAlphaFuncxOES := load('glAlphaFuncxOES');
  glClearColorxOES := load('glClearColorxOES');
  glClearDepthxOES := load('glClearDepthxOES');
  glClipPlanexOES := load('glClipPlanexOES');
  glColor4xOES := load('glColor4xOES');
  glDepthRangexOES := load('glDepthRangexOES');
  glFogxOES := load('glFogxOES');
  glFogxvOES := load('glFogxvOES');
  glFrustumxOES := load('glFrustumxOES');
  glGetClipPlanexOES := load('glGetClipPlanexOES');
  glGetFixedvOES := load('glGetFixedvOES');
  glGetTexEnvxvOES := load('glGetTexEnvxvOES');
  glGetTexParameterxvOES := load('glGetTexParameterxvOES');
  glLightModelxOES := load('glLightModelxOES');
  glLightModelxvOES := load('glLightModelxvOES');
  glLightxOES := load('glLightxOES');
  glLightxvOES := load('glLightxvOES');
  glLineWidthxOES := load('glLineWidthxOES');
  glLoadMatrixxOES := load('glLoadMatrixxOES');
  glMaterialxOES := load('glMaterialxOES');
  glMaterialxvOES := load('glMaterialxvOES');
  glMultMatrixxOES := load('glMultMatrixxOES');
  glMultiTexCoord4xOES := load('glMultiTexCoord4xOES');
  glNormal3xOES := load('glNormal3xOES');
  glOrthoxOES := load('glOrthoxOES');
  glPointParameterxvOES := load('glPointParameterxvOES');
  glPointSizexOES := load('glPointSizexOES');
  glPolygonOffsetxOES := load('glPolygonOffsetxOES');
  glRotatexOES := load('glRotatexOES');
  glScalexOES := load('glScalexOES');
  glTexEnvxOES := load('glTexEnvxOES');
  glTexEnvxvOES := load('glTexEnvxvOES');
  glTexParameterxOES := load('glTexParameterxOES');
  glTexParameterxvOES := load('glTexParameterxvOES');
  glTranslatexOES := load('glTranslatexOES');
  glGetLightxvOES := load('glGetLightxvOES');
  glGetMaterialxvOES := load('glGetMaterialxvOES');
  glPointParameterxOES := load('glPointParameterxOES');
  glSampleCoveragexOES := load('glSampleCoveragexOES');
  glAccumxOES := load('glAccumxOES');
  glBitmapxOES := load('glBitmapxOES');
  glBlendColorxOES := load('glBlendColorxOES');
  glClearAccumxOES := load('glClearAccumxOES');
  glColor3xOES := load('glColor3xOES');
  glColor3xvOES := load('glColor3xvOES');
  glColor4xvOES := load('glColor4xvOES');
  glConvolutionParameterxOES := load('glConvolutionParameterxOES');
  glConvolutionParameterxvOES := load('glConvolutionParameterxvOES');
  glEvalCoord1xOES := load('glEvalCoord1xOES');
  glEvalCoord1xvOES := load('glEvalCoord1xvOES');
  glEvalCoord2xOES := load('glEvalCoord2xOES');
  glEvalCoord2xvOES := load('glEvalCoord2xvOES');
  glFeedbackBufferxOES := load('glFeedbackBufferxOES');
  glGetConvolutionParameterxvOES := load('glGetConvolutionParameterxvOES');
  glGetHistogramParameterxvOES := load('glGetHistogramParameterxvOES');
  glGetLightxOES := load('glGetLightxOES');
  glGetMapxvOES := load('glGetMapxvOES');
  glGetMaterialxOES := load('glGetMaterialxOES');
  glGetPixelMapxv := load('glGetPixelMapxv');
  glGetTexGenxvOES := load('glGetTexGenxvOES');
  glGetTexLevelParameterxvOES := load('glGetTexLevelParameterxvOES');
  glIndexxOES := load('glIndexxOES');
  glIndexxvOES := load('glIndexxvOES');
  glLoadTransposeMatrixxOES := load('glLoadTransposeMatrixxOES');
  glMap1xOES := load('glMap1xOES');
  glMap2xOES := load('glMap2xOES');
  glMapGrid1xOES := load('glMapGrid1xOES');
  glMapGrid2xOES := load('glMapGrid2xOES');
  glMultTransposeMatrixxOES := load('glMultTransposeMatrixxOES');
  glMultiTexCoord1xOES := load('glMultiTexCoord1xOES');
  glMultiTexCoord1xvOES := load('glMultiTexCoord1xvOES');
  glMultiTexCoord2xOES := load('glMultiTexCoord2xOES');
  glMultiTexCoord2xvOES := load('glMultiTexCoord2xvOES');
  glMultiTexCoord3xOES := load('glMultiTexCoord3xOES');
  glMultiTexCoord3xvOES := load('glMultiTexCoord3xvOES');
  glMultiTexCoord4xvOES := load('glMultiTexCoord4xvOES');
  glNormal3xvOES := load('glNormal3xvOES');
  glPassThroughxOES := load('glPassThroughxOES');
  glPixelMapx := load('glPixelMapx');
  glPixelStorex := load('glPixelStorex');
  glPixelTransferxOES := load('glPixelTransferxOES');
  glPixelZoomxOES := load('glPixelZoomxOES');
  glPrioritizeTexturesxOES := load('glPrioritizeTexturesxOES');
  glRasterPos2xOES := load('glRasterPos2xOES');
  glRasterPos2xvOES := load('glRasterPos2xvOES');
  glRasterPos3xOES := load('glRasterPos3xOES');
  glRasterPos3xvOES := load('glRasterPos3xvOES');
  glRasterPos4xOES := load('glRasterPos4xOES');
  glRasterPos4xvOES := load('glRasterPos4xvOES');
  glRectxOES := load('glRectxOES');
  glRectxvOES := load('glRectxvOES');
  glTexCoord1xOES := load('glTexCoord1xOES');
  glTexCoord1xvOES := load('glTexCoord1xvOES');
  glTexCoord2xOES := load('glTexCoord2xOES');
  glTexCoord2xvOES := load('glTexCoord2xvOES');
  glTexCoord3xOES := load('glTexCoord3xOES');
  glTexCoord3xvOES := load('glTexCoord3xvOES');
  glTexCoord4xOES := load('glTexCoord4xOES');
  glTexCoord4xvOES := load('glTexCoord4xvOES');
  glTexGenxOES := load('glTexGenxOES');
  glTexGenxvOES := load('glTexGenxvOES');
  glVertex2xOES := load('glVertex2xOES');
  glVertex2xvOES := load('glVertex2xvOES');
  glVertex3xOES := load('glVertex3xOES');
  glVertex3xvOES := load('glVertex3xvOES');
  glVertex4xOES := load('glVertex4xOES');
  glVertex4xvOES := load('glVertex4xvOES');
end;

procedure load_GL_OES_query_matrix(load: TLoadProc);
begin
  if not GLAD_GL_OES_query_matrix then exit;
  glQueryMatrixxOES := load('glQueryMatrixxOES');
end;

procedure load_GL_OES_single_precision(load: TLoadProc);
begin
  if not GLAD_GL_OES_single_precision then exit;
  glClearDepthfOES := load('glClearDepthfOES');
  glClipPlanefOES := load('glClipPlanefOES');
  glDepthRangefOES := load('glDepthRangefOES');
  glFrustumfOES := load('glFrustumfOES');
  glGetClipPlanefOES := load('glGetClipPlanefOES');
  glOrthofOES := load('glOrthofOES');
end;

procedure load_GL_OVR_multiview(load: TLoadProc);
begin
  if not GLAD_GL_OVR_multiview then exit;
  glFramebufferTextureMultiviewOVR := load('glFramebufferTextureMultiviewOVR');
  glNamedFramebufferTextureMultiviewOVR := load('glNamedFramebufferTextureMultiviewOVR');
end;

procedure load_GL_PGI_misc_hints(load: TLoadProc);
begin
  if not GLAD_GL_PGI_misc_hints then exit;
  glHintPGI := load('glHintPGI');
end;

procedure load_GL_SGIS_detail_texture(load: TLoadProc);
begin
  if not GLAD_GL_SGIS_detail_texture then exit;
  glDetailTexFuncSGIS := load('glDetailTexFuncSGIS');
  glGetDetailTexFuncSGIS := load('glGetDetailTexFuncSGIS');
end;

procedure load_GL_SGIS_fog_function(load: TLoadProc);
begin
  if not GLAD_GL_SGIS_fog_function then exit;
  glFogFuncSGIS := load('glFogFuncSGIS');
  glGetFogFuncSGIS := load('glGetFogFuncSGIS');
end;

procedure load_GL_SGIS_multisample(load: TLoadProc);
begin
  if not GLAD_GL_SGIS_multisample then exit;
  glSampleMaskSGIS := load('glSampleMaskSGIS');
  glSamplePatternSGIS := load('glSamplePatternSGIS');
end;

procedure load_GL_SGIS_pixel_texture(load: TLoadProc);
begin
  if not GLAD_GL_SGIS_pixel_texture then exit;
  glPixelTexGenParameteriSGIS := load('glPixelTexGenParameteriSGIS');
  glPixelTexGenParameterivSGIS := load('glPixelTexGenParameterivSGIS');
  glPixelTexGenParameterfSGIS := load('glPixelTexGenParameterfSGIS');
  glPixelTexGenParameterfvSGIS := load('glPixelTexGenParameterfvSGIS');
  glGetPixelTexGenParameterivSGIS := load('glGetPixelTexGenParameterivSGIS');
  glGetPixelTexGenParameterfvSGIS := load('glGetPixelTexGenParameterfvSGIS');
end;

procedure load_GL_SGIS_point_parameters(load: TLoadProc);
begin
  if not GLAD_GL_SGIS_point_parameters then exit;
  glPointParameterfSGIS := load('glPointParameterfSGIS');
  glPointParameterfvSGIS := load('glPointParameterfvSGIS');
end;

procedure load_GL_SGIS_sharpen_texture(load: TLoadProc);
begin
  if not GLAD_GL_SGIS_sharpen_texture then exit;
  glSharpenTexFuncSGIS := load('glSharpenTexFuncSGIS');
  glGetSharpenTexFuncSGIS := load('glGetSharpenTexFuncSGIS');
end;

procedure load_GL_SGIS_texture4D(load: TLoadProc);
begin
  if not GLAD_GL_SGIS_texture4D then exit;
  glTexImage4DSGIS := load('glTexImage4DSGIS');
  glTexSubImage4DSGIS := load('glTexSubImage4DSGIS');
end;

procedure load_GL_SGIS_texture_color_mask(load: TLoadProc);
begin
  if not GLAD_GL_SGIS_texture_color_mask then exit;
  glTextureColorMaskSGIS := load('glTextureColorMaskSGIS');
end;

procedure load_GL_SGIS_texture_filter4(load: TLoadProc);
begin
  if not GLAD_GL_SGIS_texture_filter4 then exit;
  glGetTexFilterFuncSGIS := load('glGetTexFilterFuncSGIS');
  glTexFilterFuncSGIS := load('glTexFilterFuncSGIS');
end;

procedure load_GL_SGIX_async(load: TLoadProc);
begin
  if not GLAD_GL_SGIX_async then exit;
  glAsyncMarkerSGIX := load('glAsyncMarkerSGIX');
  glFinishAsyncSGIX := load('glFinishAsyncSGIX');
  glPollAsyncSGIX := load('glPollAsyncSGIX');
  glGenAsyncMarkersSGIX := load('glGenAsyncMarkersSGIX');
  glDeleteAsyncMarkersSGIX := load('glDeleteAsyncMarkersSGIX');
  glIsAsyncMarkerSGIX := load('glIsAsyncMarkerSGIX');
end;

procedure load_GL_SGIX_flush_raster(load: TLoadProc);
begin
  if not GLAD_GL_SGIX_flush_raster then exit;
  glFlushRasterSGIX := load('glFlushRasterSGIX');
end;

procedure load_GL_SGIX_fragment_lighting(load: TLoadProc);
begin
  if not GLAD_GL_SGIX_fragment_lighting then exit;
  glFragmentColorMaterialSGIX := load('glFragmentColorMaterialSGIX');
  glFragmentLightfSGIX := load('glFragmentLightfSGIX');
  glFragmentLightfvSGIX := load('glFragmentLightfvSGIX');
  glFragmentLightiSGIX := load('glFragmentLightiSGIX');
  glFragmentLightivSGIX := load('glFragmentLightivSGIX');
  glFragmentLightModelfSGIX := load('glFragmentLightModelfSGIX');
  glFragmentLightModelfvSGIX := load('glFragmentLightModelfvSGIX');
  glFragmentLightModeliSGIX := load('glFragmentLightModeliSGIX');
  glFragmentLightModelivSGIX := load('glFragmentLightModelivSGIX');
  glFragmentMaterialfSGIX := load('glFragmentMaterialfSGIX');
  glFragmentMaterialfvSGIX := load('glFragmentMaterialfvSGIX');
  glFragmentMaterialiSGIX := load('glFragmentMaterialiSGIX');
  glFragmentMaterialivSGIX := load('glFragmentMaterialivSGIX');
  glGetFragmentLightfvSGIX := load('glGetFragmentLightfvSGIX');
  glGetFragmentLightivSGIX := load('glGetFragmentLightivSGIX');
  glGetFragmentMaterialfvSGIX := load('glGetFragmentMaterialfvSGIX');
  glGetFragmentMaterialivSGIX := load('glGetFragmentMaterialivSGIX');
  glLightEnviSGIX := load('glLightEnviSGIX');
end;

procedure load_GL_SGIX_framezoom(load: TLoadProc);
begin
  if not GLAD_GL_SGIX_framezoom then exit;
  glFrameZoomSGIX := load('glFrameZoomSGIX');
end;

procedure load_GL_SGIX_igloo_interface(load: TLoadProc);
begin
  if not GLAD_GL_SGIX_igloo_interface then exit;
  glIglooInterfaceSGIX := load('glIglooInterfaceSGIX');
end;

procedure load_GL_SGIX_instruments(load: TLoadProc);
begin
  if not GLAD_GL_SGIX_instruments then exit;
  glGetInstrumentsSGIX := load('glGetInstrumentsSGIX');
  glInstrumentsBufferSGIX := load('glInstrumentsBufferSGIX');
  glPollInstrumentsSGIX := load('glPollInstrumentsSGIX');
  glReadInstrumentsSGIX := load('glReadInstrumentsSGIX');
  glStartInstrumentsSGIX := load('glStartInstrumentsSGIX');
  glStopInstrumentsSGIX := load('glStopInstrumentsSGIX');
end;

procedure load_GL_SGIX_list_priority(load: TLoadProc);
begin
  if not GLAD_GL_SGIX_list_priority then exit;
  glGetListParameterfvSGIX := load('glGetListParameterfvSGIX');
  glGetListParameterivSGIX := load('glGetListParameterivSGIX');
  glListParameterfSGIX := load('glListParameterfSGIX');
  glListParameterfvSGIX := load('glListParameterfvSGIX');
  glListParameteriSGIX := load('glListParameteriSGIX');
  glListParameterivSGIX := load('glListParameterivSGIX');
end;

procedure load_GL_SGIX_pixel_texture(load: TLoadProc);
begin
  if not GLAD_GL_SGIX_pixel_texture then exit;
  glPixelTexGenSGIX := load('glPixelTexGenSGIX');
end;

procedure load_GL_SGIX_polynomial_ffd(load: TLoadProc);
begin
  if not GLAD_GL_SGIX_polynomial_ffd then exit;
  glDeformationMap3dSGIX := load('glDeformationMap3dSGIX');
  glDeformationMap3fSGIX := load('glDeformationMap3fSGIX');
  glDeformSGIX := load('glDeformSGIX');
  glLoadIdentityDeformationMapSGIX := load('glLoadIdentityDeformationMapSGIX');
end;

procedure load_GL_SGIX_reference_plane(load: TLoadProc);
begin
  if not GLAD_GL_SGIX_reference_plane then exit;
  glReferencePlaneSGIX := load('glReferencePlaneSGIX');
end;

procedure load_GL_SGIX_sprite(load: TLoadProc);
begin
  if not GLAD_GL_SGIX_sprite then exit;
  glSpriteParameterfSGIX := load('glSpriteParameterfSGIX');
  glSpriteParameterfvSGIX := load('glSpriteParameterfvSGIX');
  glSpriteParameteriSGIX := load('glSpriteParameteriSGIX');
  glSpriteParameterivSGIX := load('glSpriteParameterivSGIX');
end;

procedure load_GL_SGIX_tag_sample_buffer(load: TLoadProc);
begin
  if not GLAD_GL_SGIX_tag_sample_buffer then exit;
  glTagSampleBufferSGIX := load('glTagSampleBufferSGIX');
end;

procedure load_GL_SGI_color_table(load: TLoadProc);
begin
  if not GLAD_GL_SGI_color_table then exit;
  glColorTableSGI := load('glColorTableSGI');
  glColorTableParameterfvSGI := load('glColorTableParameterfvSGI');
  glColorTableParameterivSGI := load('glColorTableParameterivSGI');
  glCopyColorTableSGI := load('glCopyColorTableSGI');
  glGetColorTableSGI := load('glGetColorTableSGI');
  glGetColorTableParameterfvSGI := load('glGetColorTableParameterfvSGI');
  glGetColorTableParameterivSGI := load('glGetColorTableParameterivSGI');
end;

procedure load_GL_SUNX_constant_data(load: TLoadProc);
begin
  if not GLAD_GL_SUNX_constant_data then exit;
  glFinishTextureSUNX := load('glFinishTextureSUNX');
end;

procedure load_GL_SUN_global_alpha(load: TLoadProc);
begin
  if not GLAD_GL_SUN_global_alpha then exit;
  glGlobalAlphaFactorbSUN := load('glGlobalAlphaFactorbSUN');
  glGlobalAlphaFactorsSUN := load('glGlobalAlphaFactorsSUN');
  glGlobalAlphaFactoriSUN := load('glGlobalAlphaFactoriSUN');
  glGlobalAlphaFactorfSUN := load('glGlobalAlphaFactorfSUN');
  glGlobalAlphaFactordSUN := load('glGlobalAlphaFactordSUN');
  glGlobalAlphaFactorubSUN := load('glGlobalAlphaFactorubSUN');
  glGlobalAlphaFactorusSUN := load('glGlobalAlphaFactorusSUN');
  glGlobalAlphaFactoruiSUN := load('glGlobalAlphaFactoruiSUN');
end;

procedure load_GL_SUN_mesh_array(load: TLoadProc);
begin
  if not GLAD_GL_SUN_mesh_array then exit;
  glDrawMeshArraysSUN := load('glDrawMeshArraysSUN');
end;

procedure load_GL_SUN_triangle_list(load: TLoadProc);
begin
  if not GLAD_GL_SUN_triangle_list then exit;
  glReplacementCodeuiSUN := load('glReplacementCodeuiSUN');
  glReplacementCodeusSUN := load('glReplacementCodeusSUN');
  glReplacementCodeubSUN := load('glReplacementCodeubSUN');
  glReplacementCodeuivSUN := load('glReplacementCodeuivSUN');
  glReplacementCodeusvSUN := load('glReplacementCodeusvSUN');
  glReplacementCodeubvSUN := load('glReplacementCodeubvSUN');
  glReplacementCodePointerSUN := load('glReplacementCodePointerSUN');
end;

procedure load_GL_SUN_vertex(load: TLoadProc);
begin
  if not GLAD_GL_SUN_vertex then exit;
  glColor4ubVertex2fSUN := load('glColor4ubVertex2fSUN');
  glColor4ubVertex2fvSUN := load('glColor4ubVertex2fvSUN');
  glColor4ubVertex3fSUN := load('glColor4ubVertex3fSUN');
  glColor4ubVertex3fvSUN := load('glColor4ubVertex3fvSUN');
  glColor3fVertex3fSUN := load('glColor3fVertex3fSUN');
  glColor3fVertex3fvSUN := load('glColor3fVertex3fvSUN');
  glNormal3fVertex3fSUN := load('glNormal3fVertex3fSUN');
  glNormal3fVertex3fvSUN := load('glNormal3fVertex3fvSUN');
  glColor4fNormal3fVertex3fSUN := load('glColor4fNormal3fVertex3fSUN');
  glColor4fNormal3fVertex3fvSUN := load('glColor4fNormal3fVertex3fvSUN');
  glTexCoord2fVertex3fSUN := load('glTexCoord2fVertex3fSUN');
  glTexCoord2fVertex3fvSUN := load('glTexCoord2fVertex3fvSUN');
  glTexCoord4fVertex4fSUN := load('glTexCoord4fVertex4fSUN');
  glTexCoord4fVertex4fvSUN := load('glTexCoord4fVertex4fvSUN');
  glTexCoord2fColor4ubVertex3fSUN := load('glTexCoord2fColor4ubVertex3fSUN');
  glTexCoord2fColor4ubVertex3fvSUN := load('glTexCoord2fColor4ubVertex3fvSUN');
  glTexCoord2fColor3fVertex3fSUN := load('glTexCoord2fColor3fVertex3fSUN');
  glTexCoord2fColor3fVertex3fvSUN := load('glTexCoord2fColor3fVertex3fvSUN');
  glTexCoord2fNormal3fVertex3fSUN := load('glTexCoord2fNormal3fVertex3fSUN');
  glTexCoord2fNormal3fVertex3fvSUN := load('glTexCoord2fNormal3fVertex3fvSUN');
  glTexCoord2fColor4fNormal3fVertex3fSUN := load('glTexCoord2fColor4fNormal3fVertex3fSUN');
  glTexCoord2fColor4fNormal3fVertex3fvSUN := load('glTexCoord2fColor4fNormal3fVertex3fvSUN');
  glTexCoord4fColor4fNormal3fVertex4fSUN := load('glTexCoord4fColor4fNormal3fVertex4fSUN');
  glTexCoord4fColor4fNormal3fVertex4fvSUN := load('glTexCoord4fColor4fNormal3fVertex4fvSUN');
  glReplacementCodeuiVertex3fSUN := load('glReplacementCodeuiVertex3fSUN');
  glReplacementCodeuiVertex3fvSUN := load('glReplacementCodeuiVertex3fvSUN');
  glReplacementCodeuiColor4ubVertex3fSUN := load('glReplacementCodeuiColor4ubVertex3fSUN');
  glReplacementCodeuiColor4ubVertex3fvSUN := load('glReplacementCodeuiColor4ubVertex3fvSUN');
  glReplacementCodeuiColor3fVertex3fSUN := load('glReplacementCodeuiColor3fVertex3fSUN');
  glReplacementCodeuiColor3fVertex3fvSUN := load('glReplacementCodeuiColor3fVertex3fvSUN');
  glReplacementCodeuiNormal3fVertex3fSUN := load('glReplacementCodeuiNormal3fVertex3fSUN');
  glReplacementCodeuiNormal3fVertex3fvSUN := load('glReplacementCodeuiNormal3fVertex3fvSUN');
  glReplacementCodeuiColor4fNormal3fVertex3fSUN := load('glReplacementCodeuiColor4fNormal3fVertex3fSUN');
  glReplacementCodeuiColor4fNormal3fVertex3fvSUN := load('glReplacementCodeuiColor4fNormal3fVertex3fvSUN');
  glReplacementCodeuiTexCoord2fVertex3fSUN := load('glReplacementCodeuiTexCoord2fVertex3fSUN');
  glReplacementCodeuiTexCoord2fVertex3fvSUN := load('glReplacementCodeuiTexCoord2fVertex3fvSUN');
  glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN := load('glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN');
  glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN := load('glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN');
  glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN := load('glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN');
  glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN := load('glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN');
end;

//procedure findExtensionsGL();
//begin
//  GLAD_GL_3DFX_multisample := hasExt('GL_3DFX_multisample');
//  GLAD_GL_3DFX_tbuffer := hasExt('GL_3DFX_tbuffer');
//  GLAD_GL_3DFX_texture_compression_FXT1 := hasExt('GL_3DFX_texture_compression_FXT1');
//  GLAD_GL_AMD_blend_minmax_factor := hasExt('GL_AMD_blend_minmax_factor');
//  GLAD_GL_AMD_conservative_depth := hasExt('GL_AMD_conservative_depth');
//  GLAD_GL_AMD_debug_output := hasExt('GL_AMD_debug_output');
//  GLAD_GL_AMD_depth_clamp_separate := hasExt('GL_AMD_depth_clamp_separate');
//  GLAD_GL_AMD_draw_buffers_blend := hasExt('GL_AMD_draw_buffers_blend');
//  GLAD_GL_AMD_framebuffer_multisample_advanced := hasExt('GL_AMD_framebuffer_multisample_advanced');
//  GLAD_GL_AMD_framebuffer_sample_positions := hasExt('GL_AMD_framebuffer_sample_positions');
//  GLAD_GL_AMD_gcn_shader := hasExt('GL_AMD_gcn_shader');
//  GLAD_GL_AMD_gpu_shader_half_float := hasExt('GL_AMD_gpu_shader_half_float');
//  GLAD_GL_AMD_gpu_shader_int16 := hasExt('GL_AMD_gpu_shader_int16');
//  GLAD_GL_AMD_gpu_shader_int64 := hasExt('GL_AMD_gpu_shader_int64');
//  GLAD_GL_AMD_interleaved_elements := hasExt('GL_AMD_interleaved_elements');
//  GLAD_GL_AMD_multi_draw_indirect := hasExt('GL_AMD_multi_draw_indirect');
//  GLAD_GL_AMD_name_gen_delete := hasExt('GL_AMD_name_gen_delete');
//  GLAD_GL_AMD_occlusion_query_event := hasExt('GL_AMD_occlusion_query_event');
//  GLAD_GL_AMD_performance_monitor := hasExt('GL_AMD_performance_monitor');
//  GLAD_GL_AMD_pinned_memory := hasExt('GL_AMD_pinned_memory');
//  GLAD_GL_AMD_query_buffer_object := hasExt('GL_AMD_query_buffer_object');
//  GLAD_GL_AMD_sample_positions := hasExt('GL_AMD_sample_positions');
//  GLAD_GL_AMD_seamless_cubemap_per_texture := hasExt('GL_AMD_seamless_cubemap_per_texture');
//  GLAD_GL_AMD_shader_atomic_counter_ops := hasExt('GL_AMD_shader_atomic_counter_ops');
//  GLAD_GL_AMD_shader_ballot := hasExt('GL_AMD_shader_ballot');
//  GLAD_GL_AMD_shader_explicit_vertex_parameter := hasExt('GL_AMD_shader_explicit_vertex_parameter');
//  GLAD_GL_AMD_shader_gpu_shader_half_float_fetch := hasExt('GL_AMD_shader_gpu_shader_half_float_fetch');
//  GLAD_GL_AMD_shader_image_load_store_lod := hasExt('GL_AMD_shader_image_load_store_lod');
//  GLAD_GL_AMD_shader_stencil_export := hasExt('GL_AMD_shader_stencil_export');
//  GLAD_GL_AMD_shader_trinary_minmax := hasExt('GL_AMD_shader_trinary_minmax');
//  GLAD_GL_AMD_sparse_texture := hasExt('GL_AMD_sparse_texture');
//  GLAD_GL_AMD_stencil_operation_extended := hasExt('GL_AMD_stencil_operation_extended');
//  GLAD_GL_AMD_texture_gather_bias_lod := hasExt('GL_AMD_texture_gather_bias_lod');
//  GLAD_GL_AMD_texture_texture4 := hasExt('GL_AMD_texture_texture4');
//  GLAD_GL_AMD_transform_feedback3_lines_triangles := hasExt('GL_AMD_transform_feedback3_lines_triangles');
//  GLAD_GL_AMD_transform_feedback4 := hasExt('GL_AMD_transform_feedback4');
//  GLAD_GL_AMD_vertex_shader_layer := hasExt('GL_AMD_vertex_shader_layer');
//  GLAD_GL_AMD_vertex_shader_tessellator := hasExt('GL_AMD_vertex_shader_tessellator');
//  GLAD_GL_AMD_vertex_shader_viewport_index := hasExt('GL_AMD_vertex_shader_viewport_index');
//  GLAD_GL_APPLE_aux_depth_stencil := hasExt('GL_APPLE_aux_depth_stencil');
//  GLAD_GL_APPLE_client_storage := hasExt('GL_APPLE_client_storage');
//  GLAD_GL_APPLE_element_array := hasExt('GL_APPLE_element_array');
//  GLAD_GL_APPLE_fence := hasExt('GL_APPLE_fence');
//  GLAD_GL_APPLE_float_pixels := hasExt('GL_APPLE_float_pixels');
//  GLAD_GL_APPLE_flush_buffer_range := hasExt('GL_APPLE_flush_buffer_range');
//  GLAD_GL_APPLE_object_purgeable := hasExt('GL_APPLE_object_purgeable');
//  GLAD_GL_APPLE_rgb_422 := hasExt('GL_APPLE_rgb_422');
//  GLAD_GL_APPLE_row_bytes := hasExt('GL_APPLE_row_bytes');
//  GLAD_GL_APPLE_specular_vector := hasExt('GL_APPLE_specular_vector');
//  GLAD_GL_APPLE_texture_range := hasExt('GL_APPLE_texture_range');
//  GLAD_GL_APPLE_transform_hint := hasExt('GL_APPLE_transform_hint');
//  GLAD_GL_APPLE_vertex_array_object := hasExt('GL_APPLE_vertex_array_object');
//  GLAD_GL_APPLE_vertex_array_range := hasExt('GL_APPLE_vertex_array_range');
//  GLAD_GL_APPLE_vertex_program_evaluators := hasExt('GL_APPLE_vertex_program_evaluators');
//  GLAD_GL_APPLE_ycbcr_422 := hasExt('GL_APPLE_ycbcr_422');
//  GLAD_GL_ARB_ES2_compatibility := hasExt('GL_ARB_ES2_compatibility');
//  GLAD_GL_ARB_ES3_1_compatibility := hasExt('GL_ARB_ES3_1_compatibility');
//  GLAD_GL_ARB_ES3_2_compatibility := hasExt('GL_ARB_ES3_2_compatibility');
//  GLAD_GL_ARB_ES3_compatibility := hasExt('GL_ARB_ES3_compatibility');
//  GLAD_GL_ARB_arrays_of_arrays := hasExt('GL_ARB_arrays_of_arrays');
//  GLAD_GL_ARB_base_instance := hasExt('GL_ARB_base_instance');
//  GLAD_GL_ARB_bindless_texture := hasExt('GL_ARB_bindless_texture');
//  GLAD_GL_ARB_blend_func_extended := hasExt('GL_ARB_blend_func_extended');
//  GLAD_GL_ARB_buffer_storage := hasExt('GL_ARB_buffer_storage');
//  GLAD_GL_ARB_cl_event := hasExt('GL_ARB_cl_event');
//  GLAD_GL_ARB_clear_buffer_object := hasExt('GL_ARB_clear_buffer_object');
//  GLAD_GL_ARB_clear_texture := hasExt('GL_ARB_clear_texture');
//  GLAD_GL_ARB_clip_control := hasExt('GL_ARB_clip_control');
//  GLAD_GL_ARB_color_buffer_float := hasExt('GL_ARB_color_buffer_float');
//  GLAD_GL_ARB_compatibility := hasExt('GL_ARB_compatibility');
//  GLAD_GL_ARB_compressed_texture_pixel_storage := hasExt('GL_ARB_compressed_texture_pixel_storage');
//  GLAD_GL_ARB_compute_shader := hasExt('GL_ARB_compute_shader');
//  GLAD_GL_ARB_compute_variable_group_size := hasExt('GL_ARB_compute_variable_group_size');
//  GLAD_GL_ARB_conditional_render_inverted := hasExt('GL_ARB_conditional_render_inverted');
//  GLAD_GL_ARB_conservative_depth := hasExt('GL_ARB_conservative_depth');
//  GLAD_GL_ARB_copy_buffer := hasExt('GL_ARB_copy_buffer');
//  GLAD_GL_ARB_copy_image := hasExt('GL_ARB_copy_image');
//  GLAD_GL_ARB_cull_distance := hasExt('GL_ARB_cull_distance');
//  GLAD_GL_ARB_debug_output := hasExt('GL_ARB_debug_output');
//  GLAD_GL_ARB_depth_buffer_float := hasExt('GL_ARB_depth_buffer_float');
//  GLAD_GL_ARB_depth_clamp := hasExt('GL_ARB_depth_clamp');
//  GLAD_GL_ARB_depth_texture := hasExt('GL_ARB_depth_texture');
//  GLAD_GL_ARB_derivative_control := hasExt('GL_ARB_derivative_control');
//  GLAD_GL_ARB_direct_state_access := hasExt('GL_ARB_direct_state_access');
//  GLAD_GL_ARB_draw_buffers := hasExt('GL_ARB_draw_buffers');
//  GLAD_GL_ARB_draw_buffers_blend := hasExt('GL_ARB_draw_buffers_blend');
//  GLAD_GL_ARB_draw_elements_base_vertex := hasExt('GL_ARB_draw_elements_base_vertex');
//  GLAD_GL_ARB_draw_indirect := hasExt('GL_ARB_draw_indirect');
//  GLAD_GL_ARB_draw_instanced := hasExt('GL_ARB_draw_instanced');
//  GLAD_GL_ARB_enhanced_layouts := hasExt('GL_ARB_enhanced_layouts');
//  GLAD_GL_ARB_explicit_attrib_location := hasExt('GL_ARB_explicit_attrib_location');
//  GLAD_GL_ARB_explicit_uniform_location := hasExt('GL_ARB_explicit_uniform_location');
//  GLAD_GL_ARB_fragment_coord_conventions := hasExt('GL_ARB_fragment_coord_conventions');
//  GLAD_GL_ARB_fragment_layer_viewport := hasExt('GL_ARB_fragment_layer_viewport');
//  GLAD_GL_ARB_fragment_program := hasExt('GL_ARB_fragment_program');
//  GLAD_GL_ARB_fragment_program_shadow := hasExt('GL_ARB_fragment_program_shadow');
//  GLAD_GL_ARB_fragment_shader := hasExt('GL_ARB_fragment_shader');
//  GLAD_GL_ARB_fragment_shader_interlock := hasExt('GL_ARB_fragment_shader_interlock');
//  GLAD_GL_ARB_framebuffer_no_attachments := hasExt('GL_ARB_framebuffer_no_attachments');
//  GLAD_GL_ARB_framebuffer_object := hasExt('GL_ARB_framebuffer_object');
//  GLAD_GL_ARB_framebuffer_sRGB := hasExt('GL_ARB_framebuffer_sRGB');
//  GLAD_GL_ARB_geometry_shader4 := hasExt('GL_ARB_geometry_shader4');
//  GLAD_GL_ARB_get_program_binary := hasExt('GL_ARB_get_program_binary');
//  GLAD_GL_ARB_get_texture_sub_image := hasExt('GL_ARB_get_texture_sub_image');
//  GLAD_GL_ARB_gl_spirv := hasExt('GL_ARB_gl_spirv');
//  GLAD_GL_ARB_gpu_shader5 := hasExt('GL_ARB_gpu_shader5');
//  GLAD_GL_ARB_gpu_shader_fp64 := hasExt('GL_ARB_gpu_shader_fp64');
//  GLAD_GL_ARB_gpu_shader_int64 := hasExt('GL_ARB_gpu_shader_int64');
//  GLAD_GL_ARB_half_float_pixel := hasExt('GL_ARB_half_float_pixel');
//  GLAD_GL_ARB_half_float_vertex := hasExt('GL_ARB_half_float_vertex');
//  GLAD_GL_ARB_imaging := hasExt('GL_ARB_imaging');
//  GLAD_GL_ARB_indirect_parameters := hasExt('GL_ARB_indirect_parameters');
//  GLAD_GL_ARB_instanced_arrays := hasExt('GL_ARB_instanced_arrays');
//  GLAD_GL_ARB_internalformat_query := hasExt('GL_ARB_internalformat_query');
//  GLAD_GL_ARB_internalformat_query2 := hasExt('GL_ARB_internalformat_query2');
//  GLAD_GL_ARB_invalidate_subdata := hasExt('GL_ARB_invalidate_subdata');
//  GLAD_GL_ARB_map_buffer_alignment := hasExt('GL_ARB_map_buffer_alignment');
//  GLAD_GL_ARB_map_buffer_range := hasExt('GL_ARB_map_buffer_range');
//  GLAD_GL_ARB_matrix_palette := hasExt('GL_ARB_matrix_palette');
//  GLAD_GL_ARB_multi_bind := hasExt('GL_ARB_multi_bind');
//  GLAD_GL_ARB_multi_draw_indirect := hasExt('GL_ARB_multi_draw_indirect');
//  GLAD_GL_ARB_multisample := hasExt('GL_ARB_multisample');
//  GLAD_GL_ARB_multitexture := hasExt('GL_ARB_multitexture');
//  GLAD_GL_ARB_occlusion_query := hasExt('GL_ARB_occlusion_query');
//  GLAD_GL_ARB_occlusion_query2 := hasExt('GL_ARB_occlusion_query2');
//  GLAD_GL_ARB_parallel_shader_compile := hasExt('GL_ARB_parallel_shader_compile');
//  GLAD_GL_ARB_pipeline_statistics_query := hasExt('GL_ARB_pipeline_statistics_query');
//  GLAD_GL_ARB_pixel_buffer_object := hasExt('GL_ARB_pixel_buffer_object');
//  GLAD_GL_ARB_point_parameters := hasExt('GL_ARB_point_parameters');
//  GLAD_GL_ARB_point_sprite := hasExt('GL_ARB_point_sprite');
//  GLAD_GL_ARB_polygon_offset_clamp := hasExt('GL_ARB_polygon_offset_clamp');
//  GLAD_GL_ARB_post_depth_coverage := hasExt('GL_ARB_post_depth_coverage');
//  GLAD_GL_ARB_program_interface_query := hasExt('GL_ARB_program_interface_query');
//  GLAD_GL_ARB_provoking_vertex := hasExt('GL_ARB_provoking_vertex');
//  GLAD_GL_ARB_query_buffer_object := hasExt('GL_ARB_query_buffer_object');
//  GLAD_GL_ARB_robust_buffer_access_behavior := hasExt('GL_ARB_robust_buffer_access_behavior');
//  GLAD_GL_ARB_robustness := hasExt('GL_ARB_robustness');
//  GLAD_GL_ARB_robustness_isolation := hasExt('GL_ARB_robustness_isolation');
//  GLAD_GL_ARB_sample_locations := hasExt('GL_ARB_sample_locations');
//  GLAD_GL_ARB_sample_shading := hasExt('GL_ARB_sample_shading');
//  GLAD_GL_ARB_sampler_objects := hasExt('GL_ARB_sampler_objects');
//  GLAD_GL_ARB_seamless_cube_map := hasExt('GL_ARB_seamless_cube_map');
//  GLAD_GL_ARB_seamless_cubemap_per_texture := hasExt('GL_ARB_seamless_cubemap_per_texture');
//  GLAD_GL_ARB_separate_shader_objects := hasExt('GL_ARB_separate_shader_objects');
//  GLAD_GL_ARB_shader_atomic_counter_ops := hasExt('GL_ARB_shader_atomic_counter_ops');
//  GLAD_GL_ARB_shader_atomic_counters := hasExt('GL_ARB_shader_atomic_counters');
//  GLAD_GL_ARB_shader_ballot := hasExt('GL_ARB_shader_ballot');
//  GLAD_GL_ARB_shader_bit_encoding := hasExt('GL_ARB_shader_bit_encoding');
//  GLAD_GL_ARB_shader_clock := hasExt('GL_ARB_shader_clock');
//  GLAD_GL_ARB_shader_draw_parameters := hasExt('GL_ARB_shader_draw_parameters');
//  GLAD_GL_ARB_shader_group_vote := hasExt('GL_ARB_shader_group_vote');
//  GLAD_GL_ARB_shader_image_load_store := hasExt('GL_ARB_shader_image_load_store');
//  GLAD_GL_ARB_shader_image_size := hasExt('GL_ARB_shader_image_size');
//  GLAD_GL_ARB_shader_objects := hasExt('GL_ARB_shader_objects');
//  GLAD_GL_ARB_shader_precision := hasExt('GL_ARB_shader_precision');
//  GLAD_GL_ARB_shader_stencil_export := hasExt('GL_ARB_shader_stencil_export');
//  GLAD_GL_ARB_shader_storage_buffer_object := hasExt('GL_ARB_shader_storage_buffer_object');
//  GLAD_GL_ARB_shader_subroutine := hasExt('GL_ARB_shader_subroutine');
//  GLAD_GL_ARB_shader_texture_image_samples := hasExt('GL_ARB_shader_texture_image_samples');
//  GLAD_GL_ARB_shader_texture_lod := hasExt('GL_ARB_shader_texture_lod');
//  GLAD_GL_ARB_shader_viewport_layer_array := hasExt('GL_ARB_shader_viewport_layer_array');
//  GLAD_GL_ARB_shading_language_100 := hasExt('GL_ARB_shading_language_100');
//  GLAD_GL_ARB_shading_language_420pack := hasExt('GL_ARB_shading_language_420pack');
//  GLAD_GL_ARB_shading_language_include := hasExt('GL_ARB_shading_language_include');
//  GLAD_GL_ARB_shading_language_packing := hasExt('GL_ARB_shading_language_packing');
//  GLAD_GL_ARB_shadow := hasExt('GL_ARB_shadow');
//  GLAD_GL_ARB_shadow_ambient := hasExt('GL_ARB_shadow_ambient');
//  GLAD_GL_ARB_sparse_buffer := hasExt('GL_ARB_sparse_buffer');
//  GLAD_GL_ARB_sparse_texture := hasExt('GL_ARB_sparse_texture');
//  GLAD_GL_ARB_sparse_texture2 := hasExt('GL_ARB_sparse_texture2');
//  GLAD_GL_ARB_sparse_texture_clamp := hasExt('GL_ARB_sparse_texture_clamp');
//  GLAD_GL_ARB_spirv_extensions := hasExt('GL_ARB_spirv_extensions');
//  GLAD_GL_ARB_stencil_texturing := hasExt('GL_ARB_stencil_texturing');
//  GLAD_GL_ARB_sync := hasExt('GL_ARB_sync');
//  GLAD_GL_ARB_tessellation_shader := hasExt('GL_ARB_tessellation_shader');
//  GLAD_GL_ARB_texture_barrier := hasExt('GL_ARB_texture_barrier');
//  GLAD_GL_ARB_texture_border_clamp := hasExt('GL_ARB_texture_border_clamp');
//  GLAD_GL_ARB_texture_buffer_object := hasExt('GL_ARB_texture_buffer_object');
//  GLAD_GL_ARB_texture_buffer_object_rgb32 := hasExt('GL_ARB_texture_buffer_object_rgb32');
//  GLAD_GL_ARB_texture_buffer_range := hasExt('GL_ARB_texture_buffer_range');
//  GLAD_GL_ARB_texture_compression := hasExt('GL_ARB_texture_compression');
//  GLAD_GL_ARB_texture_compression_bptc := hasExt('GL_ARB_texture_compression_bptc');
//  GLAD_GL_ARB_texture_compression_rgtc := hasExt('GL_ARB_texture_compression_rgtc');
//  GLAD_GL_ARB_texture_cube_map := hasExt('GL_ARB_texture_cube_map');
//  GLAD_GL_ARB_texture_cube_map_array := hasExt('GL_ARB_texture_cube_map_array');
//  GLAD_GL_ARB_texture_env_add := hasExt('GL_ARB_texture_env_add');
//  GLAD_GL_ARB_texture_env_combine := hasExt('GL_ARB_texture_env_combine');
//  GLAD_GL_ARB_texture_env_crossbar := hasExt('GL_ARB_texture_env_crossbar');
//  GLAD_GL_ARB_texture_env_dot3 := hasExt('GL_ARB_texture_env_dot3');
//  GLAD_GL_ARB_texture_filter_anisotropic := hasExt('GL_ARB_texture_filter_anisotropic');
//  GLAD_GL_ARB_texture_filter_minmax := hasExt('GL_ARB_texture_filter_minmax');
//  GLAD_GL_ARB_texture_float := hasExt('GL_ARB_texture_float');
//  GLAD_GL_ARB_texture_gather := hasExt('GL_ARB_texture_gather');
//  GLAD_GL_ARB_texture_mirror_clamp_to_edge := hasExt('GL_ARB_texture_mirror_clamp_to_edge');
//  GLAD_GL_ARB_texture_mirrored_repeat := hasExt('GL_ARB_texture_mirrored_repeat');
//  GLAD_GL_ARB_texture_multisample := hasExt('GL_ARB_texture_multisample');
//  GLAD_GL_ARB_texture_non_power_of_two := hasExt('GL_ARB_texture_non_power_of_two');
//  GLAD_GL_ARB_texture_query_levels := hasExt('GL_ARB_texture_query_levels');
//  GLAD_GL_ARB_texture_query_lod := hasExt('GL_ARB_texture_query_lod');
//  GLAD_GL_ARB_texture_rectangle := hasExt('GL_ARB_texture_rectangle');
//  GLAD_GL_ARB_texture_rg := hasExt('GL_ARB_texture_rg');
//  GLAD_GL_ARB_texture_rgb10_a2ui := hasExt('GL_ARB_texture_rgb10_a2ui');
//  GLAD_GL_ARB_texture_stencil8 := hasExt('GL_ARB_texture_stencil8');
//  GLAD_GL_ARB_texture_storage := hasExt('GL_ARB_texture_storage');
//  GLAD_GL_ARB_texture_storage_multisample := hasExt('GL_ARB_texture_storage_multisample');
//  GLAD_GL_ARB_texture_swizzle := hasExt('GL_ARB_texture_swizzle');
//  GLAD_GL_ARB_texture_view := hasExt('GL_ARB_texture_view');
//  GLAD_GL_ARB_timer_query := hasExt('GL_ARB_timer_query');
//  GLAD_GL_ARB_transform_feedback2 := hasExt('GL_ARB_transform_feedback2');
//  GLAD_GL_ARB_transform_feedback3 := hasExt('GL_ARB_transform_feedback3');
//  GLAD_GL_ARB_transform_feedback_instanced := hasExt('GL_ARB_transform_feedback_instanced');
//  GLAD_GL_ARB_transform_feedback_overflow_query := hasExt('GL_ARB_transform_feedback_overflow_query');
//  GLAD_GL_ARB_transpose_matrix := hasExt('GL_ARB_transpose_matrix');
//  GLAD_GL_ARB_uniform_buffer_object := hasExt('GL_ARB_uniform_buffer_object');
//  GLAD_GL_ARB_vertex_array_bgra := hasExt('GL_ARB_vertex_array_bgra');
//  GLAD_GL_ARB_vertex_array_object := hasExt('GL_ARB_vertex_array_object');
//  GLAD_GL_ARB_vertex_attrib_64bit := hasExt('GL_ARB_vertex_attrib_64bit');
//  GLAD_GL_ARB_vertex_attrib_binding := hasExt('GL_ARB_vertex_attrib_binding');
//  GLAD_GL_ARB_vertex_blend := hasExt('GL_ARB_vertex_blend');
//  GLAD_GL_ARB_vertex_buffer_object := hasExt('GL_ARB_vertex_buffer_object');
//  GLAD_GL_ARB_vertex_program := hasExt('GL_ARB_vertex_program');
//  GLAD_GL_ARB_vertex_shader := hasExt('GL_ARB_vertex_shader');
//  GLAD_GL_ARB_vertex_type_10f_11f_11f_rev := hasExt('GL_ARB_vertex_type_10f_11f_11f_rev');
//  GLAD_GL_ARB_vertex_type_2_10_10_10_rev := hasExt('GL_ARB_vertex_type_2_10_10_10_rev');
//  GLAD_GL_ARB_viewport_array := hasExt('GL_ARB_viewport_array');
//  GLAD_GL_ARB_window_pos := hasExt('GL_ARB_window_pos');
//  GLAD_GL_ATI_draw_buffers := hasExt('GL_ATI_draw_buffers');
//  GLAD_GL_ATI_element_array := hasExt('GL_ATI_element_array');
//  GLAD_GL_ATI_envmap_bumpmap := hasExt('GL_ATI_envmap_bumpmap');
//  GLAD_GL_ATI_fragment_shader := hasExt('GL_ATI_fragment_shader');
//  GLAD_GL_ATI_map_object_buffer := hasExt('GL_ATI_map_object_buffer');
//  GLAD_GL_ATI_meminfo := hasExt('GL_ATI_meminfo');
//  GLAD_GL_ATI_pixel_format_float := hasExt('GL_ATI_pixel_format_float');
//  GLAD_GL_ATI_pn_triangles := hasExt('GL_ATI_pn_triangles');
//  GLAD_GL_ATI_separate_stencil := hasExt('GL_ATI_separate_stencil');
//  GLAD_GL_ATI_text_fragment_shader := hasExt('GL_ATI_text_fragment_shader');
//  GLAD_GL_ATI_texture_env_combine3 := hasExt('GL_ATI_texture_env_combine3');
//  GLAD_GL_ATI_texture_float := hasExt('GL_ATI_texture_float');
//  GLAD_GL_ATI_texture_mirror_once := hasExt('GL_ATI_texture_mirror_once');
//  GLAD_GL_ATI_vertex_array_object := hasExt('GL_ATI_vertex_array_object');
//  GLAD_GL_ATI_vertex_attrib_array_object := hasExt('GL_ATI_vertex_attrib_array_object');
//  GLAD_GL_ATI_vertex_streams := hasExt('GL_ATI_vertex_streams');
//  GLAD_GL_EXT_422_pixels := hasExt('GL_EXT_422_pixels');
//  GLAD_GL_EXT_EGL_image_storage := hasExt('GL_EXT_EGL_image_storage');
//  GLAD_GL_EXT_EGL_sync := hasExt('GL_EXT_EGL_sync');
//  GLAD_GL_EXT_abgr := hasExt('GL_EXT_abgr');
//  GLAD_GL_EXT_bgra := hasExt('GL_EXT_bgra');
//  GLAD_GL_EXT_bindable_uniform := hasExt('GL_EXT_bindable_uniform');
//  GLAD_GL_EXT_blend_color := hasExt('GL_EXT_blend_color');
//  GLAD_GL_EXT_blend_equation_separate := hasExt('GL_EXT_blend_equation_separate');
//  GLAD_GL_EXT_blend_func_separate := hasExt('GL_EXT_blend_func_separate');
//  GLAD_GL_EXT_blend_logic_op := hasExt('GL_EXT_blend_logic_op');
//  GLAD_GL_EXT_blend_minmax := hasExt('GL_EXT_blend_minmax');
//  GLAD_GL_EXT_blend_subtract := hasExt('GL_EXT_blend_subtract');
//  GLAD_GL_EXT_clip_volume_hint := hasExt('GL_EXT_clip_volume_hint');
//  GLAD_GL_EXT_cmyka := hasExt('GL_EXT_cmyka');
//  GLAD_GL_EXT_color_subtable := hasExt('GL_EXT_color_subtable');
//  GLAD_GL_EXT_compiled_vertex_array := hasExt('GL_EXT_compiled_vertex_array');
//  GLAD_GL_EXT_convolution := hasExt('GL_EXT_convolution');
//  GLAD_GL_EXT_coordinate_frame := hasExt('GL_EXT_coordinate_frame');
//  GLAD_GL_EXT_copy_texture := hasExt('GL_EXT_copy_texture');
//  GLAD_GL_EXT_cull_vertex := hasExt('GL_EXT_cull_vertex');
//  GLAD_GL_EXT_debug_label := hasExt('GL_EXT_debug_label');
//  GLAD_GL_EXT_debug_marker := hasExt('GL_EXT_debug_marker');
//  GLAD_GL_EXT_depth_bounds_test := hasExt('GL_EXT_depth_bounds_test');
//  GLAD_GL_EXT_direct_state_access := hasExt('GL_EXT_direct_state_access');
//  GLAD_GL_EXT_draw_buffers2 := hasExt('GL_EXT_draw_buffers2');
//  GLAD_GL_EXT_draw_instanced := hasExt('GL_EXT_draw_instanced');
//  GLAD_GL_EXT_draw_range_elements := hasExt('GL_EXT_draw_range_elements');
//  GLAD_GL_EXT_external_buffer := hasExt('GL_EXT_external_buffer');
//  GLAD_GL_EXT_fog_coord := hasExt('GL_EXT_fog_coord');
//  GLAD_GL_EXT_framebuffer_blit := hasExt('GL_EXT_framebuffer_blit');
//  GLAD_GL_EXT_framebuffer_blit_layers := hasExt('GL_EXT_framebuffer_blit_layers');
//  GLAD_GL_EXT_framebuffer_multisample := hasExt('GL_EXT_framebuffer_multisample');
//  GLAD_GL_EXT_framebuffer_multisample_blit_scaled := hasExt('GL_EXT_framebuffer_multisample_blit_scaled');
//  GLAD_GL_EXT_framebuffer_object := hasExt('GL_EXT_framebuffer_object');
//  GLAD_GL_EXT_framebuffer_sRGB := hasExt('GL_EXT_framebuffer_sRGB');
//  GLAD_GL_EXT_geometry_shader4 := hasExt('GL_EXT_geometry_shader4');
//  GLAD_GL_EXT_gpu_program_parameters := hasExt('GL_EXT_gpu_program_parameters');
//  GLAD_GL_EXT_gpu_shader4 := hasExt('GL_EXT_gpu_shader4');
//  GLAD_GL_EXT_histogram := hasExt('GL_EXT_histogram');
//  GLAD_GL_EXT_index_array_formats := hasExt('GL_EXT_index_array_formats');
//  GLAD_GL_EXT_index_func := hasExt('GL_EXT_index_func');
//  GLAD_GL_EXT_index_material := hasExt('GL_EXT_index_material');
//  GLAD_GL_EXT_index_texture := hasExt('GL_EXT_index_texture');
//  GLAD_GL_EXT_light_texture := hasExt('GL_EXT_light_texture');
//  GLAD_GL_EXT_memory_object := hasExt('GL_EXT_memory_object');
//  GLAD_GL_EXT_memory_object_fd := hasExt('GL_EXT_memory_object_fd');
//  GLAD_GL_EXT_memory_object_win32 := hasExt('GL_EXT_memory_object_win32');
//  GLAD_GL_EXT_misc_attribute := hasExt('GL_EXT_misc_attribute');
//  GLAD_GL_EXT_multi_draw_arrays := hasExt('GL_EXT_multi_draw_arrays');
//  GLAD_GL_EXT_multisample := hasExt('GL_EXT_multisample');
//  GLAD_GL_EXT_multiview_tessellation_geometry_shader := hasExt('GL_EXT_multiview_tessellation_geometry_shader');
//  GLAD_GL_EXT_multiview_texture_multisample := hasExt('GL_EXT_multiview_texture_multisample');
//  GLAD_GL_EXT_multiview_timer_query := hasExt('GL_EXT_multiview_timer_query');
//  GLAD_GL_EXT_packed_depth_stencil := hasExt('GL_EXT_packed_depth_stencil');
//  GLAD_GL_EXT_packed_float := hasExt('GL_EXT_packed_float');
//  GLAD_GL_EXT_packed_pixels := hasExt('GL_EXT_packed_pixels');
//  GLAD_GL_EXT_paletted_texture := hasExt('GL_EXT_paletted_texture');
//  GLAD_GL_EXT_pixel_buffer_object := hasExt('GL_EXT_pixel_buffer_object');
//  GLAD_GL_EXT_pixel_transform := hasExt('GL_EXT_pixel_transform');
//  GLAD_GL_EXT_pixel_transform_color_table := hasExt('GL_EXT_pixel_transform_color_table');
//  GLAD_GL_EXT_point_parameters := hasExt('GL_EXT_point_parameters');
//  GLAD_GL_EXT_polygon_offset := hasExt('GL_EXT_polygon_offset');
//  GLAD_GL_EXT_polygon_offset_clamp := hasExt('GL_EXT_polygon_offset_clamp');
//  GLAD_GL_EXT_post_depth_coverage := hasExt('GL_EXT_post_depth_coverage');
//  GLAD_GL_EXT_provoking_vertex := hasExt('GL_EXT_provoking_vertex');
//  GLAD_GL_EXT_raster_multisample := hasExt('GL_EXT_raster_multisample');
//  GLAD_GL_EXT_rescale_normal := hasExt('GL_EXT_rescale_normal');
//  GLAD_GL_EXT_secondary_color := hasExt('GL_EXT_secondary_color');
//  GLAD_GL_EXT_semaphore := hasExt('GL_EXT_semaphore');
//  GLAD_GL_EXT_semaphore_fd := hasExt('GL_EXT_semaphore_fd');
//  GLAD_GL_EXT_semaphore_win32 := hasExt('GL_EXT_semaphore_win32');
//  GLAD_GL_EXT_separate_shader_objects := hasExt('GL_EXT_separate_shader_objects');
//  GLAD_GL_EXT_separate_specular_color := hasExt('GL_EXT_separate_specular_color');
//  GLAD_GL_EXT_shader_framebuffer_fetch := hasExt('GL_EXT_shader_framebuffer_fetch');
//  GLAD_GL_EXT_shader_framebuffer_fetch_non_coherent := hasExt('GL_EXT_shader_framebuffer_fetch_non_coherent');
//  GLAD_GL_EXT_shader_image_load_formatted := hasExt('GL_EXT_shader_image_load_formatted');
//  GLAD_GL_EXT_shader_image_load_store := hasExt('GL_EXT_shader_image_load_store');
//  GLAD_GL_EXT_shader_integer_mix := hasExt('GL_EXT_shader_integer_mix');
//  GLAD_GL_EXT_shader_samples_identical := hasExt('GL_EXT_shader_samples_identical');
//  GLAD_GL_EXT_shadow_funcs := hasExt('GL_EXT_shadow_funcs');
//  GLAD_GL_EXT_shared_texture_palette := hasExt('GL_EXT_shared_texture_palette');
//  GLAD_GL_EXT_sparse_texture2 := hasExt('GL_EXT_sparse_texture2');
//  GLAD_GL_EXT_stencil_clear_tag := hasExt('GL_EXT_stencil_clear_tag');
//  GLAD_GL_EXT_stencil_two_side := hasExt('GL_EXT_stencil_two_side');
//  GLAD_GL_EXT_stencil_wrap := hasExt('GL_EXT_stencil_wrap');
//  GLAD_GL_EXT_subtexture := hasExt('GL_EXT_subtexture');
//  GLAD_GL_EXT_texture := hasExt('GL_EXT_texture');
//  GLAD_GL_EXT_texture3D := hasExt('GL_EXT_texture3D');
//  GLAD_GL_EXT_texture_array := hasExt('GL_EXT_texture_array');
//  GLAD_GL_EXT_texture_buffer_object := hasExt('GL_EXT_texture_buffer_object');
//  GLAD_GL_EXT_texture_compression_latc := hasExt('GL_EXT_texture_compression_latc');
//  GLAD_GL_EXT_texture_compression_rgtc := hasExt('GL_EXT_texture_compression_rgtc');
//  GLAD_GL_EXT_texture_compression_s3tc := hasExt('GL_EXT_texture_compression_s3tc');
//  GLAD_GL_EXT_texture_cube_map := hasExt('GL_EXT_texture_cube_map');
//  GLAD_GL_EXT_texture_env_add := hasExt('GL_EXT_texture_env_add');
//  GLAD_GL_EXT_texture_env_combine := hasExt('GL_EXT_texture_env_combine');
//  GLAD_GL_EXT_texture_env_dot3 := hasExt('GL_EXT_texture_env_dot3');
//  GLAD_GL_EXT_texture_filter_anisotropic := hasExt('GL_EXT_texture_filter_anisotropic');
//  GLAD_GL_EXT_texture_filter_minmax := hasExt('GL_EXT_texture_filter_minmax');
//  GLAD_GL_EXT_texture_integer := hasExt('GL_EXT_texture_integer');
//  GLAD_GL_EXT_texture_lod_bias := hasExt('GL_EXT_texture_lod_bias');
//  GLAD_GL_EXT_texture_mirror_clamp := hasExt('GL_EXT_texture_mirror_clamp');
//  GLAD_GL_EXT_texture_object := hasExt('GL_EXT_texture_object');
//  GLAD_GL_EXT_texture_perturb_normal := hasExt('GL_EXT_texture_perturb_normal');
//  GLAD_GL_EXT_texture_sRGB := hasExt('GL_EXT_texture_sRGB');
//  GLAD_GL_EXT_texture_sRGB_R8 := hasExt('GL_EXT_texture_sRGB_R8');
//  GLAD_GL_EXT_texture_sRGB_RG8 := hasExt('GL_EXT_texture_sRGB_RG8');
//  GLAD_GL_EXT_texture_sRGB_decode := hasExt('GL_EXT_texture_sRGB_decode');
//  GLAD_GL_EXT_texture_shadow_lod := hasExt('GL_EXT_texture_shadow_lod');
//  GLAD_GL_EXT_texture_shared_exponent := hasExt('GL_EXT_texture_shared_exponent');
//  GLAD_GL_EXT_texture_snorm := hasExt('GL_EXT_texture_snorm');
//  GLAD_GL_EXT_texture_storage := hasExt('GL_EXT_texture_storage');
//  GLAD_GL_EXT_texture_swizzle := hasExt('GL_EXT_texture_swizzle');
//  GLAD_GL_EXT_timer_query := hasExt('GL_EXT_timer_query');
//  GLAD_GL_EXT_transform_feedback := hasExt('GL_EXT_transform_feedback');
//  GLAD_GL_EXT_vertex_array := hasExt('GL_EXT_vertex_array');
//  GLAD_GL_EXT_vertex_array_bgra := hasExt('GL_EXT_vertex_array_bgra');
//  GLAD_GL_EXT_vertex_attrib_64bit := hasExt('GL_EXT_vertex_attrib_64bit');
//  GLAD_GL_EXT_vertex_shader := hasExt('GL_EXT_vertex_shader');
//  GLAD_GL_EXT_vertex_weighting := hasExt('GL_EXT_vertex_weighting');
//  GLAD_GL_EXT_win32_keyed_mutex := hasExt('GL_EXT_win32_keyed_mutex');
//  GLAD_GL_EXT_window_rectangles := hasExt('GL_EXT_window_rectangles');
//  GLAD_GL_EXT_x11_sync_object := hasExt('GL_EXT_x11_sync_object');
//  GLAD_GL_GREMEDY_frame_terminator := hasExt('GL_GREMEDY_frame_terminator');
//  GLAD_GL_GREMEDY_string_marker := hasExt('GL_GREMEDY_string_marker');
//  GLAD_GL_HP_convolution_border_modes := hasExt('GL_HP_convolution_border_modes');
//  GLAD_GL_HP_image_transform := hasExt('GL_HP_image_transform');
//  GLAD_GL_HP_occlusion_test := hasExt('GL_HP_occlusion_test');
//  GLAD_GL_HP_texture_lighting := hasExt('GL_HP_texture_lighting');
//  GLAD_GL_IBM_cull_vertex := hasExt('GL_IBM_cull_vertex');
//  GLAD_GL_IBM_multimode_draw_arrays := hasExt('GL_IBM_multimode_draw_arrays');
//  GLAD_GL_IBM_rasterpos_clip := hasExt('GL_IBM_rasterpos_clip');
//  GLAD_GL_IBM_static_data := hasExt('GL_IBM_static_data');
//  GLAD_GL_IBM_texture_mirrored_repeat := hasExt('GL_IBM_texture_mirrored_repeat');
//  GLAD_GL_IBM_vertex_array_lists := hasExt('GL_IBM_vertex_array_lists');
//  GLAD_GL_INGR_blend_func_separate := hasExt('GL_INGR_blend_func_separate');
//  GLAD_GL_INGR_color_clamp := hasExt('GL_INGR_color_clamp');
//  GLAD_GL_INGR_interlace_read := hasExt('GL_INGR_interlace_read');
//  GLAD_GL_INTEL_blackhole_render := hasExt('GL_INTEL_blackhole_render');
//  GLAD_GL_INTEL_conservative_rasterization := hasExt('GL_INTEL_conservative_rasterization');
//  GLAD_GL_INTEL_fragment_shader_ordering := hasExt('GL_INTEL_fragment_shader_ordering');
//  GLAD_GL_INTEL_framebuffer_CMAA := hasExt('GL_INTEL_framebuffer_CMAA');
//  GLAD_GL_INTEL_map_texture := hasExt('GL_INTEL_map_texture');
//  GLAD_GL_INTEL_parallel_arrays := hasExt('GL_INTEL_parallel_arrays');
//  GLAD_GL_INTEL_performance_query := hasExt('GL_INTEL_performance_query');
//  GLAD_GL_KHR_blend_equation_advanced := hasExt('GL_KHR_blend_equation_advanced');
//  GLAD_GL_KHR_blend_equation_advanced_coherent := hasExt('GL_KHR_blend_equation_advanced_coherent');
//  GLAD_GL_KHR_context_flush_control := hasExt('GL_KHR_context_flush_control');
//  GLAD_GL_KHR_debug := hasExt('GL_KHR_debug');
//  GLAD_GL_KHR_no_error := hasExt('GL_KHR_no_error');
//  GLAD_GL_KHR_parallel_shader_compile := hasExt('GL_KHR_parallel_shader_compile');
//  GLAD_GL_KHR_robust_buffer_access_behavior := hasExt('GL_KHR_robust_buffer_access_behavior');
//  GLAD_GL_KHR_robustness := hasExt('GL_KHR_robustness');
//  GLAD_GL_KHR_shader_subgroup := hasExt('GL_KHR_shader_subgroup');
//  GLAD_GL_KHR_texture_compression_astc_hdr := hasExt('GL_KHR_texture_compression_astc_hdr');
//  GLAD_GL_KHR_texture_compression_astc_ldr := hasExt('GL_KHR_texture_compression_astc_ldr');
//  GLAD_GL_KHR_texture_compression_astc_sliced_3d := hasExt('GL_KHR_texture_compression_astc_sliced_3d');
//  GLAD_GL_MESAX_texture_stack := hasExt('GL_MESAX_texture_stack');
//  GLAD_GL_MESA_framebuffer_flip_x := hasExt('GL_MESA_framebuffer_flip_x');
//  GLAD_GL_MESA_framebuffer_flip_y := hasExt('GL_MESA_framebuffer_flip_y');
//  GLAD_GL_MESA_framebuffer_swap_xy := hasExt('GL_MESA_framebuffer_swap_xy');
//  GLAD_GL_MESA_pack_invert := hasExt('GL_MESA_pack_invert');
//  GLAD_GL_MESA_program_binary_formats := hasExt('GL_MESA_program_binary_formats');
//  GLAD_GL_MESA_resize_buffers := hasExt('GL_MESA_resize_buffers');
//  GLAD_GL_MESA_shader_integer_functions := hasExt('GL_MESA_shader_integer_functions');
//  GLAD_GL_MESA_tile_raster_order := hasExt('GL_MESA_tile_raster_order');
//  GLAD_GL_MESA_window_pos := hasExt('GL_MESA_window_pos');
//  GLAD_GL_MESA_ycbcr_texture := hasExt('GL_MESA_ycbcr_texture');
//  GLAD_GL_NVX_blend_equation_advanced_multi_draw_buffers := hasExt('GL_NVX_blend_equation_advanced_multi_draw_buffers');
//  GLAD_GL_NVX_conditional_render := hasExt('GL_NVX_conditional_render');
//  GLAD_GL_NVX_gpu_memory_info := hasExt('GL_NVX_gpu_memory_info');
//  GLAD_GL_NVX_gpu_multicast2 := hasExt('GL_NVX_gpu_multicast2');
//  GLAD_GL_NVX_linked_gpu_multicast := hasExt('GL_NVX_linked_gpu_multicast');
//  GLAD_GL_NVX_progress_fence := hasExt('GL_NVX_progress_fence');
//  GLAD_GL_NV_alpha_to_coverage_dither_control := hasExt('GL_NV_alpha_to_coverage_dither_control');
//  GLAD_GL_NV_bindless_multi_draw_indirect := hasExt('GL_NV_bindless_multi_draw_indirect');
//  GLAD_GL_NV_bindless_multi_draw_indirect_count := hasExt('GL_NV_bindless_multi_draw_indirect_count');
//  GLAD_GL_NV_bindless_texture := hasExt('GL_NV_bindless_texture');
//  GLAD_GL_NV_blend_equation_advanced := hasExt('GL_NV_blend_equation_advanced');
//  GLAD_GL_NV_blend_equation_advanced_coherent := hasExt('GL_NV_blend_equation_advanced_coherent');
//  GLAD_GL_NV_blend_minmax_factor := hasExt('GL_NV_blend_minmax_factor');
//  GLAD_GL_NV_blend_square := hasExt('GL_NV_blend_square');
//  GLAD_GL_NV_clip_space_w_scaling := hasExt('GL_NV_clip_space_w_scaling');
//  GLAD_GL_NV_command_list := hasExt('GL_NV_command_list');
//  GLAD_GL_NV_compute_program5 := hasExt('GL_NV_compute_program5');
//  GLAD_GL_NV_compute_shader_derivatives := hasExt('GL_NV_compute_shader_derivatives');
//  GLAD_GL_NV_conditional_render := hasExt('GL_NV_conditional_render');
//  GLAD_GL_NV_conservative_raster := hasExt('GL_NV_conservative_raster');
//  GLAD_GL_NV_conservative_raster_dilate := hasExt('GL_NV_conservative_raster_dilate');
//  GLAD_GL_NV_conservative_raster_pre_snap := hasExt('GL_NV_conservative_raster_pre_snap');
//  GLAD_GL_NV_conservative_raster_pre_snap_triangles := hasExt('GL_NV_conservative_raster_pre_snap_triangles');
//  GLAD_GL_NV_conservative_raster_underestimation := hasExt('GL_NV_conservative_raster_underestimation');
//  GLAD_GL_NV_copy_depth_to_color := hasExt('GL_NV_copy_depth_to_color');
//  GLAD_GL_NV_copy_image := hasExt('GL_NV_copy_image');
//  GLAD_GL_NV_deep_texture3D := hasExt('GL_NV_deep_texture3D');
//  GLAD_GL_NV_depth_buffer_float := hasExt('GL_NV_depth_buffer_float');
//  GLAD_GL_NV_depth_clamp := hasExt('GL_NV_depth_clamp');
//  GLAD_GL_NV_draw_texture := hasExt('GL_NV_draw_texture');
//  GLAD_GL_NV_draw_vulkan_image := hasExt('GL_NV_draw_vulkan_image');
//  GLAD_GL_NV_evaluators := hasExt('GL_NV_evaluators');
//  GLAD_GL_NV_explicit_multisample := hasExt('GL_NV_explicit_multisample');
//  GLAD_GL_NV_fence := hasExt('GL_NV_fence');
//  GLAD_GL_NV_fill_rectangle := hasExt('GL_NV_fill_rectangle');
//  GLAD_GL_NV_float_buffer := hasExt('GL_NV_float_buffer');
//  GLAD_GL_NV_fog_distance := hasExt('GL_NV_fog_distance');
//  GLAD_GL_NV_fragment_coverage_to_color := hasExt('GL_NV_fragment_coverage_to_color');
//  GLAD_GL_NV_fragment_program := hasExt('GL_NV_fragment_program');
//  GLAD_GL_NV_fragment_program2 := hasExt('GL_NV_fragment_program2');
//  GLAD_GL_NV_fragment_program4 := hasExt('GL_NV_fragment_program4');
//  GLAD_GL_NV_fragment_program_option := hasExt('GL_NV_fragment_program_option');
//  GLAD_GL_NV_fragment_shader_barycentric := hasExt('GL_NV_fragment_shader_barycentric');
//  GLAD_GL_NV_fragment_shader_interlock := hasExt('GL_NV_fragment_shader_interlock');
//  GLAD_GL_NV_framebuffer_mixed_samples := hasExt('GL_NV_framebuffer_mixed_samples');
//  GLAD_GL_NV_framebuffer_multisample_coverage := hasExt('GL_NV_framebuffer_multisample_coverage');
//  GLAD_GL_NV_geometry_program4 := hasExt('GL_NV_geometry_program4');
//  GLAD_GL_NV_geometry_shader4 := hasExt('GL_NV_geometry_shader4');
//  GLAD_GL_NV_geometry_shader_passthrough := hasExt('GL_NV_geometry_shader_passthrough');
//  GLAD_GL_NV_gpu_multicast := hasExt('GL_NV_gpu_multicast');
//  GLAD_GL_NV_gpu_program4 := hasExt('GL_NV_gpu_program4');
//  GLAD_GL_NV_gpu_program5 := hasExt('GL_NV_gpu_program5');
//  GLAD_GL_NV_gpu_program5_mem_extended := hasExt('GL_NV_gpu_program5_mem_extended');
//  GLAD_GL_NV_gpu_shader5 := hasExt('GL_NV_gpu_shader5');
//  GLAD_GL_NV_half_float := hasExt('GL_NV_half_float');
//  GLAD_GL_NV_internalformat_sample_query := hasExt('GL_NV_internalformat_sample_query');
//  GLAD_GL_NV_light_max_exponent := hasExt('GL_NV_light_max_exponent');
//  GLAD_GL_NV_memory_attachment := hasExt('GL_NV_memory_attachment');
//  GLAD_GL_NV_memory_object_sparse := hasExt('GL_NV_memory_object_sparse');
//  GLAD_GL_NV_mesh_shader := hasExt('GL_NV_mesh_shader');
//  GLAD_GL_NV_multisample_coverage := hasExt('GL_NV_multisample_coverage');
//  GLAD_GL_NV_multisample_filter_hint := hasExt('GL_NV_multisample_filter_hint');
//  GLAD_GL_NV_occlusion_query := hasExt('GL_NV_occlusion_query');
//  GLAD_GL_NV_packed_depth_stencil := hasExt('GL_NV_packed_depth_stencil');
//  GLAD_GL_NV_parameter_buffer_object := hasExt('GL_NV_parameter_buffer_object');
//  GLAD_GL_NV_parameter_buffer_object2 := hasExt('GL_NV_parameter_buffer_object2');
//  GLAD_GL_NV_path_rendering := hasExt('GL_NV_path_rendering');
//  GLAD_GL_NV_path_rendering_shared_edge := hasExt('GL_NV_path_rendering_shared_edge');
//  GLAD_GL_NV_pixel_data_range := hasExt('GL_NV_pixel_data_range');
//  GLAD_GL_NV_point_sprite := hasExt('GL_NV_point_sprite');
//  GLAD_GL_NV_present_video := hasExt('GL_NV_present_video');
//  GLAD_GL_NV_primitive_restart := hasExt('GL_NV_primitive_restart');
//  GLAD_GL_NV_primitive_shading_rate := hasExt('GL_NV_primitive_shading_rate');
//  GLAD_GL_NV_query_resource := hasExt('GL_NV_query_resource');
//  GLAD_GL_NV_query_resource_tag := hasExt('GL_NV_query_resource_tag');
//  GLAD_GL_NV_register_combiners := hasExt('GL_NV_register_combiners');
//  GLAD_GL_NV_register_combiners2 := hasExt('GL_NV_register_combiners2');
//  GLAD_GL_NV_representative_fragment_test := hasExt('GL_NV_representative_fragment_test');
//  GLAD_GL_NV_robustness_video_memory_purge := hasExt('GL_NV_robustness_video_memory_purge');
//  GLAD_GL_NV_sample_locations := hasExt('GL_NV_sample_locations');
//  GLAD_GL_NV_sample_mask_override_coverage := hasExt('GL_NV_sample_mask_override_coverage');
//  GLAD_GL_NV_scissor_exclusive := hasExt('GL_NV_scissor_exclusive');
//  GLAD_GL_NV_shader_atomic_counters := hasExt('GL_NV_shader_atomic_counters');
//  GLAD_GL_NV_shader_atomic_float := hasExt('GL_NV_shader_atomic_float');
//  GLAD_GL_NV_shader_atomic_float64 := hasExt('GL_NV_shader_atomic_float64');
//  GLAD_GL_NV_shader_atomic_fp16_vector := hasExt('GL_NV_shader_atomic_fp16_vector');
//  GLAD_GL_NV_shader_atomic_int64 := hasExt('GL_NV_shader_atomic_int64');
//  GLAD_GL_NV_shader_buffer_load := hasExt('GL_NV_shader_buffer_load');
//  GLAD_GL_NV_shader_buffer_store := hasExt('GL_NV_shader_buffer_store');
//  GLAD_GL_NV_shader_storage_buffer_object := hasExt('GL_NV_shader_storage_buffer_object');
//  GLAD_GL_NV_shader_subgroup_partitioned := hasExt('GL_NV_shader_subgroup_partitioned');
//  GLAD_GL_NV_shader_texture_footprint := hasExt('GL_NV_shader_texture_footprint');
//  GLAD_GL_NV_shader_thread_group := hasExt('GL_NV_shader_thread_group');
//  GLAD_GL_NV_shader_thread_shuffle := hasExt('GL_NV_shader_thread_shuffle');
//  GLAD_GL_NV_shading_rate_image := hasExt('GL_NV_shading_rate_image');
//  GLAD_GL_NV_stereo_view_rendering := hasExt('GL_NV_stereo_view_rendering');
//  GLAD_GL_NV_tessellation_program5 := hasExt('GL_NV_tessellation_program5');
//  GLAD_GL_NV_texgen_emboss := hasExt('GL_NV_texgen_emboss');
//  GLAD_GL_NV_texgen_reflection := hasExt('GL_NV_texgen_reflection');
//  GLAD_GL_NV_texture_barrier := hasExt('GL_NV_texture_barrier');
//  GLAD_GL_NV_texture_compression_vtc := hasExt('GL_NV_texture_compression_vtc');
//  GLAD_GL_NV_texture_env_combine4 := hasExt('GL_NV_texture_env_combine4');
//  GLAD_GL_NV_texture_expand_normal := hasExt('GL_NV_texture_expand_normal');
//  GLAD_GL_NV_texture_multisample := hasExt('GL_NV_texture_multisample');
//  GLAD_GL_NV_texture_rectangle := hasExt('GL_NV_texture_rectangle');
//  GLAD_GL_NV_texture_rectangle_compressed := hasExt('GL_NV_texture_rectangle_compressed');
//  GLAD_GL_NV_texture_shader := hasExt('GL_NV_texture_shader');
//  GLAD_GL_NV_texture_shader2 := hasExt('GL_NV_texture_shader2');
//  GLAD_GL_NV_texture_shader3 := hasExt('GL_NV_texture_shader3');
//  GLAD_GL_NV_timeline_semaphore := hasExt('GL_NV_timeline_semaphore');
//  GLAD_GL_NV_transform_feedback := hasExt('GL_NV_transform_feedback');
//  GLAD_GL_NV_transform_feedback2 := hasExt('GL_NV_transform_feedback2');
//  GLAD_GL_NV_uniform_buffer_std430_layout := hasExt('GL_NV_uniform_buffer_std430_layout');
//  GLAD_GL_NV_uniform_buffer_unified_memory := hasExt('GL_NV_uniform_buffer_unified_memory');
//  GLAD_GL_NV_vdpau_interop := hasExt('GL_NV_vdpau_interop');
//  GLAD_GL_NV_vdpau_interop2 := hasExt('GL_NV_vdpau_interop2');
//  GLAD_GL_NV_vertex_array_range := hasExt('GL_NV_vertex_array_range');
//  GLAD_GL_NV_vertex_array_range2 := hasExt('GL_NV_vertex_array_range2');
//  GLAD_GL_NV_vertex_attrib_integer_64bit := hasExt('GL_NV_vertex_attrib_integer_64bit');
//  GLAD_GL_NV_vertex_buffer_unified_memory := hasExt('GL_NV_vertex_buffer_unified_memory');
//  GLAD_GL_NV_vertex_program := hasExt('GL_NV_vertex_program');
//  GLAD_GL_NV_vertex_program1_1 := hasExt('GL_NV_vertex_program1_1');
//  GLAD_GL_NV_vertex_program2 := hasExt('GL_NV_vertex_program2');
//  GLAD_GL_NV_vertex_program2_option := hasExt('GL_NV_vertex_program2_option');
//  GLAD_GL_NV_vertex_program3 := hasExt('GL_NV_vertex_program3');
//  GLAD_GL_NV_vertex_program4 := hasExt('GL_NV_vertex_program4');
//  GLAD_GL_NV_video_capture := hasExt('GL_NV_video_capture');
//  GLAD_GL_NV_viewport_array2 := hasExt('GL_NV_viewport_array2');
//  GLAD_GL_NV_viewport_swizzle := hasExt('GL_NV_viewport_swizzle');
//  GLAD_GL_OES_byte_coordinates := hasExt('GL_OES_byte_coordinates');
//  GLAD_GL_OES_compressed_paletted_texture := hasExt('GL_OES_compressed_paletted_texture');
//  GLAD_GL_OES_fixed_point := hasExt('GL_OES_fixed_point');
//  GLAD_GL_OES_query_matrix := hasExt('GL_OES_query_matrix');
//  GLAD_GL_OES_read_format := hasExt('GL_OES_read_format');
//  GLAD_GL_OES_single_precision := hasExt('GL_OES_single_precision');
//  GLAD_GL_OML_interlace := hasExt('GL_OML_interlace');
//  GLAD_GL_OML_resample := hasExt('GL_OML_resample');
//  GLAD_GL_OML_subsample := hasExt('GL_OML_subsample');
//  GLAD_GL_OVR_multiview := hasExt('GL_OVR_multiview');
//  GLAD_GL_OVR_multiview2 := hasExt('GL_OVR_multiview2');
//  GLAD_GL_PGI_misc_hints := hasExt('GL_PGI_misc_hints');
//  GLAD_GL_PGI_vertex_hints := hasExt('GL_PGI_vertex_hints');
//  GLAD_GL_REND_screen_coordinates := hasExt('GL_REND_screen_coordinates');
//  GLAD_GL_S3_s3tc := hasExt('GL_S3_s3tc');
//  GLAD_GL_SGIS_detail_texture := hasExt('GL_SGIS_detail_texture');
//  GLAD_GL_SGIS_fog_function := hasExt('GL_SGIS_fog_function');
//  GLAD_GL_SGIS_generate_mipmap := hasExt('GL_SGIS_generate_mipmap');
//  GLAD_GL_SGIS_multisample := hasExt('GL_SGIS_multisample');
//  GLAD_GL_SGIS_pixel_texture := hasExt('GL_SGIS_pixel_texture');
//  GLAD_GL_SGIS_point_line_texgen := hasExt('GL_SGIS_point_line_texgen');
//  GLAD_GL_SGIS_point_parameters := hasExt('GL_SGIS_point_parameters');
//  GLAD_GL_SGIS_sharpen_texture := hasExt('GL_SGIS_sharpen_texture');
//  GLAD_GL_SGIS_texture4D := hasExt('GL_SGIS_texture4D');
//  GLAD_GL_SGIS_texture_border_clamp := hasExt('GL_SGIS_texture_border_clamp');
//  GLAD_GL_SGIS_texture_color_mask := hasExt('GL_SGIS_texture_color_mask');
//  GLAD_GL_SGIS_texture_edge_clamp := hasExt('GL_SGIS_texture_edge_clamp');
//  GLAD_GL_SGIS_texture_filter4 := hasExt('GL_SGIS_texture_filter4');
//  GLAD_GL_SGIS_texture_lod := hasExt('GL_SGIS_texture_lod');
//  GLAD_GL_SGIS_texture_select := hasExt('GL_SGIS_texture_select');
//  GLAD_GL_SGIX_async := hasExt('GL_SGIX_async');
//  GLAD_GL_SGIX_async_histogram := hasExt('GL_SGIX_async_histogram');
//  GLAD_GL_SGIX_async_pixel := hasExt('GL_SGIX_async_pixel');
//  GLAD_GL_SGIX_blend_alpha_minmax := hasExt('GL_SGIX_blend_alpha_minmax');
//  GLAD_GL_SGIX_calligraphic_fragment := hasExt('GL_SGIX_calligraphic_fragment');
//  GLAD_GL_SGIX_clipmap := hasExt('GL_SGIX_clipmap');
//  GLAD_GL_SGIX_convolution_accuracy := hasExt('GL_SGIX_convolution_accuracy');
//  GLAD_GL_SGIX_depth_pass_instrument := hasExt('GL_SGIX_depth_pass_instrument');
//  GLAD_GL_SGIX_depth_texture := hasExt('GL_SGIX_depth_texture');
//  GLAD_GL_SGIX_flush_raster := hasExt('GL_SGIX_flush_raster');
//  GLAD_GL_SGIX_fog_offset := hasExt('GL_SGIX_fog_offset');
//  GLAD_GL_SGIX_fragment_lighting := hasExt('GL_SGIX_fragment_lighting');
//  GLAD_GL_SGIX_framezoom := hasExt('GL_SGIX_framezoom');
//  GLAD_GL_SGIX_igloo_interface := hasExt('GL_SGIX_igloo_interface');
//  GLAD_GL_SGIX_instruments := hasExt('GL_SGIX_instruments');
//  GLAD_GL_SGIX_interlace := hasExt('GL_SGIX_interlace');
//  GLAD_GL_SGIX_ir_instrument1 := hasExt('GL_SGIX_ir_instrument1');
//  GLAD_GL_SGIX_list_priority := hasExt('GL_SGIX_list_priority');
//  GLAD_GL_SGIX_pixel_texture := hasExt('GL_SGIX_pixel_texture');
//  GLAD_GL_SGIX_pixel_tiles := hasExt('GL_SGIX_pixel_tiles');
//  GLAD_GL_SGIX_polynomial_ffd := hasExt('GL_SGIX_polynomial_ffd');
//  GLAD_GL_SGIX_reference_plane := hasExt('GL_SGIX_reference_plane');
//  GLAD_GL_SGIX_resample := hasExt('GL_SGIX_resample');
//  GLAD_GL_SGIX_scalebias_hint := hasExt('GL_SGIX_scalebias_hint');
//  GLAD_GL_SGIX_shadow := hasExt('GL_SGIX_shadow');
//  GLAD_GL_SGIX_shadow_ambient := hasExt('GL_SGIX_shadow_ambient');
//  GLAD_GL_SGIX_sprite := hasExt('GL_SGIX_sprite');
//  GLAD_GL_SGIX_subsample := hasExt('GL_SGIX_subsample');
//  GLAD_GL_SGIX_tag_sample_buffer := hasExt('GL_SGIX_tag_sample_buffer');
//  GLAD_GL_SGIX_texture_add_env := hasExt('GL_SGIX_texture_add_env');
//  GLAD_GL_SGIX_texture_coordinate_clamp := hasExt('GL_SGIX_texture_coordinate_clamp');
//  GLAD_GL_SGIX_texture_lod_bias := hasExt('GL_SGIX_texture_lod_bias');
//  GLAD_GL_SGIX_texture_multi_buffer := hasExt('GL_SGIX_texture_multi_buffer');
//  GLAD_GL_SGIX_texture_scale_bias := hasExt('GL_SGIX_texture_scale_bias');
//  GLAD_GL_SGIX_vertex_preclip := hasExt('GL_SGIX_vertex_preclip');
//  GLAD_GL_SGIX_ycrcb := hasExt('GL_SGIX_ycrcb');
//  GLAD_GL_SGIX_ycrcb_subsample := hasExt('GL_SGIX_ycrcb_subsample');
//  GLAD_GL_SGIX_ycrcba := hasExt('GL_SGIX_ycrcba');
//  GLAD_GL_SGI_color_matrix := hasExt('GL_SGI_color_matrix');
//  GLAD_GL_SGI_color_table := hasExt('GL_SGI_color_table');
//  GLAD_GL_SGI_texture_color_table := hasExt('GL_SGI_texture_color_table');
//  GLAD_GL_SUNX_constant_data := hasExt('GL_SUNX_constant_data');
//  GLAD_GL_SUN_convolution_border_modes := hasExt('GL_SUN_convolution_border_modes');
//  GLAD_GL_SUN_global_alpha := hasExt('GL_SUN_global_alpha');
//  GLAD_GL_SUN_mesh_array := hasExt('GL_SUN_mesh_array');
//  GLAD_GL_SUN_slice_accum := hasExt('GL_SUN_slice_accum');
//  GLAD_GL_SUN_triangle_list := hasExt('GL_SUN_triangle_list');
//  GLAD_GL_SUN_vertex := hasExt('GL_SUN_vertex');
//  GLAD_GL_WIN_phong_shading := hasExt('GL_WIN_phong_shading');
//  GLAD_GL_WIN_specular_fog := hasExt('GL_WIN_specular_fog');
//end;

function gladLoadGLExt(load: TLoadProc): boolean;
//var
//  glVersion: PAnsiChar;
begin
  //glGetString := load('glGetString');  
  //if not Assigned(glGetString) then exit(false);
  //glVersion := PAnsiChar( glGetString(GL_VERSION) );
  //if glVersion = nil then exit(false);
  //
  //findCoreGL(glVersion);
//  load_GL_VERSION_1_0(load);

//  findExtensionsGL();
  load_GL_3DFX_tbuffer(load);
  load_GL_AMD_debug_output(load);
  load_GL_AMD_draw_buffers_blend(load);
  load_GL_AMD_framebuffer_multisample_advanced(load);
  load_GL_AMD_framebuffer_sample_positions(load);
  load_GL_AMD_gpu_shader_int64(load);
  load_GL_AMD_interleaved_elements(load);
  load_GL_AMD_multi_draw_indirect(load);
  load_GL_AMD_name_gen_delete(load);
  load_GL_AMD_occlusion_query_event(load);
  load_GL_AMD_performance_monitor(load);
  load_GL_AMD_sample_positions(load);
  load_GL_AMD_sparse_texture(load);
  load_GL_AMD_stencil_operation_extended(load);
  load_GL_AMD_vertex_shader_tessellator(load);
  load_GL_APPLE_element_array(load);
  load_GL_APPLE_fence(load);
  load_GL_APPLE_flush_buffer_range(load);
  load_GL_APPLE_object_purgeable(load);
  load_GL_APPLE_texture_range(load);
  load_GL_APPLE_vertex_array_object(load);
  load_GL_APPLE_vertex_array_range(load);
  load_GL_APPLE_vertex_program_evaluators(load);
  load_GL_ARB_ES2_compatibility(load);
  load_GL_ARB_ES3_1_compatibility(load);
  load_GL_ARB_ES3_2_compatibility(load);
  load_GL_ARB_base_instance(load);
  load_GL_ARB_bindless_texture(load);
  load_GL_ARB_blend_func_extended(load);
  load_GL_ARB_buffer_storage(load);
  load_GL_ARB_cl_event(load);
  load_GL_ARB_clear_buffer_object(load);
  load_GL_ARB_clear_texture(load);
  load_GL_ARB_clip_control(load);
  load_GL_ARB_color_buffer_float(load);
  load_GL_ARB_compute_shader(load);
  load_GL_ARB_compute_variable_group_size(load);
  load_GL_ARB_copy_buffer(load);
  load_GL_ARB_copy_image(load);
  load_GL_ARB_debug_output(load);
  load_GL_ARB_direct_state_access(load);
  load_GL_ARB_draw_buffers(load);
  load_GL_ARB_draw_buffers_blend(load);
  load_GL_ARB_draw_elements_base_vertex(load);
  load_GL_ARB_draw_indirect(load);
  load_GL_ARB_draw_instanced(load);
  load_GL_ARB_fragment_program(load);
  load_GL_ARB_framebuffer_no_attachments(load);
  load_GL_ARB_framebuffer_object(load);
  load_GL_ARB_geometry_shader4(load);
  load_GL_ARB_get_program_binary(load);
  load_GL_ARB_get_texture_sub_image(load);
  load_GL_ARB_gl_spirv(load);
  load_GL_ARB_gpu_shader_fp64(load);
  load_GL_ARB_gpu_shader_int64(load);
  load_GL_ARB_imaging(load);
  load_GL_ARB_indirect_parameters(load);
  load_GL_ARB_instanced_arrays(load);
  load_GL_ARB_internalformat_query(load);
  load_GL_ARB_internalformat_query2(load);
  load_GL_ARB_invalidate_subdata(load);
  load_GL_ARB_map_buffer_range(load);
  load_GL_ARB_matrix_palette(load);
  load_GL_ARB_multi_bind(load);
  load_GL_ARB_multi_draw_indirect(load);
  load_GL_ARB_multisample(load);
  load_GL_ARB_multitexture(load);
  load_GL_ARB_occlusion_query(load);
  load_GL_ARB_parallel_shader_compile(load);
  load_GL_ARB_point_parameters(load);
  load_GL_ARB_polygon_offset_clamp(load);
  load_GL_ARB_program_interface_query(load);
  load_GL_ARB_provoking_vertex(load);
  load_GL_ARB_robustness(load);
  load_GL_ARB_sample_locations(load);
  load_GL_ARB_sample_shading(load);
  load_GL_ARB_sampler_objects(load);
  load_GL_ARB_separate_shader_objects(load);
  load_GL_ARB_shader_atomic_counters(load);
  load_GL_ARB_shader_image_load_store(load);
  load_GL_ARB_shader_objects(load);
  load_GL_ARB_shader_storage_buffer_object(load);
  load_GL_ARB_shader_subroutine(load);
  load_GL_ARB_shading_language_include(load);
  load_GL_ARB_sparse_buffer(load);
  load_GL_ARB_sparse_texture(load);
  load_GL_ARB_sync(load);
  load_GL_ARB_tessellation_shader(load);
  load_GL_ARB_texture_barrier(load);
  load_GL_ARB_texture_buffer_object(load);
  load_GL_ARB_texture_buffer_range(load);
  load_GL_ARB_texture_compression(load);
  load_GL_ARB_texture_multisample(load);
  load_GL_ARB_texture_storage(load);
  load_GL_ARB_texture_storage_multisample(load);
  load_GL_ARB_texture_view(load);
  load_GL_ARB_timer_query(load);
  load_GL_ARB_transform_feedback2(load);
  load_GL_ARB_transform_feedback3(load);
  load_GL_ARB_transform_feedback_instanced(load);
  load_GL_ARB_transpose_matrix(load);
  load_GL_ARB_uniform_buffer_object(load);
  load_GL_ARB_vertex_array_object(load);
  load_GL_ARB_vertex_attrib_64bit(load);
  load_GL_ARB_vertex_attrib_binding(load);
  load_GL_ARB_vertex_blend(load);
  load_GL_ARB_vertex_buffer_object(load);
  load_GL_ARB_vertex_program(load);
  load_GL_ARB_vertex_shader(load);
  load_GL_ARB_vertex_type_2_10_10_10_rev(load);
  load_GL_ARB_viewport_array(load);
  load_GL_ARB_window_pos(load);
  load_GL_ATI_draw_buffers(load);
  load_GL_ATI_element_array(load);
  load_GL_ATI_envmap_bumpmap(load);
  load_GL_ATI_fragment_shader(load);
  load_GL_ATI_map_object_buffer(load);
  load_GL_ATI_pn_triangles(load);
  load_GL_ATI_separate_stencil(load);
  load_GL_ATI_vertex_array_object(load);
  load_GL_ATI_vertex_attrib_array_object(load);
  load_GL_ATI_vertex_streams(load);
  load_GL_EXT_EGL_image_storage(load);
  load_GL_EXT_bindable_uniform(load);
  load_GL_EXT_blend_color(load);
  load_GL_EXT_blend_equation_separate(load);
  load_GL_EXT_blend_func_separate(load);
  load_GL_EXT_blend_minmax(load);
  load_GL_EXT_color_subtable(load);
  load_GL_EXT_compiled_vertex_array(load);
  load_GL_EXT_convolution(load);
  load_GL_EXT_coordinate_frame(load);
  load_GL_EXT_copy_texture(load);
  load_GL_EXT_cull_vertex(load);
  load_GL_EXT_debug_label(load);
  load_GL_EXT_debug_marker(load);
  load_GL_EXT_depth_bounds_test(load);
  load_GL_EXT_direct_state_access(load);
  load_GL_EXT_draw_buffers2(load);
  load_GL_EXT_draw_instanced(load);
  load_GL_EXT_draw_range_elements(load);
  load_GL_EXT_external_buffer(load);
  load_GL_EXT_fog_coord(load);
  load_GL_EXT_framebuffer_blit(load);
  load_GL_EXT_framebuffer_blit_layers(load);
  load_GL_EXT_framebuffer_multisample(load);
  load_GL_EXT_framebuffer_object(load);
  load_GL_EXT_geometry_shader4(load);
  load_GL_EXT_gpu_program_parameters(load);
  load_GL_EXT_gpu_shader4(load);
  load_GL_EXT_histogram(load);
  load_GL_EXT_index_func(load);
  load_GL_EXT_index_material(load);
  load_GL_EXT_light_texture(load);
  load_GL_EXT_memory_object(load);
  load_GL_EXT_memory_object_fd(load);
  load_GL_EXT_memory_object_win32(load);
  load_GL_EXT_multi_draw_arrays(load);
  load_GL_EXT_multisample(load);
  load_GL_EXT_paletted_texture(load);
  load_GL_EXT_pixel_transform(load);
  load_GL_EXT_point_parameters(load);
  load_GL_EXT_polygon_offset(load);
  load_GL_EXT_polygon_offset_clamp(load);
  load_GL_EXT_provoking_vertex(load);
  load_GL_EXT_raster_multisample(load);
  load_GL_EXT_secondary_color(load);
  load_GL_EXT_semaphore(load);
  load_GL_EXT_semaphore_fd(load);
  load_GL_EXT_semaphore_win32(load);
  load_GL_EXT_separate_shader_objects(load);
  load_GL_EXT_shader_framebuffer_fetch_non_coherent(load);
  load_GL_EXT_shader_image_load_store(load);
  load_GL_EXT_stencil_clear_tag(load);
  load_GL_EXT_stencil_two_side(load);
  load_GL_EXT_subtexture(load);
  load_GL_EXT_texture3D(load);
  load_GL_EXT_texture_array(load);
  load_GL_EXT_texture_buffer_object(load);
  load_GL_EXT_texture_integer(load);
  load_GL_EXT_texture_object(load);
  load_GL_EXT_texture_perturb_normal(load);
  load_GL_EXT_texture_storage(load);
  load_GL_EXT_timer_query(load);
  load_GL_EXT_transform_feedback(load);
  load_GL_EXT_vertex_array(load);
  load_GL_EXT_vertex_attrib_64bit(load);
  load_GL_EXT_vertex_shader(load);
  load_GL_EXT_vertex_weighting(load);
  load_GL_EXT_win32_keyed_mutex(load);
  load_GL_EXT_window_rectangles(load);
  load_GL_EXT_x11_sync_object(load);
  load_GL_GREMEDY_frame_terminator(load);
  load_GL_GREMEDY_string_marker(load);
  load_GL_HP_image_transform(load);
  load_GL_IBM_multimode_draw_arrays(load);
  load_GL_IBM_static_data(load);
  load_GL_IBM_vertex_array_lists(load);
  load_GL_INGR_blend_func_separate(load);
  load_GL_INTEL_framebuffer_CMAA(load);
  load_GL_INTEL_map_texture(load);
  load_GL_INTEL_parallel_arrays(load);
  load_GL_INTEL_performance_query(load);
  load_GL_KHR_blend_equation_advanced(load);
  load_GL_KHR_debug(load);
  load_GL_KHR_parallel_shader_compile(load);
  load_GL_KHR_robustness(load);
  load_GL_MESA_framebuffer_flip_y(load);
  load_GL_MESA_resize_buffers(load);
  load_GL_MESA_window_pos(load);
  load_GL_NVX_conditional_render(load);
  load_GL_NVX_gpu_multicast2(load);
  load_GL_NVX_linked_gpu_multicast(load);
  load_GL_NVX_progress_fence(load);
  load_GL_NV_alpha_to_coverage_dither_control(load);
  load_GL_NV_bindless_multi_draw_indirect(load);
  load_GL_NV_bindless_multi_draw_indirect_count(load);
  load_GL_NV_bindless_texture(load);
  load_GL_NV_blend_equation_advanced(load);
  load_GL_NV_clip_space_w_scaling(load);
  load_GL_NV_command_list(load);
  load_GL_NV_conditional_render(load);
  load_GL_NV_conservative_raster(load);
  load_GL_NV_conservative_raster_dilate(load);
  load_GL_NV_conservative_raster_pre_snap_triangles(load);
  load_GL_NV_copy_image(load);
  load_GL_NV_depth_buffer_float(load);
  load_GL_NV_draw_texture(load);
  load_GL_NV_draw_vulkan_image(load);
  load_GL_NV_evaluators(load);
  load_GL_NV_explicit_multisample(load);
  load_GL_NV_fence(load);
  load_GL_NV_fragment_coverage_to_color(load);
  load_GL_NV_fragment_program(load);
  load_GL_NV_framebuffer_mixed_samples(load);
  load_GL_NV_framebuffer_multisample_coverage(load);
  load_GL_NV_geometry_program4(load);
  load_GL_NV_gpu_multicast(load);
  load_GL_NV_gpu_program4(load);
  load_GL_NV_gpu_program5(load);
  load_GL_NV_gpu_shader5(load);
  load_GL_NV_half_float(load);
  load_GL_NV_internalformat_sample_query(load);
  load_GL_NV_memory_attachment(load);
  load_GL_NV_memory_object_sparse(load);
  load_GL_NV_mesh_shader(load);
  load_GL_NV_occlusion_query(load);
  load_GL_NV_parameter_buffer_object(load);
  load_GL_NV_path_rendering(load);
  load_GL_NV_pixel_data_range(load);
  load_GL_NV_point_sprite(load);
  load_GL_NV_present_video(load);
  load_GL_NV_primitive_restart(load);
  load_GL_NV_query_resource(load);
  load_GL_NV_query_resource_tag(load);
  load_GL_NV_register_combiners(load);
  load_GL_NV_register_combiners2(load);
  load_GL_NV_sample_locations(load);
  load_GL_NV_scissor_exclusive(load);
  load_GL_NV_shader_buffer_load(load);
  load_GL_NV_shading_rate_image(load);
  load_GL_NV_texture_barrier(load);
  load_GL_NV_texture_multisample(load);
  load_GL_NV_timeline_semaphore(load);
  load_GL_NV_transform_feedback(load);
  load_GL_NV_transform_feedback2(load);
  load_GL_NV_vdpau_interop(load);
  load_GL_NV_vdpau_interop2(load);
  load_GL_NV_vertex_array_range(load);
  load_GL_NV_vertex_attrib_integer_64bit(load);
  load_GL_NV_vertex_buffer_unified_memory(load);
  load_GL_NV_vertex_program(load);
  load_GL_NV_vertex_program4(load);
  load_GL_NV_video_capture(load);
  load_GL_NV_viewport_swizzle(load);
  load_GL_OES_byte_coordinates(load);
  load_GL_OES_fixed_point(load);
  load_GL_OES_query_matrix(load);
  load_GL_OES_single_precision(load);
  load_GL_OVR_multiview(load);
  load_GL_PGI_misc_hints(load);
  load_GL_SGIS_detail_texture(load);
  load_GL_SGIS_fog_function(load);
  load_GL_SGIS_multisample(load);
  load_GL_SGIS_pixel_texture(load);
  load_GL_SGIS_point_parameters(load);
  load_GL_SGIS_sharpen_texture(load);
  load_GL_SGIS_texture4D(load);
  load_GL_SGIS_texture_color_mask(load);
  load_GL_SGIS_texture_filter4(load);
  load_GL_SGIX_async(load);
  load_GL_SGIX_flush_raster(load);
  load_GL_SGIX_fragment_lighting(load);
  load_GL_SGIX_framezoom(load);
  load_GL_SGIX_igloo_interface(load);
  load_GL_SGIX_instruments(load);
  load_GL_SGIX_list_priority(load);
  load_GL_SGIX_pixel_texture(load);
  load_GL_SGIX_polynomial_ffd(load);
  load_GL_SGIX_reference_plane(load);
  load_GL_SGIX_sprite(load);
  load_GL_SGIX_tag_sample_buffer(load);
  load_GL_SGI_color_table(load);
  load_GL_SUNX_constant_data(load);
  load_GL_SUN_global_alpha(load);
  load_GL_SUN_mesh_array(load);
  load_GL_SUN_triangle_list(load);
  load_GL_SUN_vertex(load);

  result := (glVersionMajor <> 0) or (glVersionMinor <> 0);
end;


// === Eigenes

//var
//  LibGL: TLibHandle;
//
//{$IFDEF Linux}
//function wglGetProcAddress(proc: pansichar): Pointer;
//begin
//  Result := GetProcAddress(LibGL, proc);
//end;
//{$ENDIF}
//
//{$IFDEF Windows}
//function wglGetProcAddress(proc: pansichar): Pointer; cdecl external 'OpenGL32.dll';
//{$ENDIF}
//
//function LoadProc(proc: pansichar): TLoadProc;
//const
//  First: boolean = True;
//begin
//  Result := GetProcAddress(LibGL, proc);
//  {$IFDEF Windows}
//  {$push}
//  {$i-}
//  if First then begin
//    WriteLn('');
//    First := False;
//  end;
//  {$pop}
//  if @Result = nil then  begin
//    Result := wglGetProcAddress(proc);
//  end;
//  {$ENDIF}
//end;
//
//procedure Load_GLADEExt;
//begin
//  {$IFDEF Linux}
//  LibGL := LoadLibrary(pansichar('libGL.so.1'));
//  {$ENDIF}
//  {$IFDEF Windows}
//  LibGL := LoadLibrary(pansichar('OpenGL32.dll'));
//  {$ENDIF}
////  gladLoadGL(@LoadProc);
//  gladLoadGLExt(@LoadProc);
//end;
begin
end.
